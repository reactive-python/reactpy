{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/changelog/","title":"Changelog \ud83d\udea7","text":"<p>    The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.    </p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Nothing (yet)</li> </ul>"},{"location":"learn/add-react-to-an-existing-project/","title":"Add React to an Existing Project","text":""},{"location":"learn/add-react-to-an-existing-project/#overview","title":"Overview","text":"<p>  If you want to add some interactivity to your existing project, you don't have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.  </p>"},{"location":"learn/add-react-to-an-existing-project/#using-react-for-an-entire-subroute-of-your-existing-website","title":"Using React for an entire subroute of your existing website","text":"<p>Let's say you have an existing web app at <code>example.com</code> built with another server technology (like Rails), and you want to implement all routes starting with <code>example.com/some-app/</code> fully with React.</p>"},{"location":"learn/add-react-to-an-existing-project/#using-an-asgi-subroute","title":"Using an ASGI subroute","text":"<p>Here's how we recommend to set it up:</p> <ol> <li>Build the React part of your app using one of the ReactPy executors.</li> <li>Specify <code>/some-app</code> as the base path in your executors kwargs (<code>path_prefix=\"/some-app\"</code>).</li> <li>Configure your server or a proxy so that all requests under <code>/some-app/</code> are handled by your React app.</li> </ol> <p>This ensures the React part of your app can benefit from the best practices baked into those frameworks.</p>"},{"location":"learn/add-react-to-an-existing-project/#using-static-site-generation-ssg","title":"Using static site generation (SSG)","text":"<p>Support for SSG is coming in a future version.</p>"},{"location":"learn/add-react-to-an-existing-project/#using-react-for-a-part-of-your-existing-page","title":"Using React for a part of your existing page","text":"<p>Let's say you have an existing page built with another Python web technology (ASGI or WSGI), and you want to render interactive React components somewhere on that page.</p> <p>The exact approach depends on your existing page setup, so let's walk through some details.</p>"},{"location":"learn/add-react-to-an-existing-project/#using-asgi-middleware","title":"Using ASGI Middleware","text":"<p>ReactPy supports running as middleware for any existing ASGI application. ReactPy components are embedded into your existing HTML templates using Jinja2. You can use any ASGI framework, however for demonstration purposes we have selected Starlette for the example below.</p> <p>First, install ReactPy, Starlette, and your preferred ASGI webserver.</p> <p>Terminal</p> <pre><code>pip install reactpy[asgi,jinja] starlette uvicorn[standard]\n</code></pre> <p>Next, configure your ASGI framework to use ReactPy's Jinja2 template tag. The method for doing this will vary depending on the ASGI framework you are using. Below is an example that follow's Starlette's documentation:</p> <pre><code>from jinja2 import Environment, FileSystemLoader\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\nfrom starlette.templating import Jinja2Templates\n\nfrom reactpy.templatetags import ReactPyJinja\njinja_templates = Jinja2Templates(\n    env=Environment(\n        loader=FileSystemLoader(\"path/to/my_templates\"),\nextensions=[ReactPyJinja],\n)\n)\n\n\nasync def example_webpage(request):\nreturn jinja_templates.TemplateResponse(request, \"my_template.html\")\nstarlette_app = Starlette(routes=[Route(\"/\", example_webpage)])\n</code></pre> <p>Now you will need to wrap your existing ASGI application with ReactPy's middleware, define the dotted path to your root components, and render your components in your existing HTML templates.</p> <p>Note</p> <p>The <code>ReactPyJinja</code> extension enables a handful of template tags that allow you to render ReactPy components in your templates. The <code>component</code> tag is used to render a ReactPy SSR component, while the <code>pyscript_setup</code> and <code>pyscript_component</code> tags can be used together to render CSR components.</p> main.pymy_components.pymy_template.html <pre><code>from jinja2 import Environment, FileSystemLoader\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\nfrom starlette.templating import Jinja2Templates\n\nfrom reactpy.executors.asgi import ReactPyMiddleware\nfrom reactpy.templatetags import ReactPyJinja\n\njinja_templates = Jinja2Templates(\n    env=Environment(\n        loader=FileSystemLoader(\"path/to/my_templates\"),\n        extensions=[ReactPyJinja],\n    )\n)\n\n\nasync def example_webpage(request):\n    return jinja_templates.TemplateResponse(request, \"my_template.html\")\n\n\nstarlette_app = Starlette(routes=[Route(\"/\", example_webpage)])\nreactpy_app = ReactPyMiddleware(starlette_app, [\"my_components.hello_world\"])\n</code></pre> <pre><code>from reactpy import component, html\n\n\n@component\ndef hello_world():\n    return html.div(\"Hello World\")\n</code></pre> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n&lt;title&gt;ReactPy in Django&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  {% component \"my_components.hello_world\" %}\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> <p>Finally, use your webserver of choice to start ReactPy:</p> <p>Terminal</p> <pre><code>uvicorn main:reactpy_app\n</code></pre>"},{"location":"learn/add-react-to-an-existing-project/#using-wsgi-middleware","title":"Using WSGI Middleware","text":"<p>Support for WSGI executors is coming in a future version.</p>"},{"location":"learn/add-react-to-an-existing-project/#external-executors","title":"External Executors","text":"<p>Note</p> <p>External executors exist outside ReactPy's core library and have significantly different installation and configuration instructions.</p> <p>Make sure to follow the documentation for setting up your chosen external executor.</p>"},{"location":"learn/add-react-to-an-existing-project/#django","title":"Django","text":"<p>Django is a full-featured web framework that provides a batteries-included approach to web development.</p> <p>Due to it's batteries-included approach, ReactPy has unique features only available to this executor.</p> <p>To learn how to configure Django for ReactPy, see the ReactPy-Django documentation.</p>"},{"location":"learn/choosing-the-state-structure/","title":"Choosing the State Structure \ud83d\udea7","text":""},{"location":"learn/choosing-the-state-structure/#overview","title":"Overview","text":"<p>  Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. Here are some tips you should consider when structuring state.  </p> <p>You will learn</p> <ul> <li>When to use a single vs multiple state variables</li> <li>What to avoid when organizing state</li> <li>How to fix common issues with the state structure</li> </ul>"},{"location":"learn/choosing-the-state-structure/#principles-for-structuring-state","title":"Principles for structuring state","text":"<p>When you write a component that holds some state, you'll have to make choices about how many state variables to use and what the shape of their data should be. While it's possible to write correct programs even with a suboptimal state structure, there are a few principles that can guide you to make better choices:</p> <ol> <li>Group related state. If you always update two or more state variables at the same time, consider merging them into a single state variable.</li> <li>Avoid contradictions in state. When the state is structured in a way that several pieces of state may contradict and \"disagree\" with each other, you leave room for mistakes. Try to avoid this.</li> <li>Avoid redundant state. If you can calculate some information from the component's props or its existing state variables during rendering, you should not put that information into that component's state.</li> <li>Avoid duplication in state. When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.</li> <li>Avoid deeply nested state. Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.</li> </ol> <p>The goal behind these principles is to make state easy to update without introducing mistakes. Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. This is similar to how a database engineer might want to \"normalize\" the database structure to reduce the chance of bugs. To paraphrase Albert Einstein, \"Make your state as simple as it can be--but no simpler.\"</p> <p>Now let's see how these principles apply in action.</p>"},{"location":"learn/choosing-the-state-structure/#group-related-state","title":"Group related state","text":"<p>You might sometimes be unsure between using a single or multiple state variables.</p> <p>Should you do this?</p> <pre><code>const [x, setX] = useState(0);\nconst [y, setY] = useState(0);\n</code></pre> <p>Or this?</p> <pre><code>const [position, setPosition] = useState({ x: 0, y: 0 });\n</code></pre> <p>Technically, you can use either of these approaches. But if some two state variables always change together, it might be a good idea to unify them into a single state variable. Then you won't forget to always keep them in sync, like in this example where moving the cursor updates both coordinates of the red dot:</p> <pre><code>import { useState } from \"react\";\n\nexport default function MovingDot() {\nconst [position, setPosition] = useState({\nx: 0,\ny: 0,\n});\nreturn (\n&lt;div\nonPointerMove={(e) =&gt; {\nsetPosition({\nx: e.clientX,\ny: e.clientY,\n});\n}}\nstyle={{\nposition: \"relative\",\nwidth: \"100vw\",\nheight: \"100vh\",\n}}\n&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"red\",\nborderRadius: \"50%\",\ntransform: `translate(${position.x}px, ${position.y}px)`,\nleft: -10,\ntop: -10,\nwidth: 20,\nheight: 20,\n}}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n</code></pre> <p>Another case where you'll group data into an object or an array is when you don't know how many pieces of state you'll need. For example, it's helpful when you have a form where the user can add custom fields.</p> <p> <p>If your state variable is an object, remember that you can't update only one field in it without explicitly copying the other fields. For example, you can't do <code>setPosition({ x: 100 })</code> in the above example because it would not have the <code>y</code> property at all! Instead, if you wanted to set <code>x</code> alone, you would either do <code>setPosition({ ...position, x: 100 })</code>, or split them into two state variables and do <code>setX(100)</code>.</p> <p></p>"},{"location":"learn/choosing-the-state-structure/#avoid-contradictions-in-state","title":"Avoid contradictions in state","text":"<p>Here is a hotel feedback form with <code>isSending</code> and <code>isSent</code> state variables:</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [text, setText] = useState(\"\");\nconst [isSending, setIsSending] = useState(false);\nconst [isSent, setIsSent] = useState(false);\n\nasync function handleSubmit(e) {\ne.preventDefault();\nsetIsSending(true);\nawait sendMessage(text);\nsetIsSending(false);\nsetIsSent(true);\n}\n\nif (isSent) {\nreturn &lt;h1&gt;Thanks for feedback!&lt;/h1&gt;;\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;p&gt;How was your stay at The Prancing Pony?&lt;/p&gt;\n&lt;textarea\ndisabled={isSending}\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button disabled={isSending} type=\"submit\"&gt;\nSend\n&lt;/button&gt;\n{isSending &amp;&amp; &lt;p&gt;Sending...&lt;/p&gt;}\n&lt;/form&gt;\n);\n}\n\n// Pretend to send a message.\nfunction sendMessage(text) {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(resolve, 2000);\n});\n}\n</code></pre> <p>While this code works, it leaves the door open for \"impossible\" states. For example, if you forget to call <code>setIsSent</code> and <code>setIsSending</code> together, you may end up in a situation where both <code>isSending</code> and <code>isSent</code> are <code>true</code> at the same time. The more complex your component is, the harder it is to understand what happened.</p> <p>Since <code>isSending</code> and <code>isSent</code> should never be <code>true</code> at the same time, it is better to replace them with one <code>status</code> state variable that may take one of three valid states: <code>'typing'</code> (initial), <code>'sending'</code>, and <code>'sent'</code>:</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [text, setText] = useState(\"\");\nconst [status, setStatus] = useState(\"typing\");\n\nasync function handleSubmit(e) {\ne.preventDefault();\nsetStatus(\"sending\");\nawait sendMessage(text);\nsetStatus(\"sent\");\n}\n\nconst isSending = status === \"sending\";\nconst isSent = status === \"sent\";\n\nif (isSent) {\nreturn &lt;h1&gt;Thanks for feedback!&lt;/h1&gt;;\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;p&gt;How was your stay at The Prancing Pony?&lt;/p&gt;\n&lt;textarea\ndisabled={isSending}\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button disabled={isSending} type=\"submit\"&gt;\nSend\n&lt;/button&gt;\n{isSending &amp;&amp; &lt;p&gt;Sending...&lt;/p&gt;}\n&lt;/form&gt;\n);\n}\n\n// Pretend to send a message.\nfunction sendMessage(text) {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(resolve, 2000);\n});\n}\n</code></pre> <p>You can still declare some constants for readability:</p> <pre><code>const isSending = status === \"sending\";\nconst isSent = status === \"sent\";\n</code></pre> <p>But they're not state variables, so you don't need to worry about them getting out of sync with each other.</p>"},{"location":"learn/choosing-the-state-structure/#avoid-redundant-state","title":"Avoid redundant state","text":"<p>If you can calculate some information from the component's props or its existing state variables during rendering, you should not put that information into that component's state.</p> <p>For example, take this form. It works, but can you find any redundant state in it?</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\nconst [fullName, setFullName] = useState(\"\");\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\nsetFullName(e.target.value + \" \" + lastName);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\nsetFullName(firstName + \" \" + e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Let\u2019s check you in&lt;/h2&gt;\n&lt;label&gt;\nFirst name:{\" \"}\n&lt;input value={firstName} onChange={handleFirstNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:{\" \"}\n&lt;input value={lastName} onChange={handleLastNameChange} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\nYour ticket will be issued to: &lt;b&gt;{fullName}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <p>This form has three state variables: <code>firstName</code>, <code>lastName</code>, and <code>fullName</code>. However, <code>fullName</code> is redundant. You can always calculate <code>fullName</code> from <code>firstName</code> and <code>lastName</code> during render, so remove it from state.</p> <p>This is how you can do it:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\n\nconst fullName = firstName + \" \" + lastName;\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Let\u2019s check you in&lt;/h2&gt;\n&lt;label&gt;\nFirst name:{\" \"}\n&lt;input value={firstName} onChange={handleFirstNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:{\" \"}\n&lt;input value={lastName} onChange={handleLastNameChange} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\nYour ticket will be issued to: &lt;b&gt;{fullName}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <p>Here, <code>fullName</code> is not a state variable. Instead, it's calculated during render:</p> <pre><code>const fullName = firstName + \" \" + lastName;\n</code></pre> <p>As a result, the change handlers don't need to do anything special to update it. When you call <code>setFirstName</code> or <code>setLastName</code>, you trigger a re-render, and then the next <code>fullName</code> will be calculated from the fresh data.</p> <p>"},{"location":"learn/choosing-the-state-structure/#dont-mirror-props-in-state","title":"Don't mirror props in state","text":"<p>A common example of redundant state is code like this:</p> <pre><code>function Message({ messageColor }) {\nconst [color, setColor] = useState(messageColor);\n</code></pre> <p>Here, a <code>color</code> state variable is initialized to the <code>messageColor</code> prop. The problem is that if the parent component passes a different value of <code>messageColor</code> later (for example, <code>'red'</code> instead of <code>'blue'</code>), the <code>color</code> state variable would not be updated! The state is only initialized during the first render.</p> <p>This is why \"mirroring\" some prop in a state variable can lead to confusion. Instead, use the <code>messageColor</code> prop directly in your code. If you want to give it a shorter name, use a constant:</p> <pre><code>function Message({ messageColor }) {\nconst color = messageColor;\n</code></pre> <p>This way it won't get out of sync with the prop passed from the parent component.</p> <p>\"Mirroring\" props into state only makes sense when you want to ignore all updates for a specific prop. By convention, start the prop name with <code>initial</code> or <code>default</code> to clarify that its new values are ignored:</p> <pre><code>function Message({ initialColor }) {\n// The `color` state variable holds the *first* value of `initialColor`.\n// Further changes to the `initialColor` prop are ignored.\nconst [color, setColor] = useState(initialColor);\n</code></pre> <p></p>"},{"location":"learn/choosing-the-state-structure/#avoid-duplication-in-state","title":"Avoid duplication in state","text":"<p>This menu list component lets you choose a single travel snack out of several:</p> <pre><code>import { useState } from \"react\";\n\nconst initialItems = [\n{ title: \"pretzels\", id: 0 },\n{ title: \"crispy seaweed\", id: 1 },\n{ title: \"granola bar\", id: 2 },\n];\n\nexport default function Menu() {\nconst [items, setItems] = useState(initialItems);\nconst [selectedItem, setSelectedItem] = useState(items[0]);\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;What's your travel snack?&lt;/h2&gt;\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n{item.title}{\" \"}\n&lt;button\non_click={() =&gt; {\nsetSelectedItem(item);\n}}\n&gt;\nChoose\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;p&gt;You picked {selectedItem.title}.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-top: 10px;\n}\n</code></pre> <p>Currently, it stores the selected item as an object in the <code>selectedItem</code> state variable. However, this is not great: the contents of the <code>selectedItem</code> is the same object as one of the items inside the <code>items</code> list. This means that the information about the item itself is duplicated in two places.</p> <p>Why is this a problem? Let's make each item editable:</p> <pre><code>import { useState } from \"react\";\n\nconst initialItems = [\n{ title: \"pretzels\", id: 0 },\n{ title: \"crispy seaweed\", id: 1 },\n{ title: \"granola bar\", id: 2 },\n];\n\nexport default function Menu() {\nconst [items, setItems] = useState(initialItems);\nconst [selectedItem, setSelectedItem] = useState(items[0]);\n\nfunction handleItemChange(id, e) {\nsetItems(\nitems.map((item) =&gt; {\nif (item.id === id) {\nreturn {\n...item,\ntitle: e.target.value,\n};\n} else {\nreturn item;\n}\n})\n);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;What's your travel snack?&lt;/h2&gt;\n&lt;ul&gt;\n{items.map((item, index) =&gt; (\n&lt;li key={item.id}&gt;\n&lt;input\nvalue={item.title}\nonChange={(e) =&gt; {\nhandleItemChange(item.id, e);\n}}\n/&gt;{\" \"}\n&lt;button\non_click={() =&gt; {\nsetSelectedItem(item);\n}}\n&gt;\nChoose\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;p&gt;You picked {selectedItem.title}.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-top: 10px;\n}\n</code></pre> <p>Notice how if you first click \"Choose\" on an item and then edit it, the input updates but the label at the bottom does not reflect the edits. This is because you have duplicated state, and you forgot to update <code>selectedItem</code>.</p> <p>Although you could update <code>selectedItem</code> too, an easier fix is to remove duplication. In this example, instead of a <code>selectedItem</code> object (which creates a duplication with objects inside <code>items</code>), you hold the <code>selectedId</code> in state, and then get the <code>selectedItem</code> by searching the <code>items</code> array for an item with that ID:</p> <pre><code>import { useState } from \"react\";\n\nconst initialItems = [\n{ title: \"pretzels\", id: 0 },\n{ title: \"crispy seaweed\", id: 1 },\n{ title: \"granola bar\", id: 2 },\n];\n\nexport default function Menu() {\nconst [items, setItems] = useState(initialItems);\nconst [selectedId, setSelectedId] = useState(0);\n\nconst selectedItem = items.find((item) =&gt; item.id === selectedId);\n\nfunction handleItemChange(id, e) {\nsetItems(\nitems.map((item) =&gt; {\nif (item.id === id) {\nreturn {\n...item,\ntitle: e.target.value,\n};\n} else {\nreturn item;\n}\n})\n);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;What's your travel snack?&lt;/h2&gt;\n&lt;ul&gt;\n{items.map((item, index) =&gt; (\n&lt;li key={item.id}&gt;\n&lt;input\nvalue={item.title}\nonChange={(e) =&gt; {\nhandleItemChange(item.id, e);\n}}\n/&gt;{\" \"}\n&lt;button\non_click={() =&gt; {\nsetSelectedId(item.id);\n}}\n&gt;\nChoose\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;p&gt;You picked {selectedItem.title}.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-top: 10px;\n}\n</code></pre> <p>(Alternatively, you may hold the selected index in state.)</p> <p>The state used to be duplicated like this:</p> <ul> <li><code>items = [{ id: 0, title: 'pretzels'}, ...]</code></li> <li><code>selectedItem = {id: 0, title: 'pretzels'}</code></li> </ul> <p>But after the change it's like this:</p> <ul> <li><code>items = [{ id: 0, title: 'pretzels'}, ...]</code></li> <li><code>selectedId = 0</code></li> </ul> <p>The duplication is gone, and you only keep the essential state!</p> <p>Now if you edit the selected item, the message below will update immediately. This is because <code>setItems</code> triggers a re-render, and <code>items.find(...)</code> would find the item with the updated title. You didn't need to hold the selected item in state, because only the selected ID is essential. The rest could be calculated during render.</p>"},{"location":"learn/choosing-the-state-structure/#avoid-deeply-nested-state","title":"Avoid deeply nested state","text":"<p>Imagine a travel plan consisting of planets, continents, and countries. You might be tempted to structure its state using nested objects and arrays, like in this example:</p> <pre><code>import { useState } from \"react\";\nimport { initialTravelPlan } from \"./places.js\";\n\nfunction PlaceTree({ place }) {\nconst childPlaces = place.childPlaces;\nreturn (\n&lt;li&gt;\n{place.title}\n{childPlaces.length &gt; 0 &amp;&amp; (\n&lt;ol&gt;\n{childPlaces.map((place) =&gt; (\n&lt;PlaceTree key={place.id} place={place} /&gt;\n))}\n&lt;/ol&gt;\n)}\n&lt;/li&gt;\n);\n}\n\nexport default function TravelPlan() {\nconst [plan, setPlan] = useState(initialTravelPlan);\nconst planets = plan.childPlaces;\nreturn (\n&lt;&gt;\n&lt;h2&gt;Places to visit&lt;/h2&gt;\n&lt;ol&gt;\n{planets.map((place) =&gt; (\n&lt;PlaceTree key={place.id} place={place} /&gt;\n))}\n&lt;/ol&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const initialTravelPlan = {\nid: 0,\ntitle: \"(Root)\",\nchildPlaces: [\n{\nid: 1,\ntitle: \"Earth\",\nchildPlaces: [\n{\nid: 2,\ntitle: \"Africa\",\nchildPlaces: [\n{\nid: 3,\ntitle: \"Botswana\",\nchildPlaces: [],\n},\n{\nid: 4,\ntitle: \"Egypt\",\nchildPlaces: [],\n},\n{\nid: 5,\ntitle: \"Kenya\",\nchildPlaces: [],\n},\n{\nid: 6,\ntitle: \"Madagascar\",\nchildPlaces: [],\n},\n{\nid: 7,\ntitle: \"Morocco\",\nchildPlaces: [],\n},\n{\nid: 8,\ntitle: \"Nigeria\",\nchildPlaces: [],\n},\n{\nid: 9,\ntitle: \"South Africa\",\nchildPlaces: [],\n},\n],\n},\n{\nid: 10,\ntitle: \"Americas\",\nchildPlaces: [\n{\nid: 11,\ntitle: \"Argentina\",\nchildPlaces: [],\n},\n{\nid: 12,\ntitle: \"Brazil\",\nchildPlaces: [],\n},\n{\nid: 13,\ntitle: \"Barbados\",\nchildPlaces: [],\n},\n{\nid: 14,\ntitle: \"Canada\",\nchildPlaces: [],\n},\n{\nid: 15,\ntitle: \"Jamaica\",\nchildPlaces: [],\n},\n{\nid: 16,\ntitle: \"Mexico\",\nchildPlaces: [],\n},\n{\nid: 17,\ntitle: \"Trinidad and Tobago\",\nchildPlaces: [],\n},\n{\nid: 18,\ntitle: \"Venezuela\",\nchildPlaces: [],\n},\n],\n},\n{\nid: 19,\ntitle: \"Asia\",\nchildPlaces: [\n{\nid: 20,\ntitle: \"China\",\nchildPlaces: [],\n},\n{\nid: 21,\ntitle: \"Hong Kong\",\nchildPlaces: [],\n},\n{\nid: 22,\ntitle: \"India\",\nchildPlaces: [],\n},\n{\nid: 23,\ntitle: \"Singapore\",\nchildPlaces: [],\n},\n{\nid: 24,\ntitle: \"South Korea\",\nchildPlaces: [],\n},\n{\nid: 25,\ntitle: \"Thailand\",\nchildPlaces: [],\n},\n{\nid: 26,\ntitle: \"Vietnam\",\nchildPlaces: [],\n},\n],\n},\n{\nid: 27,\ntitle: \"Europe\",\nchildPlaces: [\n{\nid: 28,\ntitle: \"Croatia\",\nchildPlaces: [],\n},\n{\nid: 29,\ntitle: \"France\",\nchildPlaces: [],\n},\n{\nid: 30,\ntitle: \"Germany\",\nchildPlaces: [],\n},\n{\nid: 31,\ntitle: \"Italy\",\nchildPlaces: [],\n},\n{\nid: 32,\ntitle: \"Portugal\",\nchildPlaces: [],\n},\n{\nid: 33,\ntitle: \"Spain\",\nchildPlaces: [],\n},\n{\nid: 34,\ntitle: \"Turkey\",\nchildPlaces: [],\n},\n],\n},\n{\nid: 35,\ntitle: \"Oceania\",\nchildPlaces: [\n{\nid: 36,\ntitle: \"Australia\",\nchildPlaces: [],\n},\n{\nid: 37,\ntitle: \"Bora Bora (French Polynesia)\",\nchildPlaces: [],\n},\n{\nid: 38,\ntitle: \"Easter Island (Chile)\",\nchildPlaces: [],\n},\n{\nid: 39,\ntitle: \"Fiji\",\nchildPlaces: [],\n},\n{\nid: 40,\ntitle: \"Hawaii (the USA)\",\nchildPlaces: [],\n},\n{\nid: 41,\ntitle: \"New Zealand\",\nchildPlaces: [],\n},\n{\nid: 42,\ntitle: \"Vanuatu\",\nchildPlaces: [],\n},\n],\n},\n],\n},\n{\nid: 43,\ntitle: \"Moon\",\nchildPlaces: [\n{\nid: 44,\ntitle: \"Rheita\",\nchildPlaces: [],\n},\n{\nid: 45,\ntitle: \"Piccolomini\",\nchildPlaces: [],\n},\n{\nid: 46,\ntitle: \"Tycho\",\nchildPlaces: [],\n},\n],\n},\n{\nid: 47,\ntitle: \"Mars\",\nchildPlaces: [\n{\nid: 48,\ntitle: \"Corn Town\",\nchildPlaces: [],\n},\n{\nid: 49,\ntitle: \"Green Hill\",\nchildPlaces: [],\n},\n],\n},\n],\n};\n</code></pre> <p>Now let's say you want to add a button to delete a place you've already visited. How would you go about it? Updating nested state involves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose.</p> <p>If the state is too nested to update easily, consider making it \"flat\". Here is one way you can restructure this data. Instead of a tree-like structure where each <code>place</code> has an array of its child places, you can have each place hold an array of its child place IDs. Then store a mapping from each place ID to the corresponding place.</p> <p>This data restructuring might remind you of seeing a database table:</p> <pre><code>import { useState } from \"react\";\nimport { initialTravelPlan } from \"./places.js\";\n\nfunction PlaceTree({ id, placesById }) {\nconst place = placesById[id];\nconst childIds = place.childIds;\nreturn (\n&lt;li&gt;\n{place.title}\n{childIds.length &gt; 0 &amp;&amp; (\n&lt;ol&gt;\n{childIds.map((childId) =&gt; (\n&lt;PlaceTree\nkey={childId}\nid={childId}\nplacesById={placesById}\n/&gt;\n))}\n&lt;/ol&gt;\n)}\n&lt;/li&gt;\n);\n}\n\nexport default function TravelPlan() {\nconst [plan, setPlan] = useState(initialTravelPlan);\nconst root = plan[0];\nconst planetIds = root.childIds;\nreturn (\n&lt;&gt;\n&lt;h2&gt;Places to visit&lt;/h2&gt;\n&lt;ol&gt;\n{planetIds.map((id) =&gt; (\n&lt;PlaceTree key={id} id={id} placesById={plan} /&gt;\n))}\n&lt;/ol&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const initialTravelPlan = {\n0: {\nid: 0,\ntitle: \"(Root)\",\nchildIds: [1, 43, 47],\n},\n1: {\nid: 1,\ntitle: \"Earth\",\nchildIds: [2, 10, 19, 27, 35],\n},\n2: {\nid: 2,\ntitle: \"Africa\",\nchildIds: [3, 4, 5, 6, 7, 8, 9],\n},\n3: {\nid: 3,\ntitle: \"Botswana\",\nchildIds: [],\n},\n4: {\nid: 4,\ntitle: \"Egypt\",\nchildIds: [],\n},\n5: {\nid: 5,\ntitle: \"Kenya\",\nchildIds: [],\n},\n6: {\nid: 6,\ntitle: \"Madagascar\",\nchildIds: [],\n},\n7: {\nid: 7,\ntitle: \"Morocco\",\nchildIds: [],\n},\n8: {\nid: 8,\ntitle: \"Nigeria\",\nchildIds: [],\n},\n9: {\nid: 9,\ntitle: \"South Africa\",\nchildIds: [],\n},\n10: {\nid: 10,\ntitle: \"Americas\",\nchildIds: [11, 12, 13, 14, 15, 16, 17, 18],\n},\n11: {\nid: 11,\ntitle: \"Argentina\",\nchildIds: [],\n},\n12: {\nid: 12,\ntitle: \"Brazil\",\nchildIds: [],\n},\n13: {\nid: 13,\ntitle: \"Barbados\",\nchildIds: [],\n},\n14: {\nid: 14,\ntitle: \"Canada\",\nchildIds: [],\n},\n15: {\nid: 15,\ntitle: \"Jamaica\",\nchildIds: [],\n},\n16: {\nid: 16,\ntitle: \"Mexico\",\nchildIds: [],\n},\n17: {\nid: 17,\ntitle: \"Trinidad and Tobago\",\nchildIds: [],\n},\n18: {\nid: 18,\ntitle: \"Venezuela\",\nchildIds: [],\n},\n19: {\nid: 19,\ntitle: \"Asia\",\nchildIds: [20, 21, 22, 23, 24, 25, 26],\n},\n20: {\nid: 20,\ntitle: \"China\",\nchildIds: [],\n},\n21: {\nid: 21,\ntitle: \"Hong Kong\",\nchildIds: [],\n},\n22: {\nid: 22,\ntitle: \"India\",\nchildIds: [],\n},\n23: {\nid: 23,\ntitle: \"Singapore\",\nchildIds: [],\n},\n24: {\nid: 24,\ntitle: \"South Korea\",\nchildIds: [],\n},\n25: {\nid: 25,\ntitle: \"Thailand\",\nchildIds: [],\n},\n26: {\nid: 26,\ntitle: \"Vietnam\",\nchildIds: [],\n},\n27: {\nid: 27,\ntitle: \"Europe\",\nchildIds: [28, 29, 30, 31, 32, 33, 34],\n},\n28: {\nid: 28,\ntitle: \"Croatia\",\nchildIds: [],\n},\n29: {\nid: 29,\ntitle: \"France\",\nchildIds: [],\n},\n30: {\nid: 30,\ntitle: \"Germany\",\nchildIds: [],\n},\n31: {\nid: 31,\ntitle: \"Italy\",\nchildIds: [],\n},\n32: {\nid: 32,\ntitle: \"Portugal\",\nchildIds: [],\n},\n33: {\nid: 33,\ntitle: \"Spain\",\nchildIds: [],\n},\n34: {\nid: 34,\ntitle: \"Turkey\",\nchildIds: [],\n},\n35: {\nid: 35,\ntitle: \"Oceania\",\nchildIds: [36, 37, 38, 39, 40, 41, 42],\n},\n36: {\nid: 36,\ntitle: \"Australia\",\nchildIds: [],\n},\n37: {\nid: 37,\ntitle: \"Bora Bora (French Polynesia)\",\nchildIds: [],\n},\n38: {\nid: 38,\ntitle: \"Easter Island (Chile)\",\nchildIds: [],\n},\n39: {\nid: 39,\ntitle: \"Fiji\",\nchildIds: [],\n},\n40: {\nid: 40,\ntitle: \"Hawaii (the USA)\",\nchildIds: [],\n},\n41: {\nid: 41,\ntitle: \"New Zealand\",\nchildIds: [],\n},\n42: {\nid: 42,\ntitle: \"Vanuatu\",\nchildIds: [],\n},\n43: {\nid: 43,\ntitle: \"Moon\",\nchildIds: [44, 45, 46],\n},\n44: {\nid: 44,\ntitle: \"Rheita\",\nchildIds: [],\n},\n45: {\nid: 45,\ntitle: \"Piccolomini\",\nchildIds: [],\n},\n46: {\nid: 46,\ntitle: \"Tycho\",\nchildIds: [],\n},\n47: {\nid: 47,\ntitle: \"Mars\",\nchildIds: [48, 49],\n},\n48: {\nid: 48,\ntitle: \"Corn Town\",\nchildIds: [],\n},\n49: {\nid: 49,\ntitle: \"Green Hill\",\nchildIds: [],\n},\n};\n</code></pre> <p>Now that the state is \"flat\" (also known as \"normalized\"), updating nested items becomes easier.</p> <p>In order to remove a place now, you only need to update two levels of state:</p> <ul> <li>The updated version of its parent place should exclude the removed ID from its <code>childIds</code> array.</li> <li>The updated version of the root \"table\" object should include the updated version of the parent place.</li> </ul> <p>Here is an example of how you could go about it:</p> <pre><code>import { useState } from \"react\";\nimport { initialTravelPlan } from \"./places.js\";\n\nexport default function TravelPlan() {\nconst [plan, setPlan] = useState(initialTravelPlan);\n\nfunction handleComplete(parentId, childId) {\nconst parent = plan[parentId];\n// Create a new version of the parent place\n// that doesn't include this child ID.\nconst nextParent = {\n...parent,\nchildIds: parent.childIds.filter((id) =&gt; id !== childId),\n};\n// Update the root state object...\nsetPlan({\n...plan,\n// ...so that it has the updated parent.\n[parentId]: nextParent,\n});\n}\n\nconst root = plan[0];\nconst planetIds = root.childIds;\nreturn (\n&lt;&gt;\n&lt;h2&gt;Places to visit&lt;/h2&gt;\n&lt;ol&gt;\n{planetIds.map((id) =&gt; (\n&lt;PlaceTree\nkey={id}\nid={id}\nparentId={0}\nplacesById={plan}\nonComplete={handleComplete}\n/&gt;\n))}\n&lt;/ol&gt;\n&lt;/&gt;\n);\n}\n\nfunction PlaceTree({ id, parentId, placesById, onComplete }) {\nconst place = placesById[id];\nconst childIds = place.childIds;\nreturn (\n&lt;li&gt;\n{place.title}\n&lt;button\non_click={() =&gt; {\nonComplete(parentId, id);\n}}\n&gt;\nComplete\n&lt;/button&gt;\n{childIds.length &gt; 0 &amp;&amp; (\n&lt;ol&gt;\n{childIds.map((childId) =&gt; (\n&lt;PlaceTree\nkey={childId}\nid={childId}\nparentId={id}\nplacesById={placesById}\nonComplete={onComplete}\n/&gt;\n))}\n&lt;/ol&gt;\n)}\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const initialTravelPlan = {\n0: {\nid: 0,\ntitle: \"(Root)\",\nchildIds: [1, 43, 47],\n},\n1: {\nid: 1,\ntitle: \"Earth\",\nchildIds: [2, 10, 19, 27, 35],\n},\n2: {\nid: 2,\ntitle: \"Africa\",\nchildIds: [3, 4, 5, 6, 7, 8, 9],\n},\n3: {\nid: 3,\ntitle: \"Botswana\",\nchildIds: [],\n},\n4: {\nid: 4,\ntitle: \"Egypt\",\nchildIds: [],\n},\n5: {\nid: 5,\ntitle: \"Kenya\",\nchildIds: [],\n},\n6: {\nid: 6,\ntitle: \"Madagascar\",\nchildIds: [],\n},\n7: {\nid: 7,\ntitle: \"Morocco\",\nchildIds: [],\n},\n8: {\nid: 8,\ntitle: \"Nigeria\",\nchildIds: [],\n},\n9: {\nid: 9,\ntitle: \"South Africa\",\nchildIds: [],\n},\n10: {\nid: 10,\ntitle: \"Americas\",\nchildIds: [11, 12, 13, 14, 15, 16, 17, 18],\n},\n11: {\nid: 11,\ntitle: \"Argentina\",\nchildIds: [],\n},\n12: {\nid: 12,\ntitle: \"Brazil\",\nchildIds: [],\n},\n13: {\nid: 13,\ntitle: \"Barbados\",\nchildIds: [],\n},\n14: {\nid: 14,\ntitle: \"Canada\",\nchildIds: [],\n},\n15: {\nid: 15,\ntitle: \"Jamaica\",\nchildIds: [],\n},\n16: {\nid: 16,\ntitle: \"Mexico\",\nchildIds: [],\n},\n17: {\nid: 17,\ntitle: \"Trinidad and Tobago\",\nchildIds: [],\n},\n18: {\nid: 18,\ntitle: \"Venezuela\",\nchildIds: [],\n},\n19: {\nid: 19,\ntitle: \"Asia\",\nchildIds: [20, 21, 22, 23, 24, 25, 26],\n},\n20: {\nid: 20,\ntitle: \"China\",\nchildIds: [],\n},\n21: {\nid: 21,\ntitle: \"Hong Kong\",\nchildIds: [],\n},\n22: {\nid: 22,\ntitle: \"India\",\nchildIds: [],\n},\n23: {\nid: 23,\ntitle: \"Singapore\",\nchildIds: [],\n},\n24: {\nid: 24,\ntitle: \"South Korea\",\nchildIds: [],\n},\n25: {\nid: 25,\ntitle: \"Thailand\",\nchildIds: [],\n},\n26: {\nid: 26,\ntitle: \"Vietnam\",\nchildIds: [],\n},\n27: {\nid: 27,\ntitle: \"Europe\",\nchildIds: [28, 29, 30, 31, 32, 33, 34],\n},\n28: {\nid: 28,\ntitle: \"Croatia\",\nchildIds: [],\n},\n29: {\nid: 29,\ntitle: \"France\",\nchildIds: [],\n},\n30: {\nid: 30,\ntitle: \"Germany\",\nchildIds: [],\n},\n31: {\nid: 31,\ntitle: \"Italy\",\nchildIds: [],\n},\n32: {\nid: 32,\ntitle: \"Portugal\",\nchildIds: [],\n},\n33: {\nid: 33,\ntitle: \"Spain\",\nchildIds: [],\n},\n34: {\nid: 34,\ntitle: \"Turkey\",\nchildIds: [],\n},\n35: {\nid: 35,\ntitle: \"Oceania\",\nchildIds: [36, 37, 38, 39, 40, 41, , 42],\n},\n36: {\nid: 36,\ntitle: \"Australia\",\nchildIds: [],\n},\n37: {\nid: 37,\ntitle: \"Bora Bora (French Polynesia)\",\nchildIds: [],\n},\n38: {\nid: 38,\ntitle: \"Easter Island (Chile)\",\nchildIds: [],\n},\n39: {\nid: 39,\ntitle: \"Fiji\",\nchildIds: [],\n},\n40: {\nid: 40,\ntitle: \"Hawaii (the USA)\",\nchildIds: [],\n},\n41: {\nid: 41,\ntitle: \"New Zealand\",\nchildIds: [],\n},\n42: {\nid: 42,\ntitle: \"Vanuatu\",\nchildIds: [],\n},\n43: {\nid: 43,\ntitle: \"Moon\",\nchildIds: [44, 45, 46],\n},\n44: {\nid: 44,\ntitle: \"Rheita\",\nchildIds: [],\n},\n45: {\nid: 45,\ntitle: \"Piccolomini\",\nchildIds: [],\n},\n46: {\nid: 46,\ntitle: \"Tycho\",\nchildIds: [],\n},\n47: {\nid: 47,\ntitle: \"Mars\",\nchildIds: [48, 49],\n},\n48: {\nid: 48,\ntitle: \"Corn Town\",\nchildIds: [],\n},\n49: {\nid: 49,\ntitle: \"Green Hill\",\nchildIds: [],\n},\n};\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p>You can nest state as much as you like, but making it \"flat\" can solve numerous problems. It makes state easier to update, and it helps ensure you don't have duplication in different parts of a nested object.</p> <p>"},{"location":"learn/choosing-the-state-structure/#improving-memory-usage","title":"Improving memory usage","text":"<p>Ideally, you would also remove the deleted items (and their children!) from the \"table\" object to improve memory usage. This version does that. It also uses Immer to make the update logic more concise.</p> <pre><code>import { useImmer } from \"use-immer\";\nimport { initialTravelPlan } from \"./places.js\";\n\nexport default function TravelPlan() {\nconst [plan, updatePlan] = useImmer(initialTravelPlan);\n\nfunction handleComplete(parentId, childId) {\nupdatePlan((draft) =&gt; {\n// Remove from the parent place's child IDs.\nconst parent = draft[parentId];\nparent.childIds = parent.childIds.filter((id) =&gt; id !== childId);\n\n// Forget this place and all its subtree.\ndeleteAllChildren(childId);\nfunction deleteAllChildren(id) {\nconst place = draft[id];\nplace.childIds.forEach(deleteAllChildren);\ndelete draft[id];\n}\n});\n}\n\nconst root = plan[0];\nconst planetIds = root.childIds;\nreturn (\n&lt;&gt;\n&lt;h2&gt;Places to visit&lt;/h2&gt;\n&lt;ol&gt;\n{planetIds.map((id) =&gt; (\n&lt;PlaceTree\nkey={id}\nid={id}\nparentId={0}\nplacesById={plan}\nonComplete={handleComplete}\n/&gt;\n))}\n&lt;/ol&gt;\n&lt;/&gt;\n);\n}\n\nfunction PlaceTree({ id, parentId, placesById, onComplete }) {\nconst place = placesById[id];\nconst childIds = place.childIds;\nreturn (\n&lt;li&gt;\n{place.title}\n&lt;button\non_click={() =&gt; {\nonComplete(parentId, id);\n}}\n&gt;\nComplete\n&lt;/button&gt;\n{childIds.length &gt; 0 &amp;&amp; (\n&lt;ol&gt;\n{childIds.map((childId) =&gt; (\n&lt;PlaceTree\nkey={childId}\nid={childId}\nparentId={id}\nplacesById={placesById}\nonComplete={onComplete}\n/&gt;\n))}\n&lt;/ol&gt;\n)}\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const initialTravelPlan = {\n0: {\nid: 0,\ntitle: \"(Root)\",\nchildIds: [1, 43, 47],\n},\n1: {\nid: 1,\ntitle: \"Earth\",\nchildIds: [2, 10, 19, 27, 35],\n},\n2: {\nid: 2,\ntitle: \"Africa\",\nchildIds: [3, 4, 5, 6, 7, 8, 9],\n},\n3: {\nid: 3,\ntitle: \"Botswana\",\nchildIds: [],\n},\n4: {\nid: 4,\ntitle: \"Egypt\",\nchildIds: [],\n},\n5: {\nid: 5,\ntitle: \"Kenya\",\nchildIds: [],\n},\n6: {\nid: 6,\ntitle: \"Madagascar\",\nchildIds: [],\n},\n7: {\nid: 7,\ntitle: \"Morocco\",\nchildIds: [],\n},\n8: {\nid: 8,\ntitle: \"Nigeria\",\nchildIds: [],\n},\n9: {\nid: 9,\ntitle: \"South Africa\",\nchildIds: [],\n},\n10: {\nid: 10,\ntitle: \"Americas\",\nchildIds: [11, 12, 13, 14, 15, 16, 17, 18],\n},\n11: {\nid: 11,\ntitle: \"Argentina\",\nchildIds: [],\n},\n12: {\nid: 12,\ntitle: \"Brazil\",\nchildIds: [],\n},\n13: {\nid: 13,\ntitle: \"Barbados\",\nchildIds: [],\n},\n14: {\nid: 14,\ntitle: \"Canada\",\nchildIds: [],\n},\n15: {\nid: 15,\ntitle: \"Jamaica\",\nchildIds: [],\n},\n16: {\nid: 16,\ntitle: \"Mexico\",\nchildIds: [],\n},\n17: {\nid: 17,\ntitle: \"Trinidad and Tobago\",\nchildIds: [],\n},\n18: {\nid: 18,\ntitle: \"Venezuela\",\nchildIds: [],\n},\n19: {\nid: 19,\ntitle: \"Asia\",\nchildIds: [20, 21, 22, 23, 24, 25, 26],\n},\n20: {\nid: 20,\ntitle: \"China\",\nchildIds: [],\n},\n21: {\nid: 21,\ntitle: \"Hong Kong\",\nchildIds: [],\n},\n22: {\nid: 22,\ntitle: \"India\",\nchildIds: [],\n},\n23: {\nid: 23,\ntitle: \"Singapore\",\nchildIds: [],\n},\n24: {\nid: 24,\ntitle: \"South Korea\",\nchildIds: [],\n},\n25: {\nid: 25,\ntitle: \"Thailand\",\nchildIds: [],\n},\n26: {\nid: 26,\ntitle: \"Vietnam\",\nchildIds: [],\n},\n27: {\nid: 27,\ntitle: \"Europe\",\nchildIds: [28, 29, 30, 31, 32, 33, 34],\n},\n28: {\nid: 28,\ntitle: \"Croatia\",\nchildIds: [],\n},\n29: {\nid: 29,\ntitle: \"France\",\nchildIds: [],\n},\n30: {\nid: 30,\ntitle: \"Germany\",\nchildIds: [],\n},\n31: {\nid: 31,\ntitle: \"Italy\",\nchildIds: [],\n},\n32: {\nid: 32,\ntitle: \"Portugal\",\nchildIds: [],\n},\n33: {\nid: 33,\ntitle: \"Spain\",\nchildIds: [],\n},\n34: {\nid: 34,\ntitle: \"Turkey\",\nchildIds: [],\n},\n35: {\nid: 35,\ntitle: \"Oceania\",\nchildIds: [36, 37, 38, 39, 40, 41, , 42],\n},\n36: {\nid: 36,\ntitle: \"Australia\",\nchildIds: [],\n},\n37: {\nid: 37,\ntitle: \"Bora Bora (French Polynesia)\",\nchildIds: [],\n},\n38: {\nid: 38,\ntitle: \"Easter Island (Chile)\",\nchildIds: [],\n},\n39: {\nid: 39,\ntitle: \"Fiji\",\nchildIds: [],\n},\n40: {\nid: 40,\ntitle: \"Hawaii (the USA)\",\nchildIds: [],\n},\n41: {\nid: 41,\ntitle: \"New Zealand\",\nchildIds: [],\n},\n42: {\nid: 42,\ntitle: \"Vanuatu\",\nchildIds: [],\n},\n43: {\nid: 43,\ntitle: \"Moon\",\nchildIds: [44, 45, 46],\n},\n44: {\nid: 44,\ntitle: \"Rheita\",\nchildIds: [],\n},\n45: {\nid: 45,\ntitle: \"Piccolomini\",\nchildIds: [],\n},\n46: {\nid: 46,\ntitle: \"Tycho\",\nchildIds: [],\n},\n47: {\nid: 47,\ntitle: \"Mars\",\nchildIds: [48, 49],\n},\n48: {\nid: 48,\ntitle: \"Corn Town\",\nchildIds: [],\n},\n49: {\nid: 49,\ntitle: \"Green Hill\",\nchildIds: [],\n},\n};\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p></p> <p>Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. This works well for ephemeral UI state that doesn't need to be stored, like whether an item is hovered.</p> <p> <ul> <li>If two state variables always update together, consider merging them into one.</li> <li>Choose your state variables carefully to avoid creating \"impossible\" states.</li> <li>Structure your state in a way that reduces the chances that you'll make a mistake updating it.</li> <li>Avoid redundant and duplicate state so that you don't need to keep it in sync.</li> <li>Don't put props into state unless you specifically want to prevent updates.</li> <li>For UI patterns like selection, keep ID or index in state instead of the object itself.</li> <li>If updating deeply nested state is complicated, try flattening it.</li> </ul> <p></p> <p>"},{"location":"learn/choosing-the-state-structure/#fix-a-component-thats-not-updating","title":"Fix a component that's not updating","text":"<p>This <code>Clock</code> component receives two props: <code>color</code> and <code>time</code>. When you select a different color in the select box, the <code>Clock</code> component receives a different <code>color</code> prop from its parent component. However, for some reason, the displayed color doesn't update. Why? Fix the problem.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Clock(props) {\nconst [color, setColor] = useState(props.color);\nreturn &lt;h1 style={{ color: color }}&gt;{props.time}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nconst [color, setColor] = useState(\"lightcoral\");\nreturn (\n&lt;div&gt;\n&lt;p&gt;\nPick a color:{\" \"}\n&lt;select\nvalue={color}\nonChange={(e) =&gt; setColor(e.target.value)}\n&gt;\n&lt;option value=\"lightcoral\"&gt;lightcoral&lt;/option&gt;\n&lt;option value=\"midnightblue\"&gt;midnightblue&lt;/option&gt;\n&lt;option value=\"rebeccapurple\"&gt;rebeccapurple&lt;/option&gt;\n&lt;/select&gt;\n&lt;/p&gt;\n&lt;Clock color={color} time={time.toLocaleTimeString()} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p> <p>The issue is that this component has <code>color</code> state initialized with the initial value of the <code>color</code> prop. But when the <code>color</code> prop changes, this does not affect the state variable! So they get out of sync. To fix this issue, remove the state variable altogether, and use the <code>color</code> prop directly.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Clock(props) {\nreturn &lt;h1 style={{ color: props.color }}&gt;{props.time}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nconst [color, setColor] = useState(\"lightcoral\");\nreturn (\n&lt;div&gt;\n&lt;p&gt;\nPick a color:{\" \"}\n&lt;select\nvalue={color}\nonChange={(e) =&gt; setColor(e.target.value)}\n&gt;\n&lt;option value=\"lightcoral\"&gt;lightcoral&lt;/option&gt;\n&lt;option value=\"midnightblue\"&gt;midnightblue&lt;/option&gt;\n&lt;option value=\"rebeccapurple\"&gt;rebeccapurple&lt;/option&gt;\n&lt;/select&gt;\n&lt;/p&gt;\n&lt;Clock color={color} time={time.toLocaleTimeString()} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Or, using the destructuring syntax:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Clock({ color, time }) {\nreturn &lt;h1 style={{ color: color }}&gt;{time}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nconst [color, setColor] = useState(\"lightcoral\");\nreturn (\n&lt;div&gt;\n&lt;p&gt;\nPick a color:{\" \"}\n&lt;select\nvalue={color}\nonChange={(e) =&gt; setColor(e.target.value)}\n&gt;\n&lt;option value=\"lightcoral\"&gt;lightcoral&lt;/option&gt;\n&lt;option value=\"midnightblue\"&gt;midnightblue&lt;/option&gt;\n&lt;option value=\"rebeccapurple\"&gt;rebeccapurple&lt;/option&gt;\n&lt;/select&gt;\n&lt;/p&gt;\n&lt;Clock color={color} time={time.toLocaleTimeString()} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"learn/choosing-the-state-structure/#fix-a-broken-packing-list","title":"Fix a broken packing list","text":"<p>This packing list has a footer that shows how many items are packed, and how many items there are overall. It seems to work at first, but it is buggy. For example, if you mark an item as packed and then delete it, the counter will not be updated correctly. Fix the counter so that it's always correct.</p> <p> <p>Is any state in this example redundant?</p> <p></p> <pre><code>import { useState } from \"react\";\nimport AddItem from \"./AddItem.js\";\nimport PackingList from \"./PackingList.js\";\n\nlet nextId = 3;\nconst initialItems = [\n{ id: 0, title: \"Warm socks\", packed: true },\n{ id: 1, title: \"Travel journal\", packed: false },\n{ id: 2, title: \"Watercolors\", packed: false },\n];\n\nexport default function TravelPlan() {\nconst [items, setItems] = useState(initialItems);\nconst [total, setTotal] = useState(3);\nconst [packed, setPacked] = useState(1);\n\nfunction handleAddItem(title) {\nsetTotal(total + 1);\nsetItems([\n...items,\n{\nid: nextId++,\ntitle: title,\npacked: false,\n},\n]);\n}\n\nfunction handleChangeItem(nextItem) {\nif (nextItem.packed) {\nsetPacked(packed + 1);\n} else {\nsetPacked(packed - 1);\n}\nsetItems(\nitems.map((item) =&gt; {\nif (item.id === nextItem.id) {\nreturn nextItem;\n} else {\nreturn item;\n}\n})\n);\n}\n\nfunction handleDeleteItem(itemId) {\nsetTotal(total - 1);\nsetItems(items.filter((item) =&gt; item.id !== itemId));\n}\n\nreturn (\n&lt;&gt;\n&lt;AddItem onAddItem={handleAddItem} /&gt;\n&lt;PackingList\nitems={items}\nonChangeItem={handleChangeItem}\nonDeleteItem={handleDeleteItem}\n/&gt;\n&lt;hr /&gt;\n&lt;b&gt;\n{packed} out of {total} packed!\n&lt;/b&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddItem({ onAddItem }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add item\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddItem(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function PackingList({ items, onChangeItem, onDeleteItem }) {\nreturn (\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={item.packed}\nonChange={(e) =&gt; {\nonChangeItem({\n...item,\npacked: e.target.checked,\n});\n}}\n/&gt;{\" \"}\n{item.title}\n&lt;/label&gt;\n&lt;button on_click={() =&gt; onDeleteItem(item.id)}&gt;\nDelete\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p> <p>Although you could carefully change each event handler to update the <code>total</code> and <code>packed</code> counters correctly, the root problem is that these state variables exist at all. They are redundant because you can always calculate the number of items (packed or total) from the <code>items</code> array itself. Remove the redundant state to fix the bug:</p> <pre><code>import { useState } from \"react\";\nimport AddItem from \"./AddItem.js\";\nimport PackingList from \"./PackingList.js\";\n\nlet nextId = 3;\nconst initialItems = [\n{ id: 0, title: \"Warm socks\", packed: true },\n{ id: 1, title: \"Travel journal\", packed: false },\n{ id: 2, title: \"Watercolors\", packed: false },\n];\n\nexport default function TravelPlan() {\nconst [items, setItems] = useState(initialItems);\n\nconst total = items.length;\nconst packed = items.filter((item) =&gt; item.packed).length;\n\nfunction handleAddItem(title) {\nsetItems([\n...items,\n{\nid: nextId++,\ntitle: title,\npacked: false,\n},\n]);\n}\n\nfunction handleChangeItem(nextItem) {\nsetItems(\nitems.map((item) =&gt; {\nif (item.id === nextItem.id) {\nreturn nextItem;\n} else {\nreturn item;\n}\n})\n);\n}\n\nfunction handleDeleteItem(itemId) {\nsetItems(items.filter((item) =&gt; item.id !== itemId));\n}\n\nreturn (\n&lt;&gt;\n&lt;AddItem onAddItem={handleAddItem} /&gt;\n&lt;PackingList\nitems={items}\nonChangeItem={handleChangeItem}\nonDeleteItem={handleDeleteItem}\n/&gt;\n&lt;hr /&gt;\n&lt;b&gt;\n{packed} out of {total} packed!\n&lt;/b&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddItem({ onAddItem }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add item\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddItem(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function PackingList({ items, onChangeItem, onDeleteItem }) {\nreturn (\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={item.packed}\nonChange={(e) =&gt; {\nonChangeItem({\n...item,\npacked: e.target.checked,\n});\n}}\n/&gt;{\" \"}\n{item.title}\n&lt;/label&gt;\n&lt;button on_click={() =&gt; onDeleteItem(item.id)}&gt;\nDelete\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>Notice how the event handlers are only concerned with calling <code>setItems</code> after this change. The item counts are now calculated during the next render from <code>items</code>, so they are always up-to-date.</p> <p></p>"},{"location":"learn/choosing-the-state-structure/#fix-the-disappearing-selection","title":"Fix the disappearing selection","text":"<p>There is a list of <code>letters</code> in state. When you hover or focus a particular letter, it gets highlighted. The currently highlighted letter is stored in the <code>highlightedLetter</code> state variable. You can \"star\" and \"unstar\" individual letters, which updates the <code>letters</code> array in state.</p> <p>This code works, but there is a minor UI glitch. When you press \"Star\" or \"Unstar\", the highlighting disappears for a moment. However, it reappears as soon as you move your pointer or switch to another letter with keyboard. Why is this happening? Fix it so that the highlighting doesn't disappear after the button click.</p> <pre><code>import { useState } from \"react\";\nimport { initialLetters } from \"./data.js\";\nimport Letter from \"./Letter.js\";\n\nexport default function MailClient() {\nconst [letters, setLetters] = useState(initialLetters);\nconst [highlightedLetter, setHighlightedLetter] = useState(null);\n\nfunction handleHover(letter) {\nsetHighlightedLetter(letter);\n}\n\nfunction handleStar(starred) {\nsetLetters(\nletters.map((letter) =&gt; {\nif (letter.id === starred.id) {\nreturn {\n...letter,\nisStarred: !letter.isStarred,\n};\n} else {\nreturn letter;\n}\n})\n);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Inbox&lt;/h2&gt;\n&lt;ul&gt;\n{letters.map((letter) =&gt; (\n&lt;Letter\nkey={letter.id}\nletter={letter}\nisHighlighted={letter === highlightedLetter}\nonHover={handleHover}\nonToggleStar={handleStar}\n/&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Letter({\nletter,\nisHighlighted,\nonHover,\nonToggleStar,\n}) {\nreturn (\n&lt;li\nclassName={isHighlighted ? \"highlighted\" : \"\"}\nonFocus={() =&gt; {\nonHover(letter);\n}}\nonPointerMove={() =&gt; {\nonHover(letter);\n}}\n&gt;\n&lt;button\non_click={() =&gt; {\nonToggleStar(letter);\n}}\n&gt;\n{letter.isStarred ? \"Unstar\" : \"Star\"}\n&lt;/button&gt;\n{letter.subject}\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const initialLetters = [\n{\nid: 0,\nsubject: \"Ready for adventure?\",\nisStarred: true,\n},\n{\nid: 1,\nsubject: \"Time to check in!\",\nisStarred: false,\n},\n{\nid: 2,\nsubject: \"Festival Begins in Just SEVEN Days!\",\nisStarred: false,\n},\n];\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nborder-radius: 5px;\n}\n.highlighted {\nbackground: #d2eaff;\n}\n</code></pre> <p> <p>The problem is that you're holding the letter object in <code>highlightedLetter</code>. But you're also holding the same information in the <code>letters</code> array. So your state has duplication! When you update the <code>letters</code> array after the button click, you create a new letter object which is different from <code>highlightedLetter</code>. This is why <code>highlightedLetter === letter</code> check becomes <code>false</code>, and the highlight disappears. It reappears the next time you call <code>setHighlightedLetter</code> when the pointer moves.</p> <p>To fix the issue, remove the duplication from state. Instead of storing the letter itself in two places, store the <code>highlightedId</code> instead. Then you can check <code>isHighlighted</code> for each letter with <code>letter.id === highlightedId</code>, which will work even if the <code>letter</code> object has changed since the last render.</p> <pre><code>import { useState } from \"react\";\nimport { initialLetters } from \"./data.js\";\nimport Letter from \"./Letter.js\";\n\nexport default function MailClient() {\nconst [letters, setLetters] = useState(initialLetters);\nconst [highlightedId, setHighlightedId] = useState(null);\n\nfunction handleHover(letterId) {\nsetHighlightedId(letterId);\n}\n\nfunction handleStar(starredId) {\nsetLetters(\nletters.map((letter) =&gt; {\nif (letter.id === starredId) {\nreturn {\n...letter,\nisStarred: !letter.isStarred,\n};\n} else {\nreturn letter;\n}\n})\n);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Inbox&lt;/h2&gt;\n&lt;ul&gt;\n{letters.map((letter) =&gt; (\n&lt;Letter\nkey={letter.id}\nletter={letter}\nisHighlighted={letter.id === highlightedId}\nonHover={handleHover}\nonToggleStar={handleStar}\n/&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Letter({\nletter,\nisHighlighted,\nonHover,\nonToggleStar,\n}) {\nreturn (\n&lt;li\nclassName={isHighlighted ? \"highlighted\" : \"\"}\nonFocus={() =&gt; {\nonHover(letter.id);\n}}\nonPointerMove={() =&gt; {\nonHover(letter.id);\n}}\n&gt;\n&lt;button\non_click={() =&gt; {\nonToggleStar(letter.id);\n}}\n&gt;\n{letter.isStarred ? \"Unstar\" : \"Star\"}\n&lt;/button&gt;\n{letter.subject}\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const initialLetters = [\n{\nid: 0,\nsubject: \"Ready for adventure?\",\nisStarred: true,\n},\n{\nid: 1,\nsubject: \"Time to check in!\",\nisStarred: false,\n},\n{\nid: 2,\nsubject: \"Festival Begins in Just SEVEN Days!\",\nisStarred: false,\n},\n];\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nborder-radius: 5px;\n}\n.highlighted {\nbackground: #d2eaff;\n}\n</code></pre> <p></p>"},{"location":"learn/choosing-the-state-structure/#implement-multiple-selection","title":"Implement multiple selection","text":"<p>In this example, each <code>Letter</code> has an <code>isSelected</code> prop and an <code>onToggle</code> handler that marks it as selected. This works, but the state is stored as a <code>selectedId</code> (either <code>null</code> or an ID), so only one letter can get selected at any given time.</p> <p>Change the state structure to support multiple selection. (How would you structure it? Think about this before writing the code.) Each checkbox should become independent from the others. Clicking a selected letter should uncheck it. Finally, the footer should show the correct number of the selected items.</p> <p> <p>Instead of a single selected ID, you might want to hold an array or a Set of selected IDs in state.</p> <p></p> <pre><code>import { useState } from \"react\";\nimport { letters } from \"./data.js\";\nimport Letter from \"./Letter.js\";\n\nexport default function MailClient() {\nconst [selectedId, setSelectedId] = useState(null);\n\n// TODO: allow multiple selection\nconst selectedCount = 1;\n\nfunction handleToggle(toggledId) {\n// TODO: allow multiple selection\nsetSelectedId(toggledId);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Inbox&lt;/h2&gt;\n&lt;ul&gt;\n{letters.map((letter) =&gt; (\n&lt;Letter\nkey={letter.id}\nletter={letter}\nisSelected={\n// TODO: allow multiple selection\nletter.id === selectedId\n}\nonToggle={handleToggle}\n/&gt;\n))}\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;b&gt;You selected {selectedCount} letters&lt;/b&gt;\n&lt;/p&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Letter({ letter, onToggle, isSelected }) {\nreturn (\n&lt;li className={isSelected ? \"selected\" : \"\"}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isSelected}\nonChange={() =&gt; {\nonToggle(letter.id);\n}}\n/&gt;\n{letter.subject}\n&lt;/label&gt;\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const letters = [\n{\nid: 0,\nsubject: \"Ready for adventure?\",\nisStarred: true,\n},\n{\nid: 1,\nsubject: \"Time to check in!\",\nisStarred: false,\n},\n{\nid: 2,\nsubject: \"Festival Begins in Just SEVEN Days!\",\nisStarred: false,\n},\n];\n</code></pre> <pre><code>input {\nmargin: 5px;\n}\nli {\nborder-radius: 5px;\n}\nlabel {\nwidth: 100%;\npadding: 5px;\ndisplay: inline-block;\n}\n.selected {\nbackground: #d2eaff;\n}\n</code></pre> <p> <p>Instead of a single <code>selectedId</code>, keep a <code>selectedIds</code> array in state. For example, if you select the first and the last letter, it would contain <code>[0, 2]</code>. When nothing is selected, it would be an empty <code>[]</code> array:</p> <pre><code>import { useState } from \"react\";\nimport { letters } from \"./data.js\";\nimport Letter from \"./Letter.js\";\n\nexport default function MailClient() {\nconst [selectedIds, setSelectedIds] = useState([]);\n\nconst selectedCount = selectedIds.length;\n\nfunction handleToggle(toggledId) {\n// Was it previously selected?\nif (selectedIds.includes(toggledId)) {\n// Then remove this ID from the array.\nsetSelectedIds(selectedIds.filter((id) =&gt; id !== toggledId));\n} else {\n// Otherwise, add this ID to the array.\nsetSelectedIds([...selectedIds, toggledId]);\n}\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Inbox&lt;/h2&gt;\n&lt;ul&gt;\n{letters.map((letter) =&gt; (\n&lt;Letter\nkey={letter.id}\nletter={letter}\nisSelected={selectedIds.includes(letter.id)}\nonToggle={handleToggle}\n/&gt;\n))}\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;b&gt;You selected {selectedCount} letters&lt;/b&gt;\n&lt;/p&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Letter({ letter, onToggle, isSelected }) {\nreturn (\n&lt;li className={isSelected ? \"selected\" : \"\"}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isSelected}\nonChange={() =&gt; {\nonToggle(letter.id);\n}}\n/&gt;\n{letter.subject}\n&lt;/label&gt;\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const letters = [\n{\nid: 0,\nsubject: \"Ready for adventure?\",\nisStarred: true,\n},\n{\nid: 1,\nsubject: \"Time to check in!\",\nisStarred: false,\n},\n{\nid: 2,\nsubject: \"Festival Begins in Just SEVEN Days!\",\nisStarred: false,\n},\n];\n</code></pre> <pre><code>input {\nmargin: 5px;\n}\nli {\nborder-radius: 5px;\n}\nlabel {\nwidth: 100%;\npadding: 5px;\ndisplay: inline-block;\n}\n.selected {\nbackground: #d2eaff;\n}\n</code></pre> <p>One minor downside of using an array is that for each item, you're calling <code>selectedIds.includes(letter.id)</code> to check whether it's selected. If the array is very large, this can become a performance problem because array search with <code>includes()</code> takes linear time, and you're doing this search for each individual item.</p> <p>To fix this, you can hold a Set in state instead, which provides a fast <code>has()</code> operation:</p> <pre><code>import { useState } from \"react\";\nimport { letters } from \"./data.js\";\nimport Letter from \"./Letter.js\";\n\nexport default function MailClient() {\nconst [selectedIds, setSelectedIds] = useState(new Set());\n\nconst selectedCount = selectedIds.size;\n\nfunction handleToggle(toggledId) {\n// Create a copy (to avoid mutation).\nconst nextIds = new Set(selectedIds);\nif (nextIds.has(toggledId)) {\nnextIds.delete(toggledId);\n} else {\nnextIds.add(toggledId);\n}\nsetSelectedIds(nextIds);\n}\n\nreturn (\n&lt;&gt;\n&lt;h2&gt;Inbox&lt;/h2&gt;\n&lt;ul&gt;\n{letters.map((letter) =&gt; (\n&lt;Letter\nkey={letter.id}\nletter={letter}\nisSelected={selectedIds.has(letter.id)}\nonToggle={handleToggle}\n/&gt;\n))}\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;b&gt;You selected {selectedCount} letters&lt;/b&gt;\n&lt;/p&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Letter({ letter, onToggle, isSelected }) {\nreturn (\n&lt;li className={isSelected ? \"selected\" : \"\"}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isSelected}\nonChange={() =&gt; {\nonToggle(letter.id);\n}}\n/&gt;\n{letter.subject}\n&lt;/label&gt;\n&lt;/li&gt;\n);\n}\n</code></pre> <pre><code>export const letters = [\n{\nid: 0,\nsubject: \"Ready for adventure?\",\nisStarred: true,\n},\n{\nid: 1,\nsubject: \"Time to check in!\",\nisStarred: false,\n},\n{\nid: 2,\nsubject: \"Festival Begins in Just SEVEN Days!\",\nisStarred: false,\n},\n];\n</code></pre> <pre><code>input {\nmargin: 5px;\n}\nli {\nborder-radius: 5px;\n}\nlabel {\nwidth: 100%;\npadding: 5px;\ndisplay: inline-block;\n}\n.selected {\nbackground: #d2eaff;\n}\n</code></pre> <p>Now each item does a <code>selectedIds.has(letter.id)</code> check, which is very fast.</p> <p>Keep in mind that you should not mutate objects in state, and that includes Sets, too. This is why the <code>handleToggle</code> function creates a copy of the Set first, and then updates that copy.</p> <p></p> <p></p>"},{"location":"learn/conditional-rendering/","title":"Conditional Rendering \ud83d\udea7","text":""},{"location":"learn/conditional-rendering/#overview","title":"Overview","text":"<p>  Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like <code>if</code> statements, <code>&amp;&amp;</code>, and <code>? :</code> operators.  </p> <p>You will learn</p> <ul> <li>How to return different JSX depending on a condition</li> <li>How to conditionally include or exclude a piece of JSX</li> <li>Common conditional syntax shortcuts you\u2019ll encounter in React codebases</li> </ul>"},{"location":"learn/conditional-rendering/#conditionally-returning-jsx","title":"Conditionally returning JSX","text":"<p>Let\u2019s say you have a <code>PackingList</code> component rendering several <code>Item</code>s, which can be marked as packed or not:</p> <pre><code>function Item({ name, isPacked }) {\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>Notice that some of the <code>Item</code> components have their <code>isPacked</code> prop set to <code>true</code> instead of <code>false</code>. You want to add a checkmark (\u2714) to packed items if <code>isPacked={true}</code>.</p> <p>You can write this as an <code>if</code>/<code>else</code> statement like so:</p> <pre><code>if (isPacked) {\nreturn &lt;li className=\"item\"&gt;{name} \u2714&lt;/li&gt;;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n</code></pre> <p>If the <code>isPacked</code> prop is <code>true</code>, this code returns a different JSX tree. With this change, some of the items get a checkmark at the end:</p> <pre><code>function Item({ name, isPacked }) {\nif (isPacked) {\nreturn &lt;li className=\"item\"&gt;{name} \u2714&lt;/li&gt;;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>Try editing what gets returned in either case, and see how the result changes!</p> <p>Notice how you're creating branching logic with JavaScript's <code>if</code> and <code>return</code> statements. In React, control flow (like conditions) is handled by JavaScript.</p>"},{"location":"learn/conditional-rendering/#conditionally-returning-nothing-with-null","title":"Conditionally returning nothing with <code>null</code>","text":"<p>In some situations, you won't want to render anything at all. For example, say you don't want to show packed items at all. A component must return something. In this case, you can return <code>null</code>:</p> <pre><code>if (isPacked) {\nreturn null;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n</code></pre> <p>If <code>isPacked</code> is true, the component will return nothing, <code>null</code>. Otherwise, it will return JSX to render.</p> <pre><code>function Item({ name, isPacked }) {\nif (isPacked) {\nreturn null;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>In practice, returning <code>null</code> from a component isn't common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component's JSX. Here's how to do that!</p>"},{"location":"learn/conditional-rendering/#conditionally-including-jsx","title":"Conditionally including JSX","text":"<p>In the previous example, you controlled which (if any!) JSX tree would be returned by the component. You may already have noticed some duplication in the render output:</p> <pre><code>&lt;li className=\"item\"&gt;{name} \u2714&lt;/li&gt;\n</code></pre> <p>is very similar to</p> <pre><code>&lt;li className=\"item\"&gt;{name}&lt;/li&gt;\n</code></pre> <p>Both of the conditional branches return <code>&lt;li className=\"item\"&gt;...&lt;/li&gt;</code>:</p> <pre><code>if (isPacked) {\nreturn &lt;li className=\"item\"&gt;{name} \u2714&lt;/li&gt;;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n</code></pre> <p>While this duplication isn't harmful, it could make your code harder to maintain. What if you want to change the <code>className</code>? You'd have to do it in two places in your code! In such a situation, you could conditionally include a little JSX to make your code more DRY.</p>"},{"location":"learn/conditional-rendering/#conditional-ternary-operator","title":"Conditional (ternary) operator (<code>? :</code>)","text":"<p>JavaScript has a compact syntax for writing a conditional expression -- the conditional operator or \"ternary operator\".</p> <p>Instead of this:</p> <pre><code>if (isPacked) {\nreturn &lt;li className=\"item\"&gt;{name} \u2714&lt;/li&gt;;\n}\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n</code></pre> <p>You can write this:</p> <pre><code>return &lt;li className=\"item\"&gt;{isPacked ? name + \" \u2714\" : name}&lt;/li&gt;;\n</code></pre> <p>You can read it as \"if <code>isPacked</code> is true, then (<code>?</code>) render <code>name + ' \u2714'</code>, otherwise (<code>:</code>) render <code>name</code>\".</p> <p>"},{"location":"learn/conditional-rendering/#are-these-two-examples-fully-equivalent","title":"Are these two examples fully equivalent?","text":"<p>If you're coming from an object-oriented programming background, you might assume that the two examples above are subtly different because one of them may create two different \"instances\" of <code>&lt;li&gt;</code>. But JSX elements aren't \"instances\" because they don't hold any internal state and aren't real DOM nodes. They're lightweight descriptions, like blueprints. So these two examples, in fact, are completely equivalent. Preserving and Resetting State goes into detail about how this works.</p> <p></p> <p>Now let's say you want to wrap the completed item's text into another HTML tag, like <code>&lt;del&gt;</code> to strike it out. You can add even more newlines and parentheses so that it's easier to nest more JSX in each of the cases:</p> <pre><code>function Item({ name, isPacked }) {\nreturn (\n&lt;li className=\"item\"&gt;{isPacked ? &lt;del&gt;{name + \" \u2714\"}&lt;/del&gt; : name}&lt;/li&gt;\n);\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>This style works well for simple conditions, but use it in moderation. If your components get messy with too much nested conditional markup, consider extracting child components to clean things up. In React, markup is a part of your code, so you can use tools like variables and functions to tidy up complex expressions.</p>"},{"location":"learn/conditional-rendering/#logical-and-operator","title":"Logical AND operator (<code>&amp;&amp;</code>)","text":"<p>Another common shortcut you'll encounter is the JavaScript logical AND (<code>&amp;&amp;</code>) operator. Inside React components, it often comes up when you want to render some JSX when the condition is true, or render nothing otherwise. With <code>&amp;&amp;</code>, you could conditionally render the checkmark only if <code>isPacked</code> is <code>true</code>:</p> <pre><code>return (\n&lt;li className=\"item\"&gt;\n{name} {isPacked &amp;&amp; \"\u2714\"}\n&lt;/li&gt;\n);\n</code></pre> <p>You can read this as \"if <code>isPacked</code>, then (<code>&amp;&amp;</code>) render the checkmark, otherwise, render nothing\".</p> <p>Here it is in action:</p> <pre><code>function Item({ name, isPacked }) {\nreturn (\n&lt;li className=\"item\"&gt;\n{name} {isPacked &amp;&amp; \"\u2714\"}\n&lt;/li&gt;\n);\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>A JavaScript &amp;&amp; expression returns the value of its right side (in our case, the checkmark) if the left side (our condition) is <code>true</code>. But if the condition is <code>false</code>, the whole expression becomes <code>false</code>. React considers <code>false</code> as a \"hole\" in the JSX tree, just like <code>null</code> or <code>undefined</code>, and doesn't render anything in its place.</p> <p> <p>Don't put numbers on the left side of <code>&amp;&amp;</code>.</p> <p>To test the condition, JavaScript converts the left side to a boolean automatically. However, if the left side is <code>0</code>, then the whole expression gets that value (<code>0</code>), and React will happily render <code>0</code> rather than nothing.</p> <p>For example, a common mistake is to write code like <code>messageCount &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>. It's easy to assume that it renders nothing when <code>messageCount</code> is <code>0</code>, but it really renders the <code>0</code> itself!</p> <p>To fix it, make the left side a boolean: <code>messageCount &gt; 0 &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>.</p> <p></p>"},{"location":"learn/conditional-rendering/#conditionally-assigning-jsx-to-a-variable","title":"Conditionally assigning JSX to a variable","text":"<p>When the shortcuts get in the way of writing plain code, try using an <code>if</code> statement and a variable. You can reassign variables defined with <code>let</code>, so start by providing the default content you want to display, the name:</p> <pre><code>let itemContent = name;\n</code></pre> <p>Use an <code>if</code> statement to reassign a JSX expression to <code>itemContent</code> if <code>isPacked</code> is <code>true</code>:</p> <pre><code>if (isPacked) {\nitemContent = name + \" \u2714\";\n}\n</code></pre> <p>Curly braces open the \"window into JavaScript\". Embed the variable with curly braces in the returned JSX tree, nesting the previously calculated expression inside of JSX:</p> <pre><code>&lt;li className=\"item\"&gt;{itemContent}&lt;/li&gt;\n</code></pre> <p>This style is the most verbose, but it's also the most flexible. Here it is in action:</p> <pre><code>function Item({ name, isPacked }) {\nlet itemContent = name;\nif (isPacked) {\nitemContent = name + \" \u2714\";\n}\nreturn &lt;li className=\"item\"&gt;{itemContent}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>Like before, this works not only for text, but for arbitrary JSX too:</p> <pre><code>function Item({ name, isPacked }) {\nlet itemContent = name;\nif (isPacked) {\nitemContent = &lt;del&gt;{name + \" \u2714\"}&lt;/del&gt;;\n}\nreturn &lt;li className=\"item\"&gt;{itemContent}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>If you're not familiar with JavaScript, this variety of styles might seem overwhelming at first. However, learning them will help you read and write any JavaScript code -- and not just React components! Pick the one you prefer for a start, and then consult this reference again if you forget how the other ones work.</p> <p> <ul> <li>In React, you control branching logic with JavaScript.</li> <li>You can return a JSX expression conditionally with an <code>if</code> statement.</li> <li>You can conditionally save some JSX to a variable and then include it inside other JSX by using the curly braces.</li> <li>In JSX, <code>{cond ? &lt;A /&gt; : &lt;B /&gt;}</code> means \"if <code>cond</code>, render <code>&lt;A /&gt;</code>, otherwise <code>&lt;B /&gt;</code>\".</li> <li>In JSX, <code>{cond &amp;&amp; &lt;A /&gt;}</code> means \"if <code>cond</code>, render <code>&lt;A /&gt;</code>, otherwise nothing\".</li> <li>The shortcuts are common, but you don't have to use them if you prefer plain <code>if</code>.</li> </ul> <p></p> <p>"},{"location":"learn/conditional-rendering/#show-an-icon-for-incomplete-items-with","title":"Show an icon for incomplete items with <code>? :</code>","text":"<p>Use the conditional operator (<code>cond ? a : b</code>) to render a \u274c if <code>isPacked</code> isn\u2019t <code>true</code>.</p> <pre><code>function Item({ name, isPacked }) {\nreturn (\n&lt;li className=\"item\"&gt;\n{name} {isPacked &amp;&amp; \"\u2714\"}\n&lt;/li&gt;\n);\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p> <pre><code>function Item({ name, isPacked }) {\nreturn (\n&lt;li className=\"item\"&gt;\n{name} {isPacked ? \"\u2714\" : \"\u274c\"}\n&lt;/li&gt;\n);\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item isPacked={true} name=\"Space suit\" /&gt;\n&lt;Item isPacked={true} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item isPacked={false} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"learn/conditional-rendering/#show-the-item-importance-with","title":"Show the item importance with <code>&amp;&amp;</code>","text":"<p>In this example, each <code>Item</code> receives a numerical <code>importance</code> prop. Use the <code>&amp;&amp;</code> operator to render \"(Importance: X)\" in italics, but only for items that have non-zero importance. Your item list should end up looking like this:</p> <ul> <li>Space suit (Importance: 9)</li> <li>Helmet with a golden leaf</li> <li>Photo of Tam (Importance: 6)</li> </ul> <p>Don't forget to add a space between the two labels!</p> <pre><code>function Item({ name, importance }) {\nreturn &lt;li className=\"item\"&gt;{name}&lt;/li&gt;;\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item importance={9} name=\"Space suit\" /&gt;\n&lt;Item importance={0} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item importance={6} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p> <p>This should do the trick:</p> <pre><code>function Item({ name, importance }) {\nreturn (\n&lt;li className=\"item\"&gt;\n{name}\n{importance &gt; 0 &amp;&amp; \" \"}\n{importance &gt; 0 &amp;&amp; &lt;i&gt;(Importance: {importance})&lt;/i&gt;}\n&lt;/li&gt;\n);\n}\n\nexport default function PackingList() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Sally Ride's Packing List&lt;/h1&gt;\n&lt;ul&gt;\n&lt;Item importance={9} name=\"Space suit\" /&gt;\n&lt;Item importance={0} name=\"Helmet with a golden leaf\" /&gt;\n&lt;Item importance={6} name=\"Photo of Tam\" /&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>Note that you must write <code>importance &gt; 0 &amp;&amp; ...</code> rather than <code>importance &amp;&amp; ...</code> so that if the <code>importance</code> is <code>0</code>, <code>0</code> isn't rendered as the result!</p> <p>In this solution, two separate conditions are used to insert a space between the name and the importance label. Alternatively, you could use a fragment with a leading space: <code>importance &gt; 0 &amp;&amp; &lt;&gt; &lt;i&gt;...&lt;/i&gt;</code> or add a space immediately inside the <code>&lt;i&gt;</code>: <code>importance &gt; 0 &amp;&amp; &lt;i&gt; ...&lt;/i&gt;</code>.</p> <p></p>"},{"location":"learn/conditional-rendering/#refactor-a-series-of-to-if-and-variables","title":"Refactor a series of <code>? :</code> to <code>if</code> and variables","text":"<p>This <code>Drink</code> component uses a series of <code>? :</code> conditions to show different information depending on whether the <code>name</code> prop is <code>\"tea\"</code> or <code>\"coffee\"</code>. The problem is that the information about each drink is spread across multiple conditions. Refactor this code to use a single <code>if</code> statement instead of three <code>? :</code> conditions.</p> <pre><code>function Drink({ name }) {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;{name}&lt;/h1&gt;\n&lt;dl&gt;\n&lt;dt&gt;Part of plant&lt;/dt&gt;\n&lt;dd&gt;{name === \"tea\" ? \"leaf\" : \"bean\"}&lt;/dd&gt;\n&lt;dt&gt;Caffeine content&lt;/dt&gt;\n&lt;dd&gt;{name === \"tea\" ? \"15\u201370 mg/cup\" : \"80\u2013185 mg/cup\"}&lt;/dd&gt;\n&lt;dt&gt;Age&lt;/dt&gt;\n&lt;dd&gt;{name === \"tea\" ? \"4,000+ years\" : \"1,000+ years\"}&lt;/dd&gt;\n&lt;/dl&gt;\n&lt;/section&gt;\n);\n}\n\nexport default function DrinkList() {\nreturn (\n&lt;div&gt;\n&lt;Drink name=\"tea\" /&gt;\n&lt;Drink name=\"coffee\" /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Once you've refactored the code to use <code>if</code>, do you have further ideas on how to simplify it?</p> <p> <p>There are multiple ways you could go about this, but here is one starting point:</p> <pre><code>function Drink({ name }) {\nlet part, caffeine, age;\nif (name === \"tea\") {\npart = \"leaf\";\ncaffeine = \"15\u201370 mg/cup\";\nage = \"4,000+ years\";\n} else if (name === \"coffee\") {\npart = \"bean\";\ncaffeine = \"80\u2013185 mg/cup\";\nage = \"1,000+ years\";\n}\nreturn (\n&lt;section&gt;\n&lt;h1&gt;{name}&lt;/h1&gt;\n&lt;dl&gt;\n&lt;dt&gt;Part of plant&lt;/dt&gt;\n&lt;dd&gt;{part}&lt;/dd&gt;\n&lt;dt&gt;Caffeine content&lt;/dt&gt;\n&lt;dd&gt;{caffeine}&lt;/dd&gt;\n&lt;dt&gt;Age&lt;/dt&gt;\n&lt;dd&gt;{age}&lt;/dd&gt;\n&lt;/dl&gt;\n&lt;/section&gt;\n);\n}\n\nexport default function DrinkList() {\nreturn (\n&lt;div&gt;\n&lt;Drink name=\"tea\" /&gt;\n&lt;Drink name=\"coffee\" /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Here the information about each drink is grouped together instead of being spread across multiple conditions. This makes it easier to add more drinks in the future.</p> <p>Another solution would be to remove the condition altogether by moving the information into objects:</p> <pre><code>const drinks = {\ntea: {\npart: \"leaf\",\ncaffeine: \"15\u201370 mg/cup\",\nage: \"4,000+ years\",\n},\ncoffee: {\npart: \"bean\",\ncaffeine: \"80\u2013185 mg/cup\",\nage: \"1,000+ years\",\n},\n};\n\nfunction Drink({ name }) {\nconst info = drinks[name];\nreturn (\n&lt;section&gt;\n&lt;h1&gt;{name}&lt;/h1&gt;\n&lt;dl&gt;\n&lt;dt&gt;Part of plant&lt;/dt&gt;\n&lt;dd&gt;{info.part}&lt;/dd&gt;\n&lt;dt&gt;Caffeine content&lt;/dt&gt;\n&lt;dd&gt;{info.caffeine}&lt;/dd&gt;\n&lt;dt&gt;Age&lt;/dt&gt;\n&lt;dd&gt;{info.age}&lt;/dd&gt;\n&lt;/dl&gt;\n&lt;/section&gt;\n);\n}\n\nexport default function DrinkList() {\nreturn (\n&lt;div&gt;\n&lt;Drink name=\"tea\" /&gt;\n&lt;Drink name=\"coffee\" /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/creating-a-react-app/","title":"Creating a Standalone React App","text":""},{"location":"learn/creating-a-react-app/#overview","title":"Overview","text":"<p>  If you want to build a new app or website with React, we recommend starting with a standalone executor.  </p> <p>If your app has constraints not well-served by existing web frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can use ReactPy in standalone mode.</p>"},{"location":"learn/creating-a-react-app/#using-reactpy-for-full-stack","title":"Using ReactPy for full-stack","text":"<p>ReactPy is a component library that helps you build a full-stack web application. For convenience, ReactPy is also bundled with several different standalone executors.</p> <p>These standalone executors are the easiest way to get started with ReactPy, as they require no additional setup or configuration.</p> <p>Note</p> <p>Standalone ReactPy requires a server</p> <p>In order to serve the initial HTML page, you will need to run a server. The ASGI examples below use Uvicorn, but you can use any ASGI server.</p> <p>Executors on this page can either support client-side rendering (CSR) or server-side rendering (SSR)</p>"},{"location":"learn/creating-a-react-app/#running-via-asgi-ssr","title":"Running via ASGI SSR","text":"<p>ReactPy can run in server-side standalone mode, where both page loading and component rendering occurs on an ASGI server.</p> <p>This executor is the most commonly used, as it provides maximum extensibility.</p> <p>First, install ReactPy and your preferred ASGI webserver.</p> <p>Terminal</p> <pre><code>pip install reactpy[asgi] uvicorn[standard]\n</code></pre> <p>Next, create a new file called <code>main.py</code> containing the ASGI application:</p> main.py <pre><code>from reactpy import component, html\nfrom reactpy.executors.asgi import ReactPy\n\n\n@component\ndef hello_world():\n    return html.div(\"Hello World\")\n\n\nmy_app = ReactPy(hello_world)\n</code></pre> <p>Finally, use your webserver of choice to start ReactPy:</p> <p>Terminal</p> <pre><code>uvicorn main:my_app\n</code></pre>"},{"location":"learn/creating-a-react-app/#running-via-asgi-csr","title":"Running via ASGI CSR","text":"<p>ReactPy can run in client-side standalone mode, where the initial page is served using the ASGI protocol. This is configuration allows direct execution of Javascript, but requires special considerations since all ReactPy component code is run on the browser via WebAssembly.</p> <p>First, install ReactPy and your preferred ASGI webserver.</p> <p>Terminal</p> <pre><code>pip install reactpy[asgi] uvicorn[standard]\n</code></pre> <p>Next, create a new file called <code>main.py</code> containing the ASGI application, and a <code>root.py</code> file containing the root component:</p> main.pyroot.py <pre><code>from pathlib import Path\n\nfrom reactpy.executors.asgi import ReactPyCsr\n\nmy_app = ReactPyCsr(\n    Path(__file__).parent / \"components\" / \"root.py\", initial=\"Loading...\"\n)\n</code></pre> <pre><code>from reactpy import component, html\n\n\n@component\ndef root():\n    return html.div(\"Hello World\")\n</code></pre> <p>Finally, use your webserver of choice to start ReactPy:</p> <p>Terminal</p> <pre><code>uvicorn main:my_app\n</code></pre>"},{"location":"learn/creating-a-react-app/#running-via-wsgi-ssr","title":"Running via WSGI SSR","text":"<p>Support for WSGI executors is coming in a future version.</p>"},{"location":"learn/creating-a-react-app/#running-via-wsgi-csr","title":"Running via WSGI CSR","text":"<p>Support for WSGI executors is coming in a future version.</p>"},{"location":"learn/editor-setup/","title":"Editor Setup","text":""},{"location":"learn/editor-setup/#overview","title":"Overview","text":"<p>  A properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you're looking to tune up your current editor, we have a few recommendations.  </p> <p>You will learn</p> <ul> <li>What the most popular editors are</li> <li>How to format your code automatically</li> </ul>"},{"location":"learn/editor-setup/#your-editor","title":"Your editor","text":"<p>VS Code is one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!</p> <p>Other popular text editors used in the React community include:</p> <ul> <li>WebStorm is an integrated development environment designed specifically for JavaScript.</li> <li>Sublime Text has support for syntax highlighting and autocomplete built in.</li> <li>Vim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as \"vi\" with most UNIX systems and with Apple OS X.</li> </ul>"},{"location":"learn/editor-setup/#recommended-text-editor-features","title":"Recommended text editor features","text":"<p>Some editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!</p>"},{"location":"learn/editor-setup/#python-linting","title":"Python Linting","text":"<p>Linting is the process of running a program that will analyse code for potential errors. Flake8 is a popular, open source linter for Python.</p> <ul> <li>Install Flake8 (be sure you have Python installed!)</li> <li>Integrate Flake8 in VSCode with the official extension</li> <li>Install Reactpy-Flake8 to lint your ReactPy code</li> </ul>"},{"location":"learn/editor-setup/#javascript-linting","title":"JavaScript Linting","text":"<p>You typically won't use much JavaScript alongside ReactPy, but there are still some cases where you might. For example, you might want to use JavaScript to fetch data from an API or to add some interactivity to your app.</p> <p>In these cases, it's helpful to have a linter that can catch common mistakes in your code as you write it. ESLint is a popular, open source linter for JavaScript.</p> <ul> <li>Install ESLint with the recommended configuration for React (be sure you have Node installed!)</li> <li>Integrate ESLint in VSCode with the official extension</li> </ul> <p>Make sure that you've enabled all the <code>eslint-plugin-react-hooks</code> rules for your project. They are essential and catch the most severe bugs early. The recommended <code>eslint-config-react-app</code> preset already includes them.</p>"},{"location":"learn/editor-setup/#formatting","title":"Formatting","text":"<p>The last thing you want to do when sharing your code with another contributor is get into an discussion about tabs vs spaces! Fortunately, Prettier will clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces\u2014and your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you.</p> <p>You can install the Prettier extension in VSCode by following these steps:</p> <ol> <li>Launch VS Code</li> <li>Use Quick Open, press Ctrl+P</li> <li>Paste in <code>ext install esbenp.prettier-vscode</code></li> <li>Press Enter</li> </ol>"},{"location":"learn/editor-setup/#formatting-on-save","title":"Formatting on save","text":"<p>Ideally, you should format your code on every save. VS Code has settings for this!</p> <ol> <li>In VS Code, press Ctrl+Shift+P</li> <li>Type \"settings\"</li> <li>Hit Enter</li> <li>In the search bar, type \"format on save\"</li> <li>Be sure the \"format on save\" option is ticked!</li> </ol> <p>Note</p> <p>If your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset using <code>eslint-config-prettier</code> so that ESLint is only used for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, use <code>prettier --check</code> for your continuous integration.</p>"},{"location":"learn/extra-tools-and-packages/","title":"Tools, Modules, and Packages \ud83d\udea7","text":"<ul> <li>ReactPy Router</li> <li>ReactPy Flake8</li> </ul>"},{"location":"learn/extracting-state-logic-into-a-reducer/","title":"Extracting State Logic into a Reducer \ud83d\udea7","text":""},{"location":"learn/extracting-state-logic-into-a-reducer/#overview","title":"Overview","text":"<p>  Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called a reducer. </p> <p>You will learn</p> <ul> <li>What a reducer function is</li> <li>How to refactor <code>useState</code> to <code>useReducer</code></li> <li>When to use a reducer</li> <li>How to write one well</li> </ul>"},{"location":"learn/extracting-state-logic-into-a-reducer/#consolidate-state-logic-with-a-reducer","title":"Consolidate state logic with a reducer","text":"<p>As your components grow in complexity, it can get harder to see at a glance all the different ways in which a component's state gets updated. For example, the <code>TaskApp</code> component below holds an array of <code>tasks</code> in state and uses three different event handlers to add, remove, and edit tasks:</p> <pre><code>import { useState } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nexport default function TaskApp() {\nconst [tasks, setTasks] = useState(initialTasks);\n\nfunction handleAddTask(text) {\nsetTasks([\n...tasks,\n{\nid: nextId++,\ntext: text,\ndone: false,\n},\n]);\n}\n\nfunction handleChangeTask(task) {\nsetTasks(\ntasks.map((t) =&gt; {\nif (t.id === task.id) {\nreturn task;\n} else {\nreturn t;\n}\n})\n);\n}\n\nfunction handleDeleteTask(taskId) {\nsetTasks(tasks.filter((t) =&gt; t.id !== taskId));\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>Each of its event handlers calls <code>setTasks</code> in order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a \"reducer\".</p> <p>Reducers are a different way to handle state. You can migrate from <code>useState</code> to <code>useReducer</code> in three steps:</p> <ol> <li>Move from setting state to dispatching actions.</li> <li>Write a reducer function.</li> <li>Use the reducer from your component.</li> </ol>"},{"location":"learn/extracting-state-logic-into-a-reducer/#step-1-move-from-setting-state-to-dispatching-actions","title":"Step 1: Move from setting state to dispatching actions","text":"<p>Your event handlers currently specify what to do by setting state:</p> <pre><code>function handleAddTask(text) {\nsetTasks([\n...tasks,\n{\nid: nextId++,\ntext: text,\ndone: false,\n},\n]);\n}\n\nfunction handleChangeTask(task) {\nsetTasks(\ntasks.map((t) =&gt; {\nif (t.id === task.id) {\nreturn task;\n} else {\nreturn t;\n}\n})\n);\n}\n\nfunction handleDeleteTask(taskId) {\nsetTasks(tasks.filter((t) =&gt; t.id !== taskId));\n}\n</code></pre> <p>Remove all the state setting logic. What you are left with are three event handlers:</p> <ul> <li><code>handleAddTask(text)</code> is called when the user presses \"Add\".</li> <li><code>handleChangeTask(task)</code> is called when the user toggles a task or presses \"Save\".</li> <li><code>handleDeleteTask(taskId)</code> is called when the user presses \"Delete\".</li> </ul> <p>Managing state with reducers is slightly different from directly setting state. Instead of telling React \"what to do\" by setting state, you specify \"what the user just did\" by dispatching \"actions\" from your event handlers. (The state update logic will live elsewhere!) So instead of \"setting <code>tasks</code>\" via an event handler, you're dispatching an \"added/changed/deleted a task\" action. This is more descriptive of the user's intent.</p> <pre><code>function handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n</code></pre> <p>The object you pass to <code>dispatch</code> is called an \"action\":</p> <pre><code>function handleDeleteTask(taskId) {\ndispatch(\n// \"action\" object:\n{\ntype: \"deleted\",\nid: taskId,\n}\n);\n}\n</code></pre> <p>It is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information about what happened. (You will add the <code>dispatch</code> function itself in a later step.)</p> <p> <p>An action object can have any shape.</p> <p>By convention, it is common to give it a string <code>type</code> that describes what happened, and pass any additional information in other fields. The <code>type</code> is specific to a component, so in this example either <code>'added'</code> or <code>'added_task'</code> would be fine. Choose a name that says what happened!</p> <pre><code>dispatch({\n// specific to component\ntype: \"what_happened\",\n// other fields go here\n});\n</code></pre> <p></p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#step-2-write-a-reducer-function","title":"Step 2: Write a reducer function","text":"<p>A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:</p> <pre><code>function yourReducer(state, action) {\n// return next state for React to set\n}\n</code></pre> <p>React will set the state to what you return from the reducer.</p> <p>To move your state setting logic from your event handlers to a reducer function in this example, you will:</p> <ol> <li>Declare the current state (<code>tasks</code>) as the first argument.</li> <li>Declare the <code>action</code> object as the second argument.</li> <li>Return the next state from the reducer (which React will set the state to).</li> </ol> <p>Here is all the state setting logic migrated to a reducer function:</p> <pre><code>function tasksReducer(tasks, action) {\nif (action.type === \"added\") {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n} else if (action.type === \"changed\") {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n} else if (action.type === \"deleted\") {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n} else {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n</code></pre> <p>Because the reducer function takes state (<code>tasks</code>) as an argument, you can declare it outside of your component. This decreases the indentation level and can make your code easier to read.</p> <p> <p>The code above uses if/else statements, but it's a convention to use switch statements inside reducers. The result is the same, but it can be easier to read switch statements at a glance.</p> <p>We'll be using them throughout the rest of this documentation like so:</p> <pre><code>function tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <p>We recommend wrapping each <code>case</code> block into the <code>{</code> and <code>}</code> curly braces so that variables declared inside of different <code>case</code>s don't clash with each other. Also, a <code>case</code> should usually end with a <code>return</code>. If you forget to <code>return</code>, the code will \"fall through\" to the next <code>case</code>, which can lead to mistakes!</p> <p>If you're not yet comfortable with switch statements, using if/else is completely fine.</p> <p></p> <p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#why-are-reducers-called-this-way","title":"Why are reducers called this way?","text":"<p>Although reducers can \"reduce\" the amount of code inside your component, they are actually named after the <code>reduce()</code> operation that you can perform on arrays.</p> <p>The <code>reduce()</code> operation lets you take an array and \"accumulate\" a single value out of many:</p> <pre><code>const arr = [1, 2, 3, 4, 5];\nconst sum = arr.reduce(\n  (result, number) =&gt; result + number\n); // 1 + 2 + 3 + 4 + 5\n</code></pre> <p>The function you pass to <code>reduce</code> is known as a \"reducer\". It takes the result so far and the current item, then it returns the next result. React reducers are an example of the same idea: they take the state so far and the action, and return the next state. In this way, they accumulate actions over time into state.</p> <p>You could even use the <code>reduce()</code> method with an <code>initialState</code> and an array of <code>actions</code> to calculate the final state by passing your reducer function to it:</p> <pre><code>import tasksReducer from \"./tasksReducer.js\";\n\nlet initialState = [];\nlet actions = [\n{ type: \"added\", id: 1, text: \"Visit Kafka Museum\" },\n{ type: \"added\", id: 2, text: \"Watch a puppet show\" },\n{ type: \"deleted\", id: 1 },\n{ type: \"added\", id: 3, text: \"Lennon Wall pic\" },\n];\n\nlet finalState = actions.reduce(tasksReducer, initialState);\n\nconst output = document.getElementById(\"output\");\noutput.textContent = JSON.stringify(finalState, null, 2);\n</code></pre> <pre><code>export default function tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>&lt;pre id=\"output\"&gt;&lt;/pre&gt;\n</code></pre> <p>You probably won't need to do this yourself, but this is similar to what React does!</p> <p></p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#step-3-use-the-reducer-from-your-component","title":"Step 3: Use the reducer from your component","text":"<p>Finally, you need to hook up the <code>tasksReducer</code> to your component. Import the <code>useReducer</code> Hook from React:</p> <pre><code>import { useReducer } from \"react\";\n</code></pre> <p>Then you can replace <code>useState</code>:</p> <pre><code>const [tasks, setTasks] = useState(initialTasks);\n</code></pre> <p>with <code>useReducer</code> like so:</p> <pre><code>const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n</code></pre> <p>The <code>useReducer</code> Hook is similar to <code>useState</code>\u2014you must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it's a little different.</p> <p>The <code>useReducer</code> Hook takes two arguments:</p> <ol> <li>A reducer function</li> <li>An initial state</li> </ol> <p>And it returns:</p> <ol> <li>A stateful value</li> <li>A dispatch function (to \"dispatch\" user actions to the reducer)</li> </ol> <p>Now it's fully wired up! Here, the reducer is declared at the bottom of the component file:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>If you want, you can even move the reducer to a different file:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport tasksReducer from \"./tasksReducer.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>export default function tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>Component logic can be easier to read when you separate concerns like this. Now the event handlers only specify what happened by dispatching actions, and the reducer function determines how the state updates in response to them.</p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#comparing-usestate-and-usereducer","title":"Comparing <code>useState</code> and <code>useReducer</code>","text":"<p>Reducers are not without downsides! Here's a few ways you can compare them:</p> <ul> <li>Code size: Generally, with <code>useState</code> you have to write less code upfront. With <code>useReducer</code>, you have to write both a reducer function and dispatch actions. However, <code>useReducer</code> can help cut down on the code if many event handlers modify state in a similar way.</li> <li>Readability: <code>useState</code> is very easy to read when the state updates are simple. When they get more complex, they can bloat your component's code and make it difficult to scan. In this case, <code>useReducer</code> lets you cleanly separate the how of update logic from the what happened of event handlers.</li> <li>Debugging: When you have a bug with <code>useState</code>, it can be difficult to tell where the state was set incorrectly, and why. With <code>useReducer</code>, you can add a console log into your reducer to see every state update, and why it happened (due to which <code>action</code>). If each <code>action</code> is correct, you'll know that the mistake is in the reducer logic itself. However, you have to step through more code than with <code>useState</code>.</li> <li>Testing: A reducer is a pure function that doesn't depend on your component. This means that you can export and test it separately in isolation. While generally it's best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.</li> <li>Personal preference: Some people like reducers, others don't. That's okay. It's a matter of preference. You can always convert between <code>useState</code> and <code>useReducer</code> back and forth: they are equivalent!</li> </ul> <p>We recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don't have to use reducers for everything: feel free to mix and match! You can even <code>useState</code> and <code>useReducer</code> in the same component.</p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#writing-reducers-well","title":"Writing reducers well","text":"<p>Keep these two tips in mind when writing reducers:</p> <ul> <li>Reducers must be pure. Similar to state updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducers must be pure\u2014same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should update objects and arrays without mutations.</li> <li>Each action describes a single user interaction, even if that leads to multiple changes in the data. For example, if a user presses \"Reset\" on a form with five fields managed by a reducer, it makes more sense to dispatch one <code>reset_form</code> action rather than five separate <code>set_field</code> actions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!</li> </ul>"},{"location":"learn/extracting-state-logic-into-a-reducer/#writing-concise-reducers-with-immer","title":"Writing concise reducers with Immer","text":"<p>Just like with updating objects and arrays in regular state, you can use the Immer library to make reducers more concise. Here, <code>useImmerReducer</code> lets you mutate the state with <code>push</code> or <code>arr[i] =</code> assignment:</p> <pre><code>import { useImmerReducer } from \"use-immer\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nfunction tasksReducer(draft, action) {\nswitch (action.type) {\ncase \"added\": {\ndraft.push({\nid: action.id,\ntext: action.text,\ndone: false,\n});\nbreak;\n}\ncase \"changed\": {\nconst index = draft.findIndex((t) =&gt; t.id === action.task.id);\ndraft[index] = action.task;\nbreak;\n}\ncase \"deleted\": {\nreturn draft.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p>Reducers must be pure, so they shouldn't mutate state. But Immer provides you with a special <code>draft</code> object which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to the <code>draft</code>. This is why reducers managed by <code>useImmerReducer</code> can mutate their first argument and don't need to return state.</p> <p> <ul> <li>To convert from <code>useState</code> to <code>useReducer</code>:<ol> <li>Dispatch actions from event handlers.</li> <li>Write a reducer function that returns the next state for a given state and action.</li> <li>Replace <code>useState</code> with <code>useReducer</code>.</li> </ol> </li> <li>Reducers require you to write a bit more code, but they help with debugging and testing.</li> <li>Reducers must be pure.</li> <li>Each action describes a single user interaction.</li> <li>Use Immer if you want to write reducers in a mutating style.</li> </ul> <p></p> <p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#dispatch-actions-from-event-handlers","title":"Dispatch actions from event handlers","text":"<p>Currently, the event handlers in <code>ContactList.js</code> and <code>Chat.js</code> have <code>// TODO</code> comments. This is why typing into the input doesn't work, and clicking on the buttons doesn't change the selected recipient.</p> <p>Replace these two <code>// TODO</code>s with the code to <code>dispatch</code> the corresponding actions. To see the expected shape and the type of the actions, check the reducer in <code>messengerReducer.js</code>. The reducer is already written so you won't need to change it. You only need to dispatch the actions in <code>ContactList.js</code> and <code>Chat.js</code>.</p> <p> <p>The <code>dispatch</code> function is already available in both of these components because it was passed as a prop. So you need to call <code>dispatch</code> with the corresponding action object.</p> <p>To check the action object shape, you can look at the reducer and see which <code>action</code> fields it expects to see. For example, the <code>changed_selection</code> case in the reducer looks like this:</p> <pre><code>case 'changed_selection': {\nreturn {\n...state,\nselectedId: action.contactId\n};\n}\n</code></pre> <p>This means that your action object should have a <code>type: 'changed_selection'</code>. You also see the <code>action.contactId</code> being used, so you need to include a <code>contactId</code> property into your action.</p> <p></p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\n// TODO: dispatch changed_selection\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\n// TODO: dispatch edited_message\n// (Read the input value from e.target.value)\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button&gt;Send to {contact.email}&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p> <p>From the reducer code, you can infer that actions need to look like this:</p> <pre><code>// When the user presses \"Alice\"\ndispatch({\ntype: \"changed_selection\",\ncontactId: 1,\n});\n\n// When user types \"Hello!\"\ndispatch({\ntype: \"edited_message\",\nmessage: \"Hello!\",\n});\n</code></pre> <p>Here is the example updated to dispatch the corresponding messages:</p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button&gt;Send to {contact.email}&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p></p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#clear-the-input-on-sending-a-message","title":"Clear the input on sending a message","text":"<p>Currently, pressing \"Send\" doesn't do anything. Add an event handler to the \"Send\" button that will:</p> <ol> <li>Show an <code>alert</code> with the recipient's email and the message.</li> <li>Clear the message input.</li> </ol> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button&gt;Send to {contact.email}&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p> <p>There are a couple of ways you could do it in the \"Send\" button event handler. One approach is to show an alert and then dispatch an <code>edited_message</code> action with an empty <code>message</code>:</p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"edited_message\",\nmessage: \"\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>This works and clears the input when you hit \"Send\".</p> <p>However, from the user's perspective, sending a message is a different action than editing the field. To reflect that, you could instead create a new action called <code>sent_message</code>, and handle it separately in the reducer:</p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ncase \"sent_message\": {\nreturn {\n...state,\nmessage: \"\",\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"sent_message\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>The resulting behavior is the same. But keep in mind that action types should ideally describe \"what the user did\" rather than \"how you want the state to change\". This makes it easier to later add more features.</p> <p>With either solution, it's important that you don't place the <code>alert</code> inside a reducer. The reducer should be a pure function--it should only calculate the next state. It should not \"do\" anything, including displaying messages to the user. That should happen in the event handler. (To help catch mistakes like this, React will call your reducers multiple times in Strict Mode. This is why, if you put an alert in a reducer, it fires twice.)</p> <p></p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#restore-input-values-when-switching-between-tabs","title":"Restore input values when switching between tabs","text":"<p>In this example, switching between different recipients always clears the text input:</p> <pre><code>case 'changed_selection': {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: '' // Clears the input\n};\n</code></pre> <p>This is because you don't want to share a single message draft between several recipients. But it would be better if your app \"remembered\" a draft for each contact separately, restoring them when you switch contacts.</p> <p>Your task is to change the way the state is structured so that you remember a separate message draft per contact. You would need to make a few changes to the reducer, the initial state, and the components.</p> <p> <p>You can structure your state like this:</p> <pre><code>export const initialState = {\nselectedId: 0,\nmessages: {\n0: \"Hello, Taylor\", // Draft for contactId = 0\n1: \"Hello, Alice\", // Draft for contactId = 1\n},\n};\n</code></pre> <p>The <code>[key]: value</code> computed property syntax can help you update the <code>messages</code> object:</p> <pre><code>{\n...state.messages,\n[id]: message\n}\n</code></pre> <p></p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.message;\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessage: \"Hello\",\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\nmessage: \"\",\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessage: action.message,\n};\n}\ncase \"sent_message\": {\nreturn {\n...state,\nmessage: \"\",\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"sent_message\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p> <p>You'll need to update the reducer to store and update a separate message draft per contact:</p> <pre><code>// When the input is edited\ncase 'edited_message': {\nreturn {\n// Keep other state like selection\n...state,\nmessages: {\n// Keep messages for other contacts\n...state.messages,\n// But change the selected contact's message\n[state.selectedId]: action.message\n}\n};\n}\n</code></pre> <p>You would also update the <code>Messenger</code> component to read the message for the currently selected contact:</p> <pre><code>const message = state.messages[state.selectedId];\n</code></pre> <p>Here is the complete solution:</p> <pre><code>import { useReducer } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.messages[state.selectedId];\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessages: {\n0: \"Hello, Taylor\",\n1: \"Hello, Alice\",\n2: \"Hello, Bob\",\n},\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: action.message,\n},\n};\n}\ncase \"sent_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: \"\",\n},\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"sent_message\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>Notably, you didn't need to change any of the event handlers to implement this different behavior. Without a reducer, you would have to change every event handler that updates the state.</p> <p></p>"},{"location":"learn/extracting-state-logic-into-a-reducer/#implement-usereducer-from-scratch","title":"Implement <code>useReducer</code> from scratch","text":"<p>In the earlier examples, you imported the <code>useReducer</code> Hook from React. This time, you will implement the <code>useReducer</code> Hook itself! Here is a stub to get you started. It shouldn't take more than 10 lines of code.</p> <p>To test your changes, try typing into the input or select a contact.</p> <p> <p>Here is a more detailed sketch of the implementation:</p> <pre><code>export function useReducer(reducer, initialState) {\nconst [state, setState] = useState(initialState);\n\nfunction dispatch(action) {\n// ???\n}\n\nreturn [state, dispatch];\n}\n</code></pre> <p>Recall that a reducer function takes two arguments--the current state and the action object--and it returns the next state. What should your <code>dispatch</code> implementation do with it?</p> <p></p> <pre><code>import { useReducer } from \"./MyReact.js\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.messages[state.selectedId];\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessages: {\n0: \"Hello, Taylor\",\n1: \"Hello, Alice\",\n2: \"Hello, Bob\",\n},\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: action.message,\n},\n};\n}\ncase \"sent_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: \"\",\n},\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport function useReducer(reducer, initialState) {\nconst [state, setState] = useState(initialState);\n\n// ???\n\nreturn [state, dispatch];\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"sent_message\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p> <p>Dispatching an action calls a reducer with the current state and the action, and stores the result as the next state. This is what it looks like in code:</p> <pre><code>import { useReducer } from \"./MyReact.js\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\nimport { initialState, messengerReducer } from \"./messengerReducer\";\n\nexport default function Messenger() {\nconst [state, dispatch] = useReducer(messengerReducer, initialState);\nconst message = state.messages[state.selectedId];\nconst contact = contacts.find((c) =&gt; c.id === state.selectedId);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={state.selectedId}\ndispatch={dispatch}\n/&gt;\n&lt;Chat\nkey={contact.id}\nmessage={message}\ncontact={contact}\ndispatch={dispatch}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export const initialState = {\nselectedId: 0,\nmessages: {\n0: \"Hello, Taylor\",\n1: \"Hello, Alice\",\n2: \"Hello, Bob\",\n},\n};\n\nexport function messengerReducer(state, action) {\nswitch (action.type) {\ncase \"changed_selection\": {\nreturn {\n...state,\nselectedId: action.contactId,\n};\n}\ncase \"edited_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: action.message,\n},\n};\n}\ncase \"sent_message\": {\nreturn {\n...state,\nmessages: {\n...state.messages,\n[state.selectedId]: \"\",\n},\n};\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport function useReducer(reducer, initialState) {\nconst [state, setState] = useState(initialState);\n\nfunction dispatch(action) {\nconst nextState = reducer(state, action);\nsetState(nextState);\n}\n\nreturn [state, dispatch];\n}\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, dispatch }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"changed_selection\",\ncontactId: contact.id,\n});\n}}\n&gt;\n{selectedId === contact.id ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact, message, dispatch }) {\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={message}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"edited_message\",\nmessage: e.target.value,\n});\n}}\n/&gt;\n&lt;br /&gt;\n&lt;button\non_click={() =&gt; {\nalert(`Sending \"${message}\" to ${contact.email}`);\ndispatch({\ntype: \"sent_message\",\n});\n}}\n&gt;\nSend to {contact.email}\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>Though it doesn't matter in most cases, a slightly more accurate implementation looks like this:</p> <pre><code>function dispatch(action) {\nsetState((s) =&gt; reducer(s, action));\n}\n</code></pre> <p>This is because the dispatched actions are queued until the next render, similar to the updater functions.</p> <p></p> <p></p>"},{"location":"learn/importing-and-exporting-components/","title":"Importing and Exporting Components \ud83d\udea7","text":""},{"location":"learn/importing-and-exporting-components/#overview","title":"Overview","text":"<p>  The magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places.  </p> <p>You will learn</p> <ul> <li>What a root component file is</li> <li>How to import and export a component</li> <li>When to use default and named imports and exports</li> <li>How to import and export multiple components from one file</li> <li>How to split components into multiple files</li> </ul>"},{"location":"learn/importing-and-exporting-components/#the-root-component-file","title":"The root component file","text":"<p>In Your First Component, you made a <code>Profile</code> component and a <code>Gallery</code> component that renders it:</p> <pre><code>function Profile() {\nreturn (\n&lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n);\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p>These currently live in a root component file, named <code>App.js</code> in this example. In Create React App, your app lives in <code>src/App.js</code>. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.</p>"},{"location":"learn/importing-and-exporting-components/#exporting-and-importing-a-component","title":"Exporting and importing a component","text":"<p>What if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to move <code>Gallery</code> and <code>Profile</code> out of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:</p> <ol> <li>Make a new JS file to put the components in.</li> <li>Export your function component from that file (using either default or named exports).</li> <li>Import it in the file where you\u2019ll use the component (using the corresponding technique for importing default or named exports).</li> </ol> <p>Here both <code>Profile</code> and <code>Gallery</code> have been moved out of <code>App.js</code> into a new file called <code>Gallery.js</code>. Now you can change <code>App.js</code> to import <code>Gallery</code> from <code>Gallery.js</code>:</p> <pre><code>import Gallery from \"./Gallery.js\";\n\nexport default function App() {\nreturn &lt;Gallery /&gt;;\n}\n</code></pre> <pre><code>function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p>Notice how this example is broken down into two component files now:</p> <ol> <li><code>Gallery.js</code>:<ul> <li>Defines the <code>Profile</code> component which is only used within the same file and is not exported.</li> <li>Exports the <code>Gallery</code> component as a default export.</li> </ul> </li> <li><code>App.js</code>:<ul> <li>Imports <code>Gallery</code> as a default import from <code>Gallery.js</code>.</li> <li>Exports the root <code>App</code> component as a default export.</li> </ul> </li> </ol> <p> <p>You may encounter files that leave off the <code>.js</code> file extension like so:</p> <pre><code>import Gallery from \"./Gallery\";\n</code></pre> <p>Either <code>'./Gallery.js'</code> or <code>'./Gallery'</code> will work with React, though the former is closer to how native ES Modules work.</p> <p></p> <p>"},{"location":"learn/importing-and-exporting-components/#default-vs-named-exports","title":"Default vs named exports","text":"<p>There are two primary ways to export values with JavaScript: default exports and named exports. So far, our examples have only used default exports. But you can use one or both of them in the same file. A file can have no more than one default export, but it can have as many named exports as you like.</p> <p></p> <p>How you export your component dictates how you must import it. You will get an error if you try to import a default export the same way you would a named export! This chart can help you keep track:</p> Syntax Export statement Import statement Default <code>export default function Button() {}</code> <code>import Button from './Button.js';</code> Named <code>export function Button() {}</code> <code>import { Button } from './Button.js';</code> <p>When you write a default import, you can put any name you want after <code>import</code>. For example, you could write <code>import Banana from './Button.js'</code> instead and it would still provide you with the same default export. In contrast, with named imports, the name has to match on both sides. That's why they are called named imports!</p> <p>People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values. Regardless of which coding style you prefer, always give meaningful names to your component functions and the files that contain them. Components without names, like <code>export default () =&gt; {}</code>, are discouraged because they make debugging harder.</p> <p></p>"},{"location":"learn/importing-and-exporting-components/#exporting-and-importing-multiple-components-from-the-same-file","title":"Exporting and importing multiple components from the same file","text":"<p>What if you want to show just one <code>Profile</code> instead of a gallery? You can export the <code>Profile</code> component, too. But <code>Gallery.js</code> already has a default export, and you can't have two default exports. You could create a new file with a default export, or you could add a named export for <code>Profile</code>. A file can only have one default export, but it can have numerous named exports!</p> <p> <p>To reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!</p> <p></p> <p>First, export <code>Profile</code> from <code>Gallery.js</code> using a named export (no <code>default</code> keyword):</p> <pre><code>export function Profile() {\n// ...\n}\n</code></pre> <p>Then, import <code>Profile</code> from <code>Gallery.js</code> to <code>App.js</code> using a named import (with the curly braces):</p> <pre><code>import { Profile } from \"./Gallery.js\";\n</code></pre> <p>Finally, render <code>&lt;Profile /&gt;</code> from the <code>App</code> component:</p> <pre><code>export default function App() {\nreturn &lt;Profile /&gt;;\n}\n</code></pre> <p>Now <code>Gallery.js</code> contains two exports: a default <code>Gallery</code> export, and a named <code>Profile</code> export. <code>App.js</code> imports both of them. Try editing <code>&lt;Profile /&gt;</code> to <code>&lt;Gallery /&gt;</code> and back in this example:</p> <pre><code>import Gallery from \"./Gallery.js\";\nimport { Profile } from \"./Gallery.js\";\n\nexport default function App() {\nreturn &lt;Profile /&gt;;\n}\n</code></pre> <pre><code>export function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p>Now you're using a mix of default and named exports:</p> <ul> <li><code>Gallery.js</code>:<ul> <li>Exports the <code>Profile</code> component as a named export called <code>Profile</code>.</li> <li>Exports the <code>Gallery</code> component as a default export.</li> </ul> </li> <li><code>App.js</code>:<ul> <li>Imports <code>Profile</code> as a named import called <code>Profile</code> from <code>Gallery.js</code>.</li> <li>Imports <code>Gallery</code> as a default import from <code>Gallery.js</code>.</li> <li>Exports the root <code>App</code> component as a default export.</li> </ul> </li> </ul> <p> <p>On this page you learned:</p> <ul> <li>What a root component file is</li> <li>How to import and export a component</li> <li>When and how to use default and named imports and exports</li> <li>How to export multiple components from the same file</li> </ul> <p></p> <p>"},{"location":"learn/importing-and-exporting-components/#split-the-components-further","title":"Split the components further","text":"<p>Currently, <code>Gallery.js</code> exports both <code>Profile</code> and <code>Gallery</code>, which is a bit confusing.</p> <p>Move the <code>Profile</code> component to its own <code>Profile.js</code>, and then change the <code>App</code> component to render both <code>&lt;Profile /&gt;</code> and <code>&lt;Gallery /&gt;</code> one after another.</p> <p>You may use either a default or a named export for <code>Profile</code>, but make sure that you use the corresponding import syntax in both <code>App.js</code> and <code>Gallery.js</code>! You can refer to the table from the deep dive above:</p> Syntax Export statement Import statement Default <code>export default function Button() {}</code> <code>import Button from './Button.js';</code> Named <code>export function Button() {}</code> <code>import { Button } from './Button.js';</code> <p> <p>Don't forget to import your components where they are called. Doesn't <code>Gallery</code> use <code>Profile</code>, too?</p> <p></p> <pre><code>import Gallery from \"./Gallery.js\";\nimport { Profile } from \"./Gallery.js\";\n\nexport default function App() {\nreturn (\n&lt;div&gt;\n&lt;Profile /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>// Move me to Profile.js!\nexport function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p>After you get it working with one kind of exports, make it work with the other kind.</p> <p> <p>This is the solution with named exports:</p> <pre><code>import Gallery from \"./Gallery.js\";\nimport { Profile } from \"./Profile.js\";\n\nexport default function App() {\nreturn (\n&lt;div&gt;\n&lt;Profile /&gt;\n&lt;Gallery /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { Profile } from \"./Profile.js\";\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>export function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p>This is the solution with default exports:</p> <pre><code>import Gallery from \"./Gallery.js\";\nimport Profile from \"./Profile.js\";\n\nexport default function App() {\nreturn (\n&lt;div&gt;\n&lt;Profile /&gt;\n&lt;Gallery /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import Profile from \"./Profile.js\";\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>export default function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/installation/","title":"Installation","text":""},{"location":"learn/installation/#overview","title":"Overview","text":"<p>  React has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started.  </p> <p>You will learn</p> <ul> <li>How to start a new React project</li> <li>How to add React to an existing project</li> <li>How to set up your editor</li> <li>How to install React Developer Tools</li> </ul>"},{"location":"learn/installation/#start-a-new-react-project","title":"Start a new React project","text":"<p>If you want to build an app or a website fully with React, start a new React project.</p>"},{"location":"learn/installation/#add-react-to-an-existing-project","title":"Add React to an existing project","text":"<p>If want to try using React in your existing app or a website, add React to an existing project.</p>"},{"location":"learn/installation/#next-steps","title":"Next steps","text":"<p>Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day.</p>"},{"location":"learn/keeping-components-pure/","title":"Keeping Components Pure \ud83d\udea7","text":""},{"location":"learn/keeping-components-pure/#overview","title":"Overview","text":"<p>  Some JavaScript functions are pure. Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow.  </p> <p>You will learn</p> <ul> <li>What purity is and how it helps you avoid bugs</li> <li>How to keep components pure by keeping changes out of the render phase</li> <li>How to use Strict Mode to find mistakes in your components</li> </ul>"},{"location":"learn/keeping-components-pure/#purity-components-as-formulas","title":"Purity: Components as formulas","text":"<p>In computer science (and especially the world of functional programming), a pure function is a function with the following characteristics:</p> <ul> <li>It minds its own business. It does not change any objects or variables that existed before it was called.</li> <li>Same inputs, same output. Given the same inputs, a pure function should always return the same result.</li> </ul> <p>You might already be familiar with one example of pure functions: formulas in math.</p> <p>Consider this math formula: y = 2x.</p> <p>If x = 2 then y = 4. Always.</p> <p>If x = 3 then y = 6. Always.</p> <p>If x = 3, y won't sometimes be 9 or \u20131 or 2.5 depending on the time of day or the state of the stock market.</p> <p>If y = 2x and x = 3, y will always be 6.</p> <p>If we made this into a JavaScript function, it would look like this:</p> <pre><code>function double(number) {\nreturn 2 * number;\n}\n</code></pre> <p>In the above example, <code>double</code> is a pure function. If you pass it <code>3</code>, it will return <code>6</code>. Always.</p> <p>React is designed around this concept. React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs:</p> <pre><code>function Recipe({ drinkers }) {\nreturn (\n&lt;ol&gt;\n&lt;li&gt;Boil {drinkers} cups of water.&lt;/li&gt;\n&lt;li&gt;\nAdd {drinkers} spoons of tea and {0.5 * drinkers} spoons of\nspice.\n&lt;/li&gt;\n&lt;li&gt;\nAdd {0.5 * drinkers} cups of milk to boil and sugar to taste.\n&lt;/li&gt;\n&lt;/ol&gt;\n);\n}\n\nexport default function App() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Spiced Chai Recipe&lt;/h1&gt;\n&lt;h2&gt;For two&lt;/h2&gt;\n&lt;Recipe drinkers={2} /&gt;\n&lt;h2&gt;For a gathering&lt;/h2&gt;\n&lt;Recipe drinkers={4} /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>When you pass <code>drinkers={2}</code> to <code>Recipe</code>, it will return JSX containing <code>2 cups of water</code>. Always.</p> <p>If you pass <code>drinkers={4}</code>, it will return JSX containing <code>4 cups of water</code>. Always.</p> <p>Just like a math formula.</p> <p>You could think of your components as recipes: if you follow them and don't introduce new ingredients during the cooking process, you will get the same dish every time. That \"dish\" is the JSX that the component serves to React to render.</p> <p></p>"},{"location":"learn/keeping-components-pure/#side-effects-unintended-consequences","title":"Side Effects: (un)intended consequences","text":"<p>React's rendering process must always be pure. Components should only return their JSX, and not change any objects or variables that existed before rendering\u2014that would make them impure!</p> <p>Here is a component that breaks this rule:</p> <pre><code>let guest = 0;\n\nfunction Cup() {\n// Bad: changing a preexisting variable!\nguest = guest + 1;\nreturn &lt;h2&gt;Tea cup for guest #{guest}&lt;/h2&gt;;\n}\n\nexport default function TeaSet() {\nreturn (\n&lt;&gt;\n&lt;Cup /&gt;\n&lt;Cup /&gt;\n&lt;Cup /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>This component is reading and writing a <code>guest</code> variable declared outside of it. This means that calling this component multiple times will produce different JSX! And what's more, if other components read <code>guest</code>, they will produce different JSX, too, depending on when they were rendered! That's not predictable.</p> <p>Going back to our formula y = 2x, now even if x = 2, we cannot trust that y = 4. Our tests could fail, our users would be baffled, planes would fall out of the sky\u2014you can see how this would lead to confusing bugs!</p> <p>You can fix this component by passing <code>guest</code> as a prop instead:</p> <pre><code>function Cup({ guest }) {\nreturn &lt;h2&gt;Tea cup for guest #{guest}&lt;/h2&gt;;\n}\n\nexport default function TeaSet() {\nreturn (\n&lt;&gt;\n&lt;Cup guest={1} /&gt;\n&lt;Cup guest={2} /&gt;\n&lt;Cup guest={3} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now your component is pure, as the JSX it returns only depends on the <code>guest</code> prop.</p> <p>In general, you should not expect your components to be rendered in any particular order. It doesn't matter if you call y = 2x before or after y = 5x: both formulas will resolve independently of each other. In the same way, each component should only \"think for itself\", and not attempt to coordinate with or depend upon others during rendering. Rendering is like a school exam: each component should calculate JSX on their own!</p> <p>"},{"location":"learn/keeping-components-pure/#detecting-impure-calculations-with-strictmode","title":"Detecting impure calculations with StrictMode","text":"<p>Although you might not have used them all yet, in React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.</p> <p>When you want to change something in response to user input, you should set state instead of writing to a variable. You should never change preexisting variables or objects while your component is rendering.</p> <p>React offers a \"Strict Mode\" in which it calls each component's function twice during development. By calling the component functions twice, Strict Mode helps find components that break these rules.</p> <p>Notice how the original example displayed \"Guest #2\", \"Guest #4\", and \"Guest #6\" instead of \"Guest #1\", \"Guest #2\", and \"Guest #3\". The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time. Pure functions only calculate, so calling them twice won't change anything--just like calling <code>double(2)</code> twice doesn't change what's returned, and solving y = 2x twice doesn't change what y is. Same inputs, same outputs. Always.</p> <p>Strict Mode has no effect in production, so it won't slow down the app for your users. To opt into Strict Mode, you can wrap your root component into <code>&lt;React.StrictMode&gt;</code>. Some frameworks do this by default.</p> <p></p>"},{"location":"learn/keeping-components-pure/#local-mutation-your-components-little-secret","title":"Local mutation: Your component's little secret","text":"<p>In the above example, the problem was that the component changed a preexisting variable while rendering. This is often called a \"mutation\" to make it sound a bit scarier. Pure functions don't mutate variables outside of the function's scope or objects that were created before the call\u2014that makes them impure!</p> <p>However, it's completely fine to change variables and objects that you've just created while rendering. In this example, you create an <code>[]</code> array, assign it to a <code>cups</code> variable, and then <code>push</code> a dozen cups into it:</p> <pre><code>function Cup({ guest }) {\nreturn &lt;h2&gt;Tea cup for guest #{guest}&lt;/h2&gt;;\n}\n\nexport default function TeaGathering() {\nlet cups = [];\nfor (let i = 1; i &lt;= 12; i++) {\ncups.push(&lt;Cup key={i} guest={i} /&gt;);\n}\nreturn cups;\n}\n</code></pre> <p>If the <code>cups</code> variable or the <code>[]</code> array were created outside the <code>TeaGathering</code> function, this would be a huge problem! You would be changing a preexisting object by pushing items into that array.</p> <p>However, it's fine because you've created them during the same render, inside <code>TeaGathering</code>. No code outside of <code>TeaGathering</code> will ever know that this happened. This is called \"local mutation\"\u2014it's like your component's little secret.</p>"},{"location":"learn/keeping-components-pure/#where-you-can-cause-side-effects","title":"Where you can cause side effects","text":"<p>While functional programming relies heavily on purity, at some point, somewhere, something has to change. That's kind of the point of programming! These changes\u2014updating the screen, starting an animation, changing the data\u2014are called side effects. They're things that happen \"on the side\", not during rendering.</p> <p>In React, side effects usually belong inside event handlers. Event handlers are functions that React runs when you perform some action\u2014for example, when you click a button. Even though event handlers are defined inside your component, they don't run during rendering! So event handlers don't need to be pure.</p> <p>If you've exhausted all other options and can't find the right event handler for your side effect, you can still attach it to your returned JSX with a <code>useEffect</code> call in your component. This tells React to execute it later, after rendering, when side effects are allowed. However, this approach should be your last resort.</p> <p>When possible, try to express your logic with rendering alone. You'll be surprised how far this can take you!</p> <p>"},{"location":"learn/keeping-components-pure/#why-does-react-care-about-purity","title":"Why does React care about purity?","text":"<p>Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:</p> <ul> <li>Your components could run in a different environment\u2014for example, on the server! Since they return the same result for the same inputs, one component can serve many user requests.</li> <li>You can improve performance by skipping rendering components whose inputs have not changed. This is safe because pure functions always return the same results, so they are safe to cache.</li> <li>If some data changes in the middle of rendering a deep component tree, React can restart rendering without wasting time to finish the outdated render. Purity makes it safe to stop calculating at any time.</li> </ul> <p>Every new React feature we're building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm.</p> <p></p> <p> <ul> <li>A component must be pure, meaning:<ul> <li>It minds its own business. It should not change any objects or variables that existed before rendering.</li> <li>Same inputs, same output. Given the same inputs, a component should always return the same JSX.</li> </ul> </li> <li>Rendering can happen at any time, so components should not depend on each others' rendering sequence.</li> <li>You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, \"set\" state instead of mutating preexisting objects.</li> <li>Strive to express your component's logic in the JSX you return. When you need to \"change things\", you'll usually want to do it in an event handler. As a last resort, you can <code>useEffect</code>.</li> <li>Writing pure functions takes a bit of practice, but it unlocks the power of React's paradigm.</li> </ul> <p></p> <p>"},{"location":"learn/keeping-components-pure/#fix-a-broken-clock","title":"Fix a broken clock","text":"<p>This component tries to set the <code>&lt;h1&gt;</code>'s CSS class to <code>\"night\"</code> during the time from midnight to six hours in the morning, and <code>\"day\"</code> at all other times. However, it doesn't work. Can you fix this component?</p> <p>You can verify whether your solution works by temporarily changing the computer's timezone. When the current time is between midnight and six in the morning, the clock should have inverted colors!</p> <p> <p>Rendering is a calculation, it shouldn't try to \"do\" things. Can you express the same idea differently?</p> <p></p> <pre><code>export default function Clock({ time }) {\nlet hours = time.getHours();\nif (hours &gt;= 0 &amp;&amp; hours &lt;= 6) {\ndocument.getElementById(\"time\").className = \"night\";\n} else {\ndocument.getElementById(\"time\").className = \"day\";\n}\nreturn &lt;h1 id=\"time\"&gt;{time.toLocaleTimeString()}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nreturn &lt;Clock time={time} /&gt;;\n}\n</code></pre> <pre><code>body &gt; * {\nwidth: 100%;\nheight: 100%;\n}\n.day {\nbackground: #fff;\ncolor: #222;\n}\n.night {\nbackground: #222;\ncolor: #fff;\n}\n</code></pre> <p> <p>You can fix this component by calculating the <code>className</code> and including it in the render output:</p> <pre><code>export default function Clock({ time }) {\nlet hours = time.getHours();\nlet className;\nif (hours &gt;= 0 &amp;&amp; hours &lt;= 6) {\nclassName = \"night\";\n} else {\nclassName = \"day\";\n}\nreturn &lt;h1 className={className}&gt;{time.toLocaleTimeString()}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nreturn &lt;Clock time={time} /&gt;;\n}\n</code></pre> <pre><code>body &gt; * {\nwidth: 100%;\nheight: 100%;\n}\n.day {\nbackground: #fff;\ncolor: #222;\n}\n.night {\nbackground: #222;\ncolor: #fff;\n}\n</code></pre> <p>In this example, the side effect (modifying the DOM) was not necessary at all. You only needed to return JSX.</p> <p></p>"},{"location":"learn/keeping-components-pure/#fix-a-broken-profile","title":"Fix a broken profile","text":"<p>Two <code>Profile</code> components are rendered side by side with different data. Press \"Collapse\" on the first profile, and then \"Expand\" it. You'll notice that both profiles now show the same person. This is a bug.</p> <p>Find the cause of the bug and fix it.</p> <p> <p>The buggy code is in <code>Profile.js</code>. Make sure you read it all from top to bottom!</p> <p></p> <pre><code>import Panel from \"./Panel.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nlet currentPerson;\n\nexport default function Profile({ person }) {\ncurrentPerson = person;\nreturn (\n&lt;Panel&gt;\n&lt;Header /&gt;\n&lt;Avatar /&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Header() {\nreturn &lt;h1&gt;{currentPerson.name}&lt;/h1&gt;;\n}\n\nfunction Avatar() {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(currentPerson)}\nalt={currentPerson.name}\nwidth={50}\nheight={50}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Panel({ children }) {\nconst [open, setOpen] = useState(true);\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;button on_click={() =&gt; setOpen(!open)}&gt;\n{open ? \"Collapse\" : \"Expand\"}\n&lt;/button&gt;\n{open &amp;&amp; children}\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import Profile from \"./Profile.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;Profile\nperson={{\nimageId: \"lrWQx8l\",\nname: \"Subrahmanyan Chandrasekhar\",\n}}\n/&gt;\n&lt;Profile\nperson={{\nimageId: \"MK3eW3A\",\nname: \"Creola Katherine Johnson\",\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size = \"s\") {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 5px;\nborder-radius: 50%;\n}\n.panel {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nmargin-top: 20px;\npadding: 10px;\nwidth: 200px;\n}\nh1 {\nmargin: 5px;\nfont-size: 18px;\n}\n</code></pre> <p> <p>The problem is that the <code>Profile</code> component writes to a preexisting variable called <code>currentPerson</code>, and the <code>Header</code> and <code>Avatar</code> components read from it. This makes all three of them impure and difficult to predict.</p> <p>To fix the bug, remove the <code>currentPerson</code> variable. Instead, pass all information from <code>Profile</code> to <code>Header</code> and <code>Avatar</code> via props. You'll need to add a <code>person</code> prop to both components and pass it all the way down.</p> <pre><code>import Panel from \"./Panel.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function Profile({ person }) {\nreturn (\n&lt;Panel&gt;\n&lt;Header person={person} /&gt;\n&lt;Avatar person={person} /&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Header({ person }) {\nreturn &lt;h1&gt;{person.name}&lt;/h1&gt;;\n}\n\nfunction Avatar({ person }) {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person)}\nalt={person.name}\nwidth={50}\nheight={50}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Panel({ children }) {\nconst [open, setOpen] = useState(true);\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;button on_click={() =&gt; setOpen(!open)}&gt;\n{open ? \"Collapse\" : \"Expand\"}\n&lt;/button&gt;\n{open &amp;&amp; children}\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import Profile from \"./Profile.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;Profile\nperson={{\nimageId: \"lrWQx8l\",\nname: \"Subrahmanyan Chandrasekhar\",\n}}\n/&gt;\n&lt;Profile\nperson={{\nimageId: \"MK3eW3A\",\nname: \"Creola Katherine Johnson\",\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size = \"s\") {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 5px;\nborder-radius: 50%;\n}\n.panel {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nmargin-top: 20px;\npadding: 10px;\nwidth: 200px;\n}\nh1 {\nmargin: 5px;\nfont-size: 18px;\n}\n</code></pre> <p>Remember that React does not guarantee that component functions will execute in any particular order, so you can't communicate between them by setting variables. All communication must happen through props.</p> <p></p>"},{"location":"learn/keeping-components-pure/#fix-a-broken-story-tray","title":"Fix a broken story tray","text":"<p>The CEO of your company is asking you to add \"stories\" to your online clock app, and you can't say no. You've written a <code>StoryTray</code> component that accepts a list of <code>stories</code>, followed by a \"Create Story\" placeholder.</p> <p>You implemented the \"Create Story\" placeholder by pushing one more fake story at the end of the <code>stories</code> array that you receive as a prop. But for some reason, \"Create Story\" appears more than once. Fix the issue.</p> <pre><code>export default function StoryTray({ stories }) {\nstories.push({\nid: \"create\",\nlabel: \"Create Story\",\n});\n\nreturn (\n&lt;ul&gt;\n{stories.map((story) =&gt; (\n&lt;li key={story.id}&gt;{story.label}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport StoryTray from \"./StoryTray.js\";\n\nlet initialStories = [\n{ id: 0, label: \"Ankit's Story\" },\n{ id: 1, label: \"Taylor's Story\" },\n];\n\nexport default function App() {\nlet [stories, setStories] = useState([...initialStories]);\nlet time = useTime();\n\n// HACK: Prevent the memory from growing forever while you read docs.\n// We're breaking our own rules here.\nif (stories.length &gt; 100) {\nstories.length = 100;\n}\n\nreturn (\n&lt;div\nstyle={{\nwidth: \"100%\",\nheight: \"100%\",\ntextAlign: \"center\",\n}}\n&gt;\n&lt;h2&gt;It is {time.toLocaleTimeString()} now.&lt;/h2&gt;\n&lt;StoryTray stories={stories} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n</code></pre> <pre><code>ul {\nmargin: 0;\nlist-style-type: none;\n}\n\nli {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nfloat: left;\nmargin: 5px;\nmargin-bottom: 20px;\npadding: 5px;\nwidth: 70px;\nheight: 100px;\n}\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <p> <p>Notice how whenever the clock updates, \"Create Story\" is added twice. This serves as a hint that we have a mutation during rendering--Strict Mode calls components twice to make these issues more noticeable.</p> <p><code>StoryTray</code> function is not pure. By calling <code>push</code> on the received <code>stories</code> array (a prop!), it is mutating an object that was created before <code>StoryTray</code> started rendering. This makes it buggy and very difficult to predict.</p> <p>The simplest fix is to not touch the array at all, and render \"Create Story\" separately:</p> <pre><code>export default function StoryTray({ stories }) {\nreturn (\n&lt;ul&gt;\n{stories.map((story) =&gt; (\n&lt;li key={story.id}&gt;{story.label}&lt;/li&gt;\n))}\n&lt;li&gt;Create Story&lt;/li&gt;\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport StoryTray from \"./StoryTray.js\";\n\nlet initialStories = [\n{ id: 0, label: \"Ankit's Story\" },\n{ id: 1, label: \"Taylor's Story\" },\n];\n\nexport default function App() {\nlet [stories, setStories] = useState([...initialStories]);\nlet time = useTime();\n\n// HACK: Prevent the memory from growing forever while you read docs.\n// We're breaking our own rules here.\nif (stories.length &gt; 100) {\nstories.length = 100;\n}\n\nreturn (\n&lt;div\nstyle={{\nwidth: \"100%\",\nheight: \"100%\",\ntextAlign: \"center\",\n}}\n&gt;\n&lt;h2&gt;It is {time.toLocaleTimeString()} now.&lt;/h2&gt;\n&lt;StoryTray stories={stories} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n</code></pre> <pre><code>ul {\nmargin: 0;\nlist-style-type: none;\n}\n\nli {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nfloat: left;\nmargin: 5px;\nmargin-bottom: 20px;\npadding: 5px;\nwidth: 70px;\nheight: 100px;\n}\n</code></pre> <p>Alternatively, you could create a new array (by copying the existing one) before you push an item into it:</p> <pre><code>export default function StoryTray({ stories }) {\n// Copy the array!\nlet storiesToDisplay = stories.slice();\n\n// Does not affect the original array:\nstoriesToDisplay.push({\nid: \"create\",\nlabel: \"Create Story\",\n});\n\nreturn (\n&lt;ul&gt;\n{storiesToDisplay.map((story) =&gt; (\n&lt;li key={story.id}&gt;{story.label}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport StoryTray from \"./StoryTray.js\";\n\nlet initialStories = [\n{ id: 0, label: \"Ankit's Story\" },\n{ id: 1, label: \"Taylor's Story\" },\n];\n\nexport default function App() {\nlet [stories, setStories] = useState([...initialStories]);\nlet time = useTime();\n\n// HACK: Prevent the memory from growing forever while you read docs.\n// We're breaking our own rules here.\nif (stories.length &gt; 100) {\nstories.length = 100;\n}\n\nreturn (\n&lt;div\nstyle={{\nwidth: \"100%\",\nheight: \"100%\",\ntextAlign: \"center\",\n}}\n&gt;\n&lt;h2&gt;It is {time.toLocaleTimeString()} now.&lt;/h2&gt;\n&lt;StoryTray stories={stories} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n</code></pre> <pre><code>ul {\nmargin: 0;\nlist-style-type: none;\n}\n\nli {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nfloat: left;\nmargin: 5px;\nmargin-bottom: 20px;\npadding: 5px;\nwidth: 70px;\nheight: 100px;\n}\n</code></pre> <p>This keeps your mutation local and your rendering function pure. However, you still need to be careful: for example, if you tried to change any of the array's existing items, you'd have to clone those items too.</p> <p>It is useful to remember which operations on arrays mutate them, and which don't. For example, <code>push</code>, <code>pop</code>, <code>reverse</code>, and <code>sort</code> will mutate the original array, but <code>slice</code>, <code>filter</code>, and <code>map</code> will create a new one.</p> <p></p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/","title":"Lifecycle of Reactive Effects \ud83d\udea7","text":""},{"location":"learn/lifecycle-of-reactive-effects/#overview","title":"Overview","text":"<p>  Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you've specified your Effect's dependencies correctly. This keeps your Effect synchronized to the latest props and state.  </p> <p>You will learn</p> <ul> <li>How an Effect's lifecycle is different from a component's lifecycle</li> <li>How to think about each individual Effect in isolation</li> <li>When your Effect needs to re-synchronize, and why</li> <li>How your Effect's dependencies are determined</li> <li>What it means for a value to be reactive</li> <li>What an empty dependency array means</li> <li>How React verifies your dependencies are correct with a linter</li> <li>What to do when you disagree with the linter</li> </ul>"},{"location":"learn/lifecycle-of-reactive-effects/#the-lifecycle-of-an-effect","title":"The lifecycle of an Effect","text":"<p>Every React component goes through the same lifecycle:</p> <ul> <li>A component mounts when it's added to the screen.</li> <li>A component updates when it receives new props or state, usually in response to an interaction.</li> <li>A component unmounts when it's removed from the screen.</li> </ul> <p>It's a good way to think about components, but not about Effects. Instead, try to think about each Effect independently from your component's lifecycle. An Effect describes how to synchronize an external system to the current props and state. As your code changes, synchronization will need to happen more or less often.</p> <p>To illustrate this point, consider this Effect connecting your component to a chat server:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]);\n// ...\n}\n</code></pre> <p>Your Effect's body specifies how to start synchronizing:</p> <pre><code>// ...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n// ...\n</code></pre> <p>The cleanup function returned by your Effect specifies how to stop synchronizing:</p> <pre><code>// ...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n// ...\n</code></pre> <p>Intuitively, you might think that React would start synchronizing when your component mounts and stop synchronizing when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted.</p> <p>Let's look at why this is necessary, when it happens, and how you can control this behavior.</p> <p> <p>Some Effects don't return a cleanup function at all. More often than not, you'll want to return one--but if you don't, React will behave as if you returned an empty cleanup function.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#why-synchronization-may-need-to-happen-more-than-once","title":"Why synchronization may need to happen more than once","text":"<p>Imagine this <code>ChatRoom</code> component receives a <code>roomId</code> prop that the user picks in a dropdown. Let's say that initially the user picks the <code>\"general\"</code> room as the <code>roomId</code>. Your app displays the <code>\"general\"</code> chat room:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId /* \"general\" */ }) {\n// ...\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <p>After the UI is displayed, React will run your Effect to start synchronizing. It connects to the <code>\"general\"</code> room:</p> <pre><code>function ChatRoom({ roomId /* \"general\" */ }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // Connects to the \"general\" room\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect(); // Disconnects from the \"general\" room\n};\n}, [roomId]);\n// ...\n</code></pre> <p>So far, so good.</p> <p>Later, the user picks a different room in the dropdown (for example, <code>\"travel\"</code>). First, React will update the UI:</p> <pre><code>function ChatRoom({ roomId /* \"travel\" */ }) {\n// ...\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <p>Think about what should happen next. The user sees that <code>\"travel\"</code> is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the <code>\"general\"</code> room. The <code>roomId</code> prop has changed, so what your Effect did back then (connecting to the <code>\"general\"</code> room) no longer matches the UI.</p> <p>At this point, you want React to do two things:</p> <ol> <li>Stop synchronizing with the old <code>roomId</code> (disconnect from the <code>\"general\"</code> room)</li> <li>Start synchronizing with the new <code>roomId</code> (connect to the <code>\"travel\"</code> room)</li> </ol> <p>Luckily, you've already taught React how to do both of these things! Your Effect's body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let's see how exactly that happens.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#how-react-re-synchronizes-your-effect","title":"How React re-synchronizes your Effect","text":"<p>Recall that your <code>ChatRoom</code> component has received a new value for its <code>roomId</code> prop. It used to be <code>\"general\"</code>, and now it is <code>\"travel\"</code>. React needs to re-synchronize your Effect to re-connect you to a different room.</p> <p>To stop synchronizing, React will call the cleanup function that your Effect returned after connecting to the <code>\"general\"</code> room. Since <code>roomId</code> was <code>\"general\"</code>, the cleanup function disconnects from the <code>\"general\"</code> room:</p> <pre><code>function ChatRoom({ roomId /* \"general\" */ }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // Connects to the \"general\" room\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect(); // Disconnects from the \"general\" room\n};\n// ...\n</code></pre> <p>Then React will run the Effect that you've provided during this render. This time, <code>roomId</code> is <code>\"travel\"</code> so it will start synchronizing to the <code>\"travel\"</code> chat room (until its cleanup function is eventually called too):</p> <pre><code>function ChatRoom({ roomId /* \"travel\" */ }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // Connects to the \"travel\" room\nconnection.connect();\n// ...\n</code></pre> <p>Thanks to this, you're now connected to the same room that the user chose in the UI. Disaster averted!</p> <p>Every time after your component re-renders with a different <code>roomId</code>, your Effect will re-synchronize. For example, let's say the user changes <code>roomId</code> from <code>\"travel\"</code> to <code>\"music\"</code>. React will again stop synchronizing your Effect by calling its cleanup function (disconnecting you from the <code>\"travel\"</code> room). Then it will start synchronizing again by running its body with the new <code>roomId</code> prop (connecting you to the <code>\"music\"</code> room).</p> <p>Finally, when the user goes to a different screen, <code>ChatRoom</code> unmounts. Now there is no need to stay connected at all. React will stop synchronizing your Effect one last time and disconnect you from the <code>\"music\"</code> chat room.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#thinking-from-the-effects-perspective","title":"Thinking from the Effect's perspective","text":"<p>Let's recap everything that's happened from the <code>ChatRoom</code> component's perspective:</p> <ol> <li><code>ChatRoom</code> mounted with <code>roomId</code> set to <code>\"general\"</code></li> <li><code>ChatRoom</code> updated with <code>roomId</code> set to <code>\"travel\"</code></li> <li><code>ChatRoom</code> updated with <code>roomId</code> set to <code>\"music\"</code></li> <li><code>ChatRoom</code> unmounted</li> </ol> <p>During each of these points in the component's lifecycle, your Effect did different things:</p> <ol> <li>Your Effect connected to the <code>\"general\"</code> room</li> <li>Your Effect disconnected from the <code>\"general\"</code> room and connected to the <code>\"travel\"</code> room</li> <li>Your Effect disconnected from the <code>\"travel\"</code> room and connected to the <code>\"music\"</code> room</li> <li>Your Effect disconnected from the <code>\"music\"</code> room</li> </ol> <p>Now let's think about what happened from the perspective of the Effect itself:</p> <pre><code>useEffect(() =&gt; {\n// Your Effect connected to the room specified with roomId...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\n// ...until it disconnected\nconnection.disconnect();\n};\n}, [roomId]);\n</code></pre> <p>This code's structure might inspire you to see what happened as a sequence of non-overlapping time periods:</p> <ol> <li>Your Effect connected to the <code>\"general\"</code> room (until it disconnected)</li> <li>Your Effect connected to the <code>\"travel\"</code> room (until it disconnected)</li> <li>Your Effect connected to the <code>\"music\"</code> room (until it disconnected)</li> </ol> <p>Previously, you were thinking from the component's perspective. When you looked from the component's perspective, it was tempting to think of Effects as \"callbacks\" or \"lifecycle events\" that fire at a specific time like \"after a render\" or \"before unmount\". This way of thinking gets complicated very fast, so it's best to avoid.</p> <p>Instead, always focus on a single start/stop cycle at a time. It shouldn't matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it's needed.</p> <p>This might remind you how you don't think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React figures out the rest.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#how-react-verifies-that-your-effect-can-re-synchronize","title":"How React verifies that your Effect can re-synchronize","text":"<p>Here is a live example that you can play with. Press \"Open chat\" to mount the <code>ChatRoom</code> component:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Notice that when the component mounts for the first time, you see three logs:</p> <ol> <li><code>\u2705 Connecting to \"general\" room at https://localhost:1234...</code> (development-only)</li> <li><code>\u274c Disconnected from \"general\" room at https://localhost:1234.</code> (development-only)</li> <li><code>\u2705 Connecting to \"general\" room at https://localhost:1234...</code></li> </ol> <p>The first two logs are development-only. In development, React always remounts each component once.</p> <p>React verifies that your Effect can re-synchronize by forcing it to do that immediately in development. This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check you've implemented its cleanup well.</p> <p>The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the <code>roomId</code> changes, your Effect re-synchronizes.</p> <p>However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the <code>serverUrl</code> in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#how-react-knows-that-it-needs-to-re-synchronize-the-effect","title":"How React knows that it needs to re-synchronize the Effect","text":"<p>You might be wondering how React knew that your Effect needed to re-synchronize after <code>roomId</code> changes. It's because you told React that its code depends on <code>roomId</code> by including it in the list of dependencies:</p> <pre><code>function ChatRoom({ roomId }) { // The roomId prop may change over time\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // This Effect reads roomId\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]); // So you tell React that this Effect \"depends on\" roomId\n// ...\n</code></pre> <p>Here's how this works:</p> <ol> <li>You knew <code>roomId</code> is a prop, which means it can change over time.</li> <li>You knew that your Effect reads <code>roomId</code> (so its logic depends on a value that may change later).</li> <li>This is why you specified it as your Effect's dependency (so that it re-synchronizes when <code>roomId</code> changes).</li> </ol> <p>Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.</p> <p>For example, if you passed <code>[\"general\"]</code> during the initial render, and later you passed <code>[\"travel\"]</code> during the next render, React will compare <code>\"general\"</code> and <code>\"travel\"</code>. These are different values (compared with <code>Object.is</code>), so React will re-synchronize your Effect. On the other hand, if your component re-renders but <code>roomId</code> has not changed, your Effect will remain connected to the same room.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#each-effect-represents-a-separate-synchronization-process","title":"Each Effect represents a separate synchronization process","text":"<p>Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let's say you want to send an analytics event when the user visits the room. You already have an Effect that depends on <code>roomId</code>, so you might feel tempted to add the analytics call there:</p> <pre><code>function ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nlogVisit(roomId);\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]);\n// ...\n}\n</code></pre> <p>But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call <code>logVisit(roomId)</code> for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects:</p> <pre><code>function ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nlogVisit(roomId);\n}, [roomId]);\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\n// ...\n}, [roomId]);\n// ...\n}\n</code></pre> <p>Each Effect in your code should represent a separate and independent synchronization process.</p> <p>In the above example, deleting one Effect wouldn\u2019t break the other Effect's logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look \"cleaner\" but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#effects-react-to-reactive-values","title":"Effects \"react\" to reactive values","text":"<p>Your Effect reads two variables (<code>serverUrl</code> and <code>roomId</code>), but you only specified <code>roomId</code> as a dependency:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]);\n// ...\n}\n</code></pre> <p>Why doesn't <code>serverUrl</code> need to be a dependency?</p> <p>This is because the <code>serverUrl</code> never changes due to a re-render. It's always the same no matter how many times the component re-renders and why. Since <code>serverUrl</code> never changes, it wouldn't make sense to specify it as a dependency. After all, dependencies only do something when they change over time!</p> <p>On the other hand, <code>roomId</code> may be different on a re-render. Props, state, and other values declared inside the component are reactive because they're calculated during rendering and participate in the React data flow.</p> <p>If <code>serverUrl</code> was a state variable, it would be reactive. Reactive values must be included in dependencies:</p> <pre><code>function ChatRoom({ roomId }) {\n// Props change over time\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); // State may change over time\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // Your Effect reads props and state\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]); // So you tell React that this Effect \"depends on\" on props and state\n// ...\n}\n</code></pre> <p>By including <code>serverUrl</code> as a dependency, you ensure that the Effect re-synchronizes after it changes.</p> <p>Try changing the selected chat room or edit the server URL in this sandbox:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Whenever you change a reactive value like <code>roomId</code> or <code>serverUrl</code>, the Effect re-connects to the chat server.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#what-an-effect-with-empty-dependencies-means","title":"What an Effect with empty dependencies means","text":"<p>What happens if you move both <code>serverUrl</code> and <code>roomId</code> outside the component?</p> <pre><code>const serverUrl = \"https://localhost:1234\";\nconst roomId = \"general\";\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Now your Effect's code does not use any reactive values, so its dependencies can be empty (<code>[]</code>).</p> <p>Thinking from the component's perspective, the empty <code>[]</code> dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would still re-synchronize it an extra time in development to stress-test your logic.)</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\nconst roomId = \"general\";\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []);\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>However, if you think from the Effect's perspective, you don't need to think about mounting and unmounting at all. What's important is you've specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change <code>roomId</code> or <code>serverUrl</code> over time (and they would become reactive), your Effect's code won't change. You will only need to add them to the dependencies.</p>"},{"location":"learn/lifecycle-of-reactive-effects/#all-variables-declared-in-the-component-body-are-reactive","title":"All variables declared in the component body are reactive","text":"<p>Props and state aren't the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.</p> <p>Let's say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you've already put the settings state in a context so you read the <code>settings</code> from that context. Now you calculate the <code>serverUrl</code> based on the selected server from props and the default server:</p> <pre><code>function ChatRoom({ roomId, selectedServerUrl }) {\n// roomId is reactive\nconst settings = useContext(SettingsContext); // settings is reactive\nconst serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!\n// ...\n}\n</code></pre> <p>In this example, <code>serverUrl</code> is not a prop or a state variable. It's a regular variable that you calculate during rendering. But it's calculated during rendering, so it can change due to a re-render. This is why it's reactive.</p> <p>All values inside the component (including props, state, and variables in your component's body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect's dependencies.</p> <p>In other words, Effects \"react\" to all values from the component body.</p> <p>"},{"location":"learn/lifecycle-of-reactive-effects/#can-global-or-mutable-values-be-dependencies","title":"Can global or mutable values be dependencies?","text":"<p>Mutable values (including global variables) aren't reactive.</p> <p>A mutable value like <code>location.pathname</code> can't be a dependency. It's mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn't trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React wouldn't know to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks purity of rendering. Instead, you should read and subscribe to an external mutable value with <code>useSyncExternalStore</code>.</p> <p>A mutable value like <code>ref.current</code> or things you read from it also can't be a dependency. The ref object returned by <code>useRef</code> itself can be a dependency, but its <code>current</code> property is intentionally mutable. It lets you keep track of something without triggering a re-render. But since changing it doesn't trigger a re-render, it's not a reactive value, and React won't know to re-run your Effect when it changes.</p> <p>As you'll learn below on this page, a linter will check for these issues automatically.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#react-verifies-that-you-specified-every-reactive-value-as-a-dependency","title":"React verifies that you specified every reactive value as a dependency","text":"<p>If your linter is configured for React, it will check that every reactive value used by your Effect's code is declared as its dependency. For example, this is a lint error because both <code>roomId</code> and <code>serverUrl</code> are reactive:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\n// roomId is reactive\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); // serverUrl is reactive\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // &lt;-- Something's wrong here!\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>This may look like a React error, but really React is pointing out a bug in your code. Both <code>roomId</code> and <code>serverUrl</code> may change over time, but you're forgetting to re-synchronize your Effect when they change. You will remain connected to the initial <code>roomId</code> and <code>serverUrl</code> even after the user picks different values in the UI.</p> <p>To fix the bug, follow the linter's suggestion to specify <code>roomId</code> and <code>serverUrl</code> as dependencies of your Effect:</p> <pre><code>function ChatRoom({ roomId }) {\n// roomId is reactive\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); // serverUrl is reactive\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.</p> <p> <p>In some cases, React knows that a value never changes even though it's declared inside the component. For example, the <code>set</code> function returned from <code>useState</code> and the ref object returned by <code>useRef</code> are stable--they are guaranteed to not change on a re-render. Stable values aren't reactive, so you may omit them from the list. Including them is allowed: they won't change, so it doesn't matter.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#what-to-do-when-you-dont-want-to-re-synchronize","title":"What to do when you don't want to re-synchronize","text":"<p>In the previous example, you've fixed the lint error by listing <code>roomId</code> and <code>serverUrl</code> as dependencies.</p> <p>However, you could instead \"prove\" to the linter that these values aren't reactive values, i.e. that they can't change as a result of a re-render. For example, if <code>serverUrl</code> and <code>roomId</code> don't depend on rendering and always have the same values, you can move them outside the component. Now they don't need to be dependencies:</p> <pre><code>const serverUrl = \"https://localhost:1234\"; // serverUrl is not reactive\nconst roomId = \"general\"; // roomId is not reactive\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>You can also move them inside the Effect. They aren't calculated during rendering, so they're not reactive:</p> <pre><code>function ChatRoom() {\nuseEffect(() =&gt; {\nconst serverUrl = \"https://localhost:1234\"; // serverUrl is not reactive\nconst roomId = \"general\"; // roomId is not reactive\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Effects are reactive blocks of code. They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.</p> <p>You can't \"choose\" your dependencies. Your dependencies must include every reactive value you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don't fix these problems by suppressing the linter! Here's what to try instead:</p> <ul> <li> <p>Check that your Effect represents an independent synchronization process. If your Effect doesn't synchronize anything, it might be unnecessary. If it synchronizes several independent things, split it up.</p> </li> <li> <p>If you want to read the latest value of props or state without \"reacting\" to it and re-synchronizing the Effect, you can split your Effect into a reactive part (which you'll keep in the Effect) and a non-reactive part (which you'll extract into something called an Effect Event). Read about separating Events from Effects.</p> </li> <li> <p>Avoid relying on objects and functions as dependencies. If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. Read more about removing unnecessary dependencies from Effects.</p> </li> </ul> <p> <p>The linter is your friend, but its powers are limited. The linter only knows when the dependencies are wrong. It doesn't know the best way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn't mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn't reactive and doesn't need to be a dependency.</p> <p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p> <pre><code>useEffect(() =&gt; {\n// ...\n// \ud83d\udd34 Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}, []);\n</code></pre> <p>On the next pages, you'll learn how to fix this code without breaking the rules. It's always worth fixing!</p> <p></p> <p> <ul> <li>Components can mount, update, and unmount.</li> <li>Each Effect has a separate lifecycle from the surrounding component.</li> <li>Each Effect describes a separate synchronization process that can start and stop.</li> <li>When you write and read Effects, think from each individual Effect's perspective (how to start and stop synchronization) rather than from the component's perspective (how it mounts, updates, or unmounts).</li> <li>Values declared inside the component body are \"reactive\".</li> <li>Reactive values should re-synchronize the Effect because they can change over time.</li> <li>The linter verifies that all reactive values used inside the Effect are specified as dependencies.</li> <li>All errors flagged by the linter are legitimate. There's always a way to fix the code to not break the rules.</li> </ul> <p></p> <p>"},{"location":"learn/lifecycle-of-reactive-effects/#fix-reconnecting-on-every-keystroke","title":"Fix reconnecting on every keystroke","text":"<p>In this example, the <code>ChatRoom</code> component connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.</p> <p>However, there is a problem. Whenever you type into the message box input at the bottom, <code>ChatRoom</code> also reconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn't happen.</p> <p> <p>You might need to add a dependency array for this Effect. What dependencies should be there?</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n});\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p> <p>This Effect didn't have a dependency array at all, so it re-synchronized after every re-render. First, add a dependency array. Then, make sure that every reactive value used by the Effect is specified in the array. For example, <code>roomId</code> is reactive (because it's a prop), so it should be included in the array. This ensures that when the user selects a different room, the chat reconnects. On the other hand, <code>serverUrl</code> is defined outside the component. This is why it doesn't need to be in the array.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#switch-synchronization-on-and-off","title":"Switch synchronization on and off","text":"<p>In this example, an Effect subscribes to the window <code>pointermove</code> event to move a pink dot on the screen. Try hovering over the preview area (or touching the screen if you're on a mobile device), and see how the pink dot follows your movement.</p> <p>There is also a checkbox. Ticking the checkbox toggles the <code>canMove</code> state variable, but this state variable is not used anywhere in the code. Your task is to change the code so that when <code>canMove</code> is <code>false</code> (the checkbox is ticked off), the dot should stop moving. After you toggle the checkbox back on (and set <code>canMove</code> to <code>true</code>), the box should follow the movement again. In other words, whether the dot can move or not should stay synchronized to whether the checkbox is checked.</p> <p> <p>You can't declare an Effect conditionally. However, the code inside the Effect can use conditions!</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p> <p>One solution is to wrap the <code>setPosition</code> call into an <code>if (canMove) { ... }</code> condition:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}, [canMove]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>Alternatively, you could wrap the event subscription logic into an <code>if (canMove) { ... }</code> condition:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nif (canMove) {\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}\n}, [canMove]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>In both of these cases, <code>canMove</code> is a reactive variable that you read inside the Effect. This is why it must be specified in the list of Effect dependencies. This ensures that the Effect re-synchronizes after every change to its value.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#investigate-a-stale-value-bug","title":"Investigate a stale value bug","text":"<p>In this example, the pink dot should move when the checkbox is on, and should stop moving when the checkbox is off. The logic for this has already been implemented: the <code>handleMove</code> event handler checks the <code>canMove</code> state variable.</p> <p>However, for some reason, the <code>canMove</code> state variable inside <code>handleMove</code> appears to be \"stale\": it's always <code>true</code>, even after you tick off the checkbox. How is this possible? Find the mistake in the code and fix it.</p> <p> <p>If you see a linter rule being suppressed, remove the suppression! That's where the mistakes usually are.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nfunction handleMove(e) {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n}\n\nuseEffect(() =&gt; {\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p> <p>The problem with the original code was suppressing the dependency linter. If you remove the suppression, you'll see that this Effect depends on the <code>handleMove</code> function. This makes sense: <code>handleMove</code> is declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!</p> <p>The author of the original code has \"lied\" to React by saying that the Effect does not depend (<code>[]</code>) on any reactive values. This is why React did not re-synchronize the Effect after <code>canMove</code> has changed (and <code>handleMove</code> with it). Because React did not re-synchronize the Effect, the <code>handleMove</code> attached as a listener is the <code>handleMove</code> function created during the initial render. During the initial render, <code>canMove</code> was <code>true</code>, which is why <code>handleMove</code> from the initial render will forever see that value.</p> <p>If you never suppress the linter, you will never see problems with stale values. There are a few different ways to solve this bug, but you should always start by removing the linter suppression. Then change the code to fix the lint error.</p> <p>You can change the Effect dependencies to <code>[handleMove]</code>, but since it's going to be a newly defined function for every render, you might as well remove dependencies array altogether. Then the Effect will re-synchronize after every re-render:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nfunction handleMove(e) {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n}\n\nuseEffect(() =&gt; {\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>This solution works, but it's not ideal. If you put <code>console.log('Resubscribing')</code> inside the Effect, you'll notice that it resubscribes after every re-render. Resubscribing is fast, but it would still be nice to avoid doing it so often.</p> <p>A better fix would be to move the <code>handleMove</code> function inside the Effect. Then <code>handleMove</code> won't be a reactive value, and so your Effect won't depend on a function. Instead, it will need to depend on <code>canMove</code> which your code now reads from inside the Effect. This matches the behavior you wanted, since your Effect will now stay synchronized with the value of <code>canMove</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n}\n\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}, [canMove]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>Try adding <code>console.log('Resubscribing')</code> inside the Effect body and notice that now it only resubscribes when you toggle the checkbox (<code>canMove</code> changes) or edit the code. This makes it better than the previous approach that always resubscribed.</p> <p>You'll learn a more general approach to this type of problem in Separating Events from Effects.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#fix-a-connection-switch","title":"Fix a connection switch","text":"<p>In this example, the chat service in <code>chat.js</code> exposes two different APIs: <code>createEncryptedConnection</code> and <code>createUnencryptedConnection</code>. The root <code>App</code> component lets the user choose whether to use encryption or not, and then passes down the corresponding API method to the child <code>ChatRoom</code> component as the <code>createConnection</code> prop.</p> <p>Notice that initially, the console logs say the connection is not encrypted. Try toggling the checkbox on: nothing will happen. However, if you change the selected room after that, then the chat will reconnect and enable encryption (as you'll see from the console messages). This is a bug. Fix the bug so that toggling the checkbox also causes the chat to reconnect.</p> <p> <p>Suppressing the linter is always suspicious. Could this be a bug?</p> <p></p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\nimport {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from \"./chat.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isEncrypted, setIsEncrypted] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isEncrypted}\nonChange={(e) =&gt; setIsEncrypted(e.target.checked)}\n/&gt;\nEnable encryption\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom\nroomId={roomId}\ncreateConnection={\nisEncrypted\n? createEncryptedConnection\n: createUnencryptedConnection\n}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function ChatRoom({ roomId, createConnection }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createEncryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 \ud83d\udd10 Connecting to \"' + roomId + \"... (encrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c \ud83d\udd10 Disconnected from \"' + roomId + '\" room (encrypted)'\n);\n},\n};\n}\n\nexport function createUnencryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 Connecting to \"' + roomId + \"... (unencrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room (unencrypted)'\n);\n},\n};\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>If you remove the linter suppression, you will see a lint error. The problem is that <code>createConnection</code> is a prop, so it's a reactive value. It can change over time! (And indeed, it should--when the user ticks the checkbox, the parent component passes a different value of the <code>createConnection</code> prop.) This is why it should be a dependency. Include it in the list to fix the bug:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\nimport {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from \"./chat.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isEncrypted, setIsEncrypted] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isEncrypted}\nonChange={(e) =&gt; setIsEncrypted(e.target.checked)}\n/&gt;\nEnable encryption\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom\nroomId={roomId}\ncreateConnection={\nisEncrypted\n? createEncryptedConnection\n: createUnencryptedConnection\n}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function ChatRoom({ roomId, createConnection }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, createConnection]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createEncryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 \ud83d\udd10 Connecting to \"' + roomId + \"... (encrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c \ud83d\udd10 Disconnected from \"' + roomId + '\" room (encrypted)'\n);\n},\n};\n}\n\nexport function createUnencryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 Connecting to \"' + roomId + \"... (unencrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room (unencrypted)'\n);\n},\n};\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p>It is correct that <code>createConnection</code> is a dependency. However, this code is a bit fragile because someone could edit the <code>App</code> component to pass an inline function as the value of this prop. In that case, its value would be different every time the <code>App</code> component re-renders, so the Effect might re-synchronize too often. To avoid this, you can pass <code>isEncrypted</code> down instead:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isEncrypted, setIsEncrypted] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isEncrypted}\nonChange={(e) =&gt; setIsEncrypted(e.target.checked)}\n/&gt;\nEnable encryption\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} isEncrypted={isEncrypted} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from \"./chat.js\";\n\nexport default function ChatRoom({ roomId, isEncrypted }) {\nuseEffect(() =&gt; {\nconst createConnection = isEncrypted\n? createEncryptedConnection\n: createUnencryptedConnection;\nconst connection = createConnection(roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, isEncrypted]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createEncryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 \ud83d\udd10 Connecting to \"' + roomId + \"... (encrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c \ud83d\udd10 Disconnected from \"' + roomId + '\" room (encrypted)'\n);\n},\n};\n}\n\nexport function createUnencryptedConnection(roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log('\u2705 Connecting to \"' + roomId + \"... (unencrypted)\");\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room (unencrypted)'\n);\n},\n};\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p>In this version, the <code>App</code> component passes a boolean prop instead of a function. Inside the Effect, you decide which function to use. Since both <code>createEncryptedConnection</code> and <code>createUnencryptedConnection</code> are declared outside the component, they aren't reactive, and don't need to be dependencies. You'll learn more about this in Removing Effect Dependencies.</p> <p></p>"},{"location":"learn/lifecycle-of-reactive-effects/#populate-a-chain-of-select-boxes","title":"Populate a chain of select boxes","text":"<p>In this example, there are two select boxes. One select box lets the user pick a planet. Another select box lets the user pick a place on that planet. The second box doesn't work yet. Your task is to make it show the places on the chosen planet.</p> <p>Look at how the first select box works. It populates the <code>planetList</code> state with the result from the <code>\"/planets\"</code> API call. The currently selected planet's ID is kept in the <code>planetId</code> state variable. You need to find where to add some additional code so that the <code>placeList</code> state variable is populated with the result of the <code>\"/planets/\" + planetId + \"/places\"</code> API call.</p> <p>If you implement this right, selecting a planet should populate the place list. Changing a planet should change the place list.</p> <p> <p>If you have two independent synchronization processes, you need to write two separate Effects.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchData } from \"./api.js\";\n\nexport default function Page() {\nconst [planetList, setPlanetList] = useState([]);\nconst [planetId, setPlanetId] = useState(\"\");\n\nconst [placeList, setPlaceList] = useState([]);\nconst [placeId, setPlaceId] = useState(\"\");\n\nuseEffect(() =&gt; {\nlet ignore = false;\nfetchData(\"/planets\").then((result) =&gt; {\nif (!ignore) {\nconsole.log(\"Fetched a list of planets.\");\nsetPlanetList(result);\nsetPlanetId(result[0].id); // Select the first planet\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nPick a planet:{\" \"}\n&lt;select\nvalue={planetId}\nonChange={(e) =&gt; {\nsetPlanetId(e.target.value);\n}}\n&gt;\n{planetList.map((planet) =&gt; (\n&lt;option key={planet.id} value={planet.id}&gt;\n{planet.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPick a place:{\" \"}\n&lt;select\nvalue={placeId}\nonChange={(e) =&gt; {\nsetPlaceId(e.target.value);\n}}\n&gt;\n{placeList.map((place) =&gt; (\n&lt;option key={place.id} value={place.id}&gt;\n{place.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nYou are going to: {placeId || \"???\"} on {planetId || \"???\"}{\" \"}\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function fetchData(url) {\nif (url === \"/planets\") {\nreturn fetchPlanets();\n} else if (url.startsWith(\"/planets/\")) {\nconst match = url.match(/^\\/planets\\/([\\w-]+)\\/places(\\/)?$/);\nif (!match || !match[1] || !match[1].length) {\nthrow Error(\n'Expected URL like \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\nreturn fetchPlaces(match[1]);\n} else\nthrow Error(\n'Expected URL like \"/planets\" or \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\n\nasync function fetchPlanets() {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve([\n{\nid: \"earth\",\nname: \"Earth\",\n},\n{\nid: \"venus\",\nname: \"Venus\",\n},\n{\nid: \"mars\",\nname: \"Mars\",\n},\n]);\n}, 1000);\n});\n}\n\nasync function fetchPlaces(planetId) {\nif (typeof planetId !== \"string\") {\nthrow Error(\n\"fetchPlaces(planetId) expects a string argument. \" +\n\"Instead received: \" +\nplanetId +\n\".\"\n);\n}\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nif (planetId === \"earth\") {\nresolve([\n{\nid: \"laos\",\nname: \"Laos\",\n},\n{\nid: \"spain\",\nname: \"Spain\",\n},\n{\nid: \"vietnam\",\nname: \"Vietnam\",\n},\n]);\n} else if (planetId === \"venus\") {\nresolve([\n{\nid: \"aurelia\",\nname: \"Aurelia\",\n},\n{\nid: \"diana-chasma\",\nname: \"Diana Chasma\",\n},\n{\nid: \"kumsong-vallis\",\nname: \"K\u016dms\u014fng Vallis\",\n},\n]);\n} else if (planetId === \"mars\") {\nresolve([\n{\nid: \"aluminum-city\",\nname: \"Aluminum City\",\n},\n{\nid: \"new-new-york\",\nname: \"New New York\",\n},\n{\nid: \"vishniac\",\nname: \"Vishniac\",\n},\n]);\n} else throw Error(\"Unknown planet ID: \" + planetId);\n}, 1000);\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>There are two independent synchronization processes:</p> <ul> <li>The first select box is synchronized to the remote list of planets.</li> <li>The second select box is synchronized to the remote list of places for the current <code>planetId</code>.</li> </ul> <p>This is why it makes sense to describe them as two separate Effects. Here's an example of how you could do this:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchData } from \"./api.js\";\n\nexport default function Page() {\nconst [planetList, setPlanetList] = useState([]);\nconst [planetId, setPlanetId] = useState(\"\");\n\nconst [placeList, setPlaceList] = useState([]);\nconst [placeId, setPlaceId] = useState(\"\");\n\nuseEffect(() =&gt; {\nlet ignore = false;\nfetchData(\"/planets\").then((result) =&gt; {\nif (!ignore) {\nconsole.log(\"Fetched a list of planets.\");\nsetPlanetList(result);\nsetPlanetId(result[0].id); // Select the first planet\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, []);\n\nuseEffect(() =&gt; {\nif (planetId === \"\") {\n// Nothing is selected in the first box yet\nreturn;\n}\n\nlet ignore = false;\nfetchData(\"/planets/\" + planetId + \"/places\").then((result) =&gt; {\nif (!ignore) {\nconsole.log('Fetched a list of places on \"' + planetId + '\".');\nsetPlaceList(result);\nsetPlaceId(result[0].id); // Select the first place\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [planetId]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nPick a planet:{\" \"}\n&lt;select\nvalue={planetId}\nonChange={(e) =&gt; {\nsetPlanetId(e.target.value);\n}}\n&gt;\n{planetList.map((planet) =&gt; (\n&lt;option key={planet.id} value={planet.id}&gt;\n{planet.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPick a place:{\" \"}\n&lt;select\nvalue={placeId}\nonChange={(e) =&gt; {\nsetPlaceId(e.target.value);\n}}\n&gt;\n{placeList.map((place) =&gt; (\n&lt;option key={place.id} value={place.id}&gt;\n{place.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nYou are going to: {placeId || \"???\"} on {planetId || \"???\"}{\" \"}\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function fetchData(url) {\nif (url === \"/planets\") {\nreturn fetchPlanets();\n} else if (url.startsWith(\"/planets/\")) {\nconst match = url.match(/^\\/planets\\/([\\w-]+)\\/places(\\/)?$/);\nif (!match || !match[1] || !match[1].length) {\nthrow Error(\n'Expected URL like \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\nreturn fetchPlaces(match[1]);\n} else\nthrow Error(\n'Expected URL like \"/planets\" or \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\n\nasync function fetchPlanets() {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve([\n{\nid: \"earth\",\nname: \"Earth\",\n},\n{\nid: \"venus\",\nname: \"Venus\",\n},\n{\nid: \"mars\",\nname: \"Mars\",\n},\n]);\n}, 1000);\n});\n}\n\nasync function fetchPlaces(planetId) {\nif (typeof planetId !== \"string\") {\nthrow Error(\n\"fetchPlaces(planetId) expects a string argument. \" +\n\"Instead received: \" +\nplanetId +\n\".\"\n);\n}\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nif (planetId === \"earth\") {\nresolve([\n{\nid: \"laos\",\nname: \"Laos\",\n},\n{\nid: \"spain\",\nname: \"Spain\",\n},\n{\nid: \"vietnam\",\nname: \"Vietnam\",\n},\n]);\n} else if (planetId === \"venus\") {\nresolve([\n{\nid: \"aurelia\",\nname: \"Aurelia\",\n},\n{\nid: \"diana-chasma\",\nname: \"Diana Chasma\",\n},\n{\nid: \"kumsong-vallis\",\nname: \"K\u016dms\u014fng Vallis\",\n},\n]);\n} else if (planetId === \"mars\") {\nresolve([\n{\nid: \"aluminum-city\",\nname: \"Aluminum City\",\n},\n{\nid: \"new-new-york\",\nname: \"New New York\",\n},\n{\nid: \"vishniac\",\nname: \"Vishniac\",\n},\n]);\n} else throw Error(\"Unknown planet ID: \" + planetId);\n}, 1000);\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p>This code is a bit repetitive. However, that's not a good reason to combine it into a single Effect! If you did this, you'd have to combine both Effect's dependencies into one list, and then changing the planet would refetch the list of all planets. Effects are not a tool for code reuse.</p> <p>Instead, to reduce repetition, you can extract some logic into a custom Hook like <code>useSelectOptions</code> below:</p> <pre><code>import { useState } from \"react\";\nimport { useSelectOptions } from \"./useSelectOptions.js\";\n\nexport default function Page() {\nconst [planetList, planetId, setPlanetId] = useSelectOptions(\"/planets\");\n\nconst [placeList, placeId, setPlaceId] = useSelectOptions(\nplanetId ? `/planets/${planetId}/places` : null\n);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nPick a planet:{\" \"}\n&lt;select\nvalue={planetId}\nonChange={(e) =&gt; {\nsetPlanetId(e.target.value);\n}}\n&gt;\n{planetList?.map((planet) =&gt; (\n&lt;option key={planet.id} value={planet.id}&gt;\n{planet.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPick a place:{\" \"}\n&lt;select\nvalue={placeId}\nonChange={(e) =&gt; {\nsetPlaceId(e.target.value);\n}}\n&gt;\n{placeList?.map((place) =&gt; (\n&lt;option key={place.id} value={place.id}&gt;\n{place.name}\n&lt;/option&gt;\n))}\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nYou are going to: {placeId || \"...\"} on {planetId || \"...\"}{\" \"}\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchData } from \"./api.js\";\n\nexport function useSelectOptions(url) {\nconst [list, setList] = useState(null);\nconst [selectedId, setSelectedId] = useState(\"\");\nuseEffect(() =&gt; {\nif (url === null) {\nreturn;\n}\n\nlet ignore = false;\nfetchData(url).then((result) =&gt; {\nif (!ignore) {\nsetList(result);\nsetSelectedId(result[0].id);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [url]);\nreturn [list, selectedId, setSelectedId];\n}\n</code></pre> <pre><code>export function fetchData(url) {\nif (url === \"/planets\") {\nreturn fetchPlanets();\n} else if (url.startsWith(\"/planets/\")) {\nconst match = url.match(/^\\/planets\\/([\\w-]+)\\/places(\\/)?$/);\nif (!match || !match[1] || !match[1].length) {\nthrow Error(\n'Expected URL like \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\nreturn fetchPlaces(match[1]);\n} else\nthrow Error(\n'Expected URL like \"/planets\" or \"/planets/earth/places\". Received: \"' +\nurl +\n'\".'\n);\n}\n\nasync function fetchPlanets() {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve([\n{\nid: \"earth\",\nname: \"Earth\",\n},\n{\nid: \"venus\",\nname: \"Venus\",\n},\n{\nid: \"mars\",\nname: \"Mars\",\n},\n]);\n}, 1000);\n});\n}\n\nasync function fetchPlaces(planetId) {\nif (typeof planetId !== \"string\") {\nthrow Error(\n\"fetchPlaces(planetId) expects a string argument. \" +\n\"Instead received: \" +\nplanetId +\n\".\"\n);\n}\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nif (planetId === \"earth\") {\nresolve([\n{\nid: \"laos\",\nname: \"Laos\",\n},\n{\nid: \"spain\",\nname: \"Spain\",\n},\n{\nid: \"vietnam\",\nname: \"Vietnam\",\n},\n]);\n} else if (planetId === \"venus\") {\nresolve([\n{\nid: \"aurelia\",\nname: \"Aurelia\",\n},\n{\nid: \"diana-chasma\",\nname: \"Diana Chasma\",\n},\n{\nid: \"kumsong-vallis\",\nname: \"K\u016dms\u014fng Vallis\",\n},\n]);\n} else if (planetId === \"mars\") {\nresolve([\n{\nid: \"aluminum-city\",\nname: \"Aluminum City\",\n},\n{\nid: \"new-new-york\",\nname: \"New New York\",\n},\n{\nid: \"vishniac\",\nname: \"Vishniac\",\n},\n]);\n} else throw Error(\"Unknown planet ID: \" + planetId);\n}, 1000);\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p>Check the <code>useSelectOptions.js</code> tab in the sandbox to see how it works. Ideally, most Effects in your application should eventually be replaced by custom Hooks, whether written by you or by the community. Custom Hooks hide the synchronization logic, so the calling component doesn't know about the Effect. As you keep working on your app, you'll develop a palette of Hooks to choose from, and eventually you won't need to write Effects in your components very often.</p> <p></p> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/","title":"Manipulating the DOM with Refs \ud83d\udea7","text":""},{"location":"learn/manipulating-the-dom-with-refs/#overview","title":"Overview","text":"<p>  React automatically updates the DOM to match your render output, so your components won't often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React--for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node.  </p> <p>You will learn</p> <ul> <li>How to access a DOM node managed by React with the <code>ref</code> attribute</li> <li>How the <code>ref</code> JSX attribute relates to the <code>useRef</code> Hook</li> <li>How to access another component's DOM node</li> <li>In which cases it's safe to modify the DOM managed by React</li> </ul>"},{"location":"learn/manipulating-the-dom-with-refs/#getting-a-ref-to-the-node","title":"Getting a ref to the node","text":"<p>To access a DOM node managed by React, first, import the <code>useRef</code> Hook:</p> <pre><code>import { useRef } from \"react\";\n</code></pre> <p>Then, use it to declare a ref inside your component:</p> <pre><code>const myRef = useRef(null);\n</code></pre> <p>Finally, pass your ref as the <code>ref</code> attribute to the JSX tag for which you want to get the DOM node:</p> <pre><code>&lt;div ref={myRef}&gt;\n</code></pre> <p>The <code>useRef</code> Hook returns an object with a single property called <code>current</code>. Initially, <code>myRef.current</code> will be <code>null</code>. When React creates a DOM node for this <code>&lt;div&gt;</code>, React will put a reference to this node into <code>myRef.current</code>. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.</p> <pre><code>// You can use any browser APIs, for example:\nmyRef.current.scrollIntoView();\n</code></pre>"},{"location":"learn/manipulating-the-dom-with-refs/#example-focusing-a-text-input","title":"Example: Focusing a text input","text":"<p>In this example, clicking the button will focus the input:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Form() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;input ref={inputRef} /&gt;\n&lt;button on_click={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>To implement this:</p> <ol> <li>Declare <code>inputRef</code> with the <code>useRef</code> Hook.</li> <li>Pass it as <code>&lt;input ref={inputRef}&gt;</code>. This tells React to put this <code>&lt;input&gt;</code>'s DOM node into <code>inputRef.current</code>.</li> <li>In the <code>handleClick</code> function, read the input DOM node from <code>inputRef.current</code> and call <code>focus()</code> on it with <code>inputRef.current.focus()</code>.</li> <li>Pass the <code>handleClick</code> event handler to <code>&lt;button&gt;</code> with <code>on_click</code>.</li> </ol> <p>While DOM manipulation is the most common use case for refs, the <code>useRef</code> Hook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don't trigger re-renders when you set them. Read about refs in Referencing Values with Refs.</p>"},{"location":"learn/manipulating-the-dom-with-refs/#example-scrolling-to-an-element","title":"Example: Scrolling to an element","text":"<p>You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browser <code>scrollIntoView()</code> method on the corresponding DOM node:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function CatFriends() {\nconst firstCatRef = useRef(null);\nconst secondCatRef = useRef(null);\nconst thirdCatRef = useRef(null);\n\nfunction handleScrollToFirstCat() {\nfirstCatRef.current.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}\n\nfunction handleScrollToSecondCat() {\nsecondCatRef.current.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}\n\nfunction handleScrollToThirdCat() {\nthirdCatRef.current.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button on_click={handleScrollToFirstCat}&gt;Tom&lt;/button&gt;\n&lt;button on_click={handleScrollToSecondCat}&gt;Maru&lt;/button&gt;\n&lt;button on_click={handleScrollToThirdCat}&gt;Jellylorum&lt;/button&gt;\n&lt;/nav&gt;\n&lt;div&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/200/200\"\nalt=\"Tom\"\nref={firstCatRef}\n/&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/300/200\"\nalt=\"Maru\"\nref={secondCatRef}\n/&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/250/200\"\nalt=\"Jellylorum\"\nref={thirdCatRef}\n/&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>div {\nwidth: 100%;\noverflow: hidden;\n}\n\nnav {\ntext-align: center;\n}\n\nbutton {\nmargin: 0.25rem;\n}\n\nul,\nli {\nlist-style: none;\nwhite-space: nowrap;\n}\n\nli {\ndisplay: inline;\npadding: 0.5rem;\n}\n</code></pre> <p>"},{"location":"learn/manipulating-the-dom-with-refs/#how-to-manage-a-list-of-refs-using-a-ref-callback","title":"How to manage a list of refs using a ref callback","text":"<p>In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don't know how many you will have. Something like this wouldn't work:</p> <pre><code>&lt;ul&gt;\n{items.map((item) =&gt; {\n// Doesn't work!\nconst ref = useRef(null);\nreturn &lt;li ref={ref} /&gt;;\n})}\n&lt;/ul&gt;\n</code></pre> <p>This is because Hooks must only be called at the top-level of your component. You can't call <code>useRef</code> in a loop, in a condition, or inside a <code>map()</code> call.</p> <p>One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like <code>querySelectorAll</code> to \"find\" the individual child nodes from it. However, this is brittle and can break if your DOM structure changes.</p> <p>Another solution is to pass a function to the <code>ref</code> attribute. This is called a <code>ref</code> callback. React will call your ref callback with the DOM node when it's time to set the ref, and with <code>null</code> when it's time to clear it. This lets you maintain your own array or a Map, and access any ref by its index or some kind of ID.</p> <p>This example shows how you can use this approach to scroll to an arbitrary node in a long list:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function CatFriends() {\nconst itemsRef = useRef(null);\n\nfunction scrollToId(itemId) {\nconst map = getMap();\nconst node = map.get(itemId);\nnode.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}\n\nfunction getMap() {\nif (!itemsRef.current) {\n// Initialize the Map on first usage.\nitemsRef.current = new Map();\n}\nreturn itemsRef.current;\n}\n\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button on_click={() =&gt; scrollToId(0)}&gt;Tom&lt;/button&gt;\n&lt;button on_click={() =&gt; scrollToId(5)}&gt;Maru&lt;/button&gt;\n&lt;button on_click={() =&gt; scrollToId(9)}&gt;Jellylorum&lt;/button&gt;\n&lt;/nav&gt;\n&lt;div&gt;\n&lt;ul&gt;\n{catList.map((cat) =&gt; (\n&lt;li\nkey={cat.id}\nref={(node) =&gt; {\nconst map = getMap();\nif (node) {\nmap.set(cat.id, node);\n} else {\nmap.delete(cat.id);\n}\n}}\n&gt;\n&lt;img src={cat.imageUrl} alt={\"Cat #\" + cat.id} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nconst catList = [];\nfor (let i = 0; i &lt; 10; i++) {\ncatList.push({\nid: i,\nimageUrl: \"https://placekitten.com/250/200?image=\" + i,\n});\n}\n</code></pre> <pre><code>div {\nwidth: 100%;\noverflow: hidden;\n}\n\nnav {\ntext-align: center;\n}\n\nbutton {\nmargin: 0.25rem;\n}\n\nul,\nli {\nlist-style: none;\nwhite-space: nowrap;\n}\n\nli {\ndisplay: inline;\npadding: 0.5rem;\n}\n</code></pre> <p>In this example, <code>itemsRef</code> doesn't hold a single DOM node. Instead, it holds a Map from item ID to a DOM node. (Refs can hold any values!) The <code>ref</code> callback on every list item takes care to update the Map:</p> <pre><code>&lt;li\nkey={cat.id}\nref={node =&gt; {\nconst map = getMap();\nif (node) {\n// Add to the Map\nmap.set(cat.id, node);\n} else {\n// Remove from the Map\nmap.delete(cat.id);\n}\n}}\n&gt;\n</code></pre> <p>This lets you read individual DOM nodes from the Map later.</p> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#accessing-another-components-dom-nodes","title":"Accessing another component's DOM nodes","text":"<p>When you put a ref on a built-in component that outputs a browser element like <code>&lt;input /&gt;</code>, React will set that ref's <code>current</code> property to the corresponding DOM node (such as the actual <code>&lt;input /&gt;</code> in the browser).</p> <p>However, if you try to put a ref on your own component, like <code>&lt;MyInput /&gt;</code>, by default you will get <code>null</code>. Here is an example demonstrating it. Notice how clicking the button does not focus the input:</p> <pre><code>import { useRef } from \"react\";\n\nfunction MyInput(props) {\nreturn &lt;input {...props} /&gt;;\n}\n\nexport default function MyForm() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;MyInput ref={inputRef} /&gt;\n&lt;button on_click={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>To help you notice the issue, React also prints an error to the console:</p> <p> <p>Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p> <p></p> <p>This happens because by default React does not let a component access the DOM nodes of other components. Not even for its own children! This is intentional. Refs are an escape hatch that should be used sparingly. Manually manipulating another component's DOM nodes makes your code even more fragile.</p> <p>Instead, components that want to expose their DOM nodes have to opt in to that behavior. A component can specify that it \"forwards\" its ref to one of its children. Here's how <code>MyInput</code> can use the <code>forwardRef</code> API:</p> <pre><code>const MyInput = forwardRef((props, ref) =&gt; {\nreturn &lt;input {...props} ref={ref} /&gt;;\n});\n</code></pre> <p>This is how it works:</p> <ol> <li><code>&lt;MyInput ref={inputRef} /&gt;</code> tells React to put the corresponding DOM node into <code>inputRef.current</code>. However, it's up to the <code>MyInput</code> component to opt into that--by default, it doesn't.</li> <li>The <code>MyInput</code> component is declared using <code>forwardRef</code>. This opts it into receiving the <code>inputRef</code> from above as the second <code>ref</code> argument which is declared after <code>props</code>.</li> <li><code>MyInput</code> itself passes the <code>ref</code> it received to the <code>&lt;input&gt;</code> inside of it.</li> </ol> <p>Now clicking the button to focus the input works:</p> <pre><code>import { forwardRef, useRef } from \"react\";\n\nconst MyInput = forwardRef((props, ref) =&gt; {\nreturn &lt;input {...props} ref={ref} /&gt;;\n});\n\nexport default function Form() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;MyInput ref={inputRef} /&gt;\n&lt;button on_click={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>In design systems, it is a common pattern for low-level components like buttons, inputs, and so on, to forward their refs to their DOM nodes. On the other hand, high-level components like forms, lists, or page sections usually won't expose their DOM nodes to avoid accidental dependencies on the DOM structure.</p> <p>"},{"location":"learn/manipulating-the-dom-with-refs/#exposing-a-subset-of-the-api-with-an-imperative-handle","title":"Exposing a subset of the API with an imperative handle","text":"<p>In the above example, <code>MyInput</code> exposes the original DOM input element. This lets the parent component call <code>focus()</code> on it. However, this also lets the parent component do something else--for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that with <code>useImperativeHandle</code>:</p> <pre><code>import { forwardRef, useRef, useImperativeHandle } from \"react\";\n\nconst MyInput = forwardRef((props, ref) =&gt; {\nconst realInputRef = useRef(null);\nuseImperativeHandle(ref, () =&gt; ({\n// Only expose focus and nothing else\nfocus() {\nrealInputRef.current.focus();\n},\n}));\nreturn &lt;input {...props} ref={realInputRef} /&gt;;\n});\n\nexport default function Form() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;MyInput ref={inputRef} /&gt;\n&lt;button on_click={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Here, <code>realInputRef</code> inside <code>MyInput</code> holds the actual input DOM node. However, <code>useImperativeHandle</code> instructs React to provide your own special object as the value of a ref to the parent component. So <code>inputRef.current</code> inside the <code>Form</code> component will only have the <code>focus</code> method. In this case, the ref \"handle\" is not the DOM node, but the custom object you create inside <code>useImperativeHandle</code> call.</p> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#when-react-attaches-the-refs","title":"When React attaches the refs","text":"<p>In React, every update is split in two phases:</p> <ul> <li>During render, React calls your components to figure out what should be on the screen.</li> <li>During commit, React applies changes to the DOM.</li> </ul> <p>In general, you don't want to access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, so <code>ref.current</code> will be <code>null</code>. And during the rendering of updates, the DOM nodes haven't been updated yet. So it's too early to read them.</p> <p>React sets <code>ref.current</code> during the commit. Before updating the DOM, React sets the affected <code>ref.current</code> values to <code>null</code>. After updating the DOM, React immediately sets them to the corresponding DOM nodes.</p> <p>Usually, you will access refs from event handlers. If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss effects on the next pages.</p> <p>"},{"location":"learn/manipulating-the-dom-with-refs/#flushing-state-updates-synchronously-with-flushsync","title":"Flushing state updates synchronously with flushSync","text":"<p>Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that was just before the last added one:</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function TodoList() {\nconst listRef = useRef(null);\nconst [text, setText] = useState(\"\");\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAdd() {\nconst newTodo = { id: nextId++, text: text };\nsetText(\"\");\nsetTodos([...todos, newTodo]);\nlistRef.current.lastChild.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleAdd}&gt;Add&lt;/button&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;ul ref={listRef}&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 0;\nlet initialTodos = [];\nfor (let i = 0; i &lt; 20; i++) {\ninitialTodos.push({\nid: nextId++,\ntext: \"Todo #\" + (i + 1),\n});\n}\n</code></pre> <p>The issue is with these two lines:</p> <pre><code>setTodos([...todos, newTodo]);\nlistRef.current.lastChild.scrollIntoView();\n</code></pre> <p>In React, state updates are queued. Usually, this is what you want. However, here it causes a problem because <code>setTodos</code> does not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always \"lags behind\" by one item.</p> <p>To fix this issue, you can force React to update (\"flush\") the DOM synchronously. To do this, import <code>flushSync</code> from <code>react-dom</code> and wrap the state update into a <code>flushSync</code> call:</p> <pre><code>flushSync(() =&gt; {\nsetTodos([...todos, newTodo]);\n});\nlistRef.current.lastChild.scrollIntoView();\n</code></pre> <p>This will instruct React to update the DOM synchronously right after the code wrapped in <code>flushSync</code> executes. As a result, the last todo will already be in the DOM by the time you try to scroll to it:</p> <pre><code>import { useState, useRef } from \"react\";\nimport { flushSync } from \"react-dom\";\n\nexport default function TodoList() {\nconst listRef = useRef(null);\nconst [text, setText] = useState(\"\");\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAdd() {\nconst newTodo = { id: nextId++, text: text };\nflushSync(() =&gt; {\nsetText(\"\");\nsetTodos([...todos, newTodo]);\n});\nlistRef.current.lastChild.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleAdd}&gt;Add&lt;/button&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;ul ref={listRef}&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 0;\nlet initialTodos = [];\nfor (let i = 0; i &lt; 20; i++) {\ninitialTodos.push({\nid: nextId++,\ntext: \"Todo #\" + (i + 1),\n});\n}\n</code></pre> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#best-practices-for-dom-manipulation-with-refs","title":"Best practices for DOM manipulation with refs","text":"<p>Refs are an escape hatch. You should only use them when you have to \"step outside React\". Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose.</p> <p>If you stick to non-destructive actions like focusing and scrolling, you shouldn't encounter any problems. However, if you try to modify the DOM manually, you can risk conflicting with the changes React is making.</p> <p>To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence using conditional rendering and state, as you would usually do in React. The second button uses the <code>remove()</code> DOM API to forcefully remove it from the DOM outside of React's control.</p> <p>Try pressing \"Toggle with setState\" a few times. The message should disappear and appear again. Then press \"Remove from the DOM\". This will forcefully remove it. Finally, press \"Toggle with setState\":</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Counter() {\nconst [show, setShow] = useState(true);\nconst ref = useRef(null);\n\nreturn (\n&lt;div&gt;\n&lt;button\non_click={() =&gt; {\nsetShow(!show);\n}}\n&gt;\nToggle with setState\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nref.current.remove();\n}}\n&gt;\nRemove from the DOM\n&lt;/button&gt;\n{show &amp;&amp; &lt;p ref={ref}&gt;Hello world&lt;/p&gt;}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>p,\nbutton {\ndisplay: block;\nmargin: 10px;\n}\n</code></pre> <p>After you've manually removed the DOM element, trying to use <code>setState</code> to show it again will lead to a crash. This is because you've changed the DOM, and React doesn't know how to continue managing it correctly.</p> <p>Avoid changing DOM nodes managed by React. Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above.</p> <p>However, this doesn't mean that you can't do it at all. It requires caution. You can safely modify parts of the DOM that React has no reason to update. For example, if some <code>&lt;div&gt;</code> is always empty in the JSX, React won't have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there.</p> <p> <ul> <li>Refs are a generic concept, but most often you'll use them to hold DOM elements.</li> <li>You instruct React to put a DOM node into <code>myRef.current</code> by passing <code>&lt;div ref={myRef}&gt;</code>.</li> <li>Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.</li> <li>A component doesn't expose its DOM nodes by default. You can opt into exposing a DOM node by using <code>forwardRef</code> and passing the second <code>ref</code> argument down to a specific node.</li> <li>Avoid changing DOM nodes managed by React.</li> <li>If you do modify DOM nodes managed by React, modify parts that React has no reason to update.</li> </ul> <p></p> <p>"},{"location":"learn/manipulating-the-dom-with-refs/#play-and-pause-the-video","title":"Play and pause the video","text":"<p>In this example, the button toggles a state variable to switch between a playing and a paused state. However, in order to actually play or pause the video, toggling state is not enough. You also need to call <code>play()</code> and <code>pause()</code> on the DOM element for the <code>&lt;video&gt;</code>. Add a ref to it, and make the button work.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function VideoPlayer() {\nconst [isPlaying, setIsPlaying] = useState(false);\n\nfunction handleClick() {\nconst nextIsPlaying = !isPlaying;\nsetIsPlaying(nextIsPlaying);\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;video width=\"250\"&gt;\n&lt;source\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\ntype=\"video/mp4\"\n/&gt;\n&lt;/video&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p>For an extra challenge, keep the \"Play\" button in sync with whether the video is playing even if the user right-clicks the video and plays it using the built-in browser media controls. You might want to listen to <code>onPlay</code> and <code>onPause</code> on the video to do that.</p> <p> <p>Declare a ref and put it on the <code>&lt;video&gt;</code> element. Then call <code>ref.current.play()</code> and <code>ref.current.pause()</code> in the event handler depending on the next state.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function VideoPlayer() {\nconst [isPlaying, setIsPlaying] = useState(false);\nconst ref = useRef(null);\n\nfunction handleClick() {\nconst nextIsPlaying = !isPlaying;\nsetIsPlaying(nextIsPlaying);\n\nif (nextIsPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;video\nwidth=\"250\"\nref={ref}\nonPlay={() =&gt; setIsPlaying(true)}\nonPause={() =&gt; setIsPlaying(false)}\n&gt;\n&lt;source\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\ntype=\"video/mp4\"\n/&gt;\n&lt;/video&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p>In order to handle the built-in browser controls, you can add <code>onPlay</code> and <code>onPause</code> handlers to the <code>&lt;video&gt;</code> element and call <code>setIsPlaying</code> from them. This way, if the user plays the video using the browser controls, the state will adjust accordingly.</p> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#focus-the-search-field","title":"Focus the search field","text":"<p>Make it so that clicking the \"Search\" button puts focus into the field.</p> <pre><code>export default function Page() {\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button&gt;Search&lt;/button&gt;\n&lt;/nav&gt;\n&lt;input placeholder=\"Looking for something?\" /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>Add a ref to the input, and call <code>focus()</code> on the DOM node to focus it:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Page() {\nconst inputRef = useRef(null);\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button\non_click={() =&gt; {\ninputRef.current.focus();\n}}\n&gt;\nSearch\n&lt;/button&gt;\n&lt;/nav&gt;\n&lt;input ref={inputRef} placeholder=\"Looking for something?\" /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#scrolling-an-image-carousel","title":"Scrolling an image carousel","text":"<p>This image carousel has a \"Next\" button that switches the active image. Make the gallery scroll horizontally to the active image on click. You will want to call <code>scrollIntoView()</code> on the DOM node of the active image:</p> <pre><code>node.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n</code></pre> <p> <p>You don't need to have a ref to every image for this exercise. It should be enough to have a ref to the currently active image, or to the list itself. Use <code>flushSync</code> to ensure the DOM is updated before you scroll.</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function CatFriends() {\nconst [index, setIndex] = useState(0);\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button\non_click={() =&gt; {\nif (index &lt; catList.length - 1) {\nsetIndex(index + 1);\n} else {\nsetIndex(0);\n}\n}}\n&gt;\nNext\n&lt;/button&gt;\n&lt;/nav&gt;\n&lt;div&gt;\n&lt;ul&gt;\n{catList.map((cat, i) =&gt; (\n&lt;li key={cat.id}&gt;\n&lt;img\nclassName={index === i ? \"active\" : \"\"}\nsrc={cat.imageUrl}\nalt={\"Cat #\" + cat.id}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nconst catList = [];\nfor (let i = 0; i &lt; 10; i++) {\ncatList.push({\nid: i,\nimageUrl: \"https://placekitten.com/250/200?image=\" + i,\n});\n}\n</code></pre> <pre><code>div {\nwidth: 100%;\noverflow: hidden;\n}\n\nnav {\ntext-align: center;\n}\n\nbutton {\nmargin: 0.25rem;\n}\n\nul,\nli {\nlist-style: none;\nwhite-space: nowrap;\n}\n\nli {\ndisplay: inline;\npadding: 0.5rem;\n}\n\nimg {\npadding: 10px;\nmargin: -10px;\ntransition: background 0.2s linear;\n}\n\n.active {\nbackground: rgba(0, 100, 150, 0.4);\n}\n</code></pre> <p> <p>You can declare a <code>selectedRef</code>, and then pass it conditionally only to the current image:</p> <pre><code>&lt;li ref={index === i ? selectedRef : null}&gt;\n</code></pre> <p>When <code>index === i</code>, meaning that the image is the selected one, the <code>&lt;li&gt;</code> will receive the <code>selectedRef</code>. React will make sure that <code>selectedRef.current</code> always points at the correct DOM node.</p> <p>Note that the <code>flushSync</code> call is necessary to force React to update the DOM before the scroll. Otherwise, <code>selectedRef.current</code> would always point at the previously selected item.</p> <pre><code>import { useRef, useState } from \"react\";\nimport { flushSync } from \"react-dom\";\n\nexport default function CatFriends() {\nconst selectedRef = useRef(null);\nconst [index, setIndex] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button\non_click={() =&gt; {\nflushSync(() =&gt; {\nif (index &lt; catList.length - 1) {\nsetIndex(index + 1);\n} else {\nsetIndex(0);\n}\n});\nselectedRef.current.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}}\n&gt;\nNext\n&lt;/button&gt;\n&lt;/nav&gt;\n&lt;div&gt;\n&lt;ul&gt;\n{catList.map((cat, i) =&gt; (\n&lt;li key={cat.id} ref={index === i ? selectedRef : null}&gt;\n&lt;img\nclassName={index === i ? \"active\" : \"\"}\nsrc={cat.imageUrl}\nalt={\"Cat #\" + cat.id}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nconst catList = [];\nfor (let i = 0; i &lt; 10; i++) {\ncatList.push({\nid: i,\nimageUrl: \"https://placekitten.com/250/200?image=\" + i,\n});\n}\n</code></pre> <pre><code>div {\nwidth: 100%;\noverflow: hidden;\n}\n\nnav {\ntext-align: center;\n}\n\nbutton {\nmargin: 0.25rem;\n}\n\nul,\nli {\nlist-style: none;\nwhite-space: nowrap;\n}\n\nli {\ndisplay: inline;\npadding: 0.5rem;\n}\n\nimg {\npadding: 10px;\nmargin: -10px;\ntransition: background 0.2s linear;\n}\n\n.active {\nbackground: rgba(0, 100, 150, 0.4);\n}\n</code></pre> <p></p>"},{"location":"learn/manipulating-the-dom-with-refs/#focus-the-search-field-with-separate-components","title":"Focus the search field with separate components","text":"<p>Make it so that clicking the \"Search\" button puts focus into the field. Note that each component is defined in a separate file and shouldn't be moved out of it. How do you connect them together?</p> <p> <p>You'll need <code>forwardRef</code> to opt into exposing a DOM node from your own component like <code>SearchInput</code>.</p> <p></p> <pre><code>import SearchButton from \"./SearchButton.js\";\nimport SearchInput from \"./SearchInput.js\";\n\nexport default function Page() {\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;SearchButton /&gt;\n&lt;/nav&gt;\n&lt;SearchInput /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function SearchButton() {\nreturn &lt;button&gt;Search&lt;/button&gt;;\n}\n</code></pre> <pre><code>export default function SearchInput() {\nreturn &lt;input placeholder=\"Looking for something?\" /&gt;;\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>You'll need to add an <code>on_click</code> prop to the <code>SearchButton</code>, and make the <code>SearchButton</code> pass it down to the browser <code>&lt;button&gt;</code>. You'll also pass a ref down to <code>&lt;SearchInput&gt;</code>, which will forward it to the real <code>&lt;input&gt;</code> and populate it. Finally, in the click handler, you'll call <code>focus</code> on the DOM node stored inside that ref.</p> <pre><code>import { useRef } from \"react\";\nimport SearchButton from \"./SearchButton.js\";\nimport SearchInput from \"./SearchInput.js\";\n\nexport default function Page() {\nconst inputRef = useRef(null);\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;SearchButton\non_click={() =&gt; {\ninputRef.current.focus();\n}}\n/&gt;\n&lt;/nav&gt;\n&lt;SearchInput ref={inputRef} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function SearchButton({ on_click }) {\nreturn &lt;button on_click={on_click}&gt;Search&lt;/button&gt;;\n}\n</code></pre> <pre><code>import { forwardRef } from \"react\";\n\nexport default forwardRef(function SearchInput(props, ref) {\nreturn &lt;input ref={ref} placeholder=\"Looking for something?\" /&gt;;\n});\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/passing-data-deeply-with-context/","title":"Passing Data Deeply with Context \ud83d\udea7","text":""},{"location":"learn/passing-data-deeply-with-context/#overview","title":"Overview","text":"<p>  Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information. Context lets the parent component make some information available to any component in the tree below it\u2014no matter how deep\u2014without passing it explicitly through props.  </p> <p>You will learn</p> <ul> <li>What \"prop drilling\" is</li> <li>How to replace repetitive prop passing with context</li> <li>Common use cases for context</li> <li>Common alternatives to context</li> </ul>"},{"location":"learn/passing-data-deeply-with-context/#the-problem-with-passing-props","title":"The problem with passing props","text":"<p>Passing props is a great way to explicitly pipe data through your UI tree to the components that use it.</p> <p>But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, and lifting state up that high can lead to a situation called \"prop drilling\".</p> <p>Wouldn't it be great if there were a way to \"teleport\" data to the components in the tree that need it without passing props? With React's context feature, there is!</p>"},{"location":"learn/passing-data-deeply-with-context/#context-an-alternative-to-passing-props","title":"Context: an alternative to passing props","text":"<p>Context lets a parent component provide data to the entire tree below it. There are many uses for context. Here is one example. Consider this <code>Heading</code> component that accepts a <code>level</code> for its size:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section&gt;\n&lt;Heading level={1}&gt;Title&lt;/Heading&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={5}&gt;Sub-sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={6}&gt;Sub-sub-sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>export default function Section({ children }) {\nreturn &lt;section className=\"section\"&gt;{children}&lt;/section&gt;;\n}\n</code></pre> <pre><code>export default function Heading({ level, children }) {\nswitch (level) {\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Let's say you want multiple headings within the same <code>Section</code> to always have the same size:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section&gt;\n&lt;Heading level={1}&gt;Title&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>export default function Section({ children }) {\nreturn &lt;section className=\"section\"&gt;{children}&lt;/section&gt;;\n}\n</code></pre> <pre><code>export default function Heading({ level, children }) {\nswitch (level) {\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Currently, you pass the <code>level</code> prop to each <code>&lt;Heading&gt;</code> separately:</p> <pre><code>&lt;Section&gt;\n&lt;Heading level={3}&gt;About&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Photos&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Videos&lt;/Heading&gt;\n&lt;/Section&gt;\n</code></pre> <p>It would be nice if you could pass the <code>level</code> prop to the <code>&lt;Section&gt;</code> component instead and remove it from the <code>&lt;Heading&gt;</code>. This way you could enforce that all headings in the same section have the same size:</p> <pre><code>&lt;Section level={3}&gt;\n&lt;Heading&gt;About&lt;/Heading&gt;\n&lt;Heading&gt;Photos&lt;/Heading&gt;\n&lt;Heading&gt;Videos&lt;/Heading&gt;\n&lt;/Section&gt;\n</code></pre> <p>But how can the <code>&lt;Heading&gt;</code> component know the level of its closest <code>&lt;Section&gt;</code>? That would require some way for a child to \"ask\" for data from somewhere above in the tree.</p> <p>You can't do it with props alone. This is where context comes into play. You will do it in three steps:</p> <ol> <li>Create a context. (You can call it <code>LevelContext</code>, since it's for the heading level.)</li> <li>Use that context from the component that needs the data. (<code>Heading</code> will use <code>LevelContext</code>.)</li> <li>Provide that context from the component that specifies the data. (<code>Section</code> will provide <code>LevelContext</code>.)</li> </ol> <p>Context lets a parent--even a distant one!--provide some data to the entire tree inside of it.</p>"},{"location":"learn/passing-data-deeply-with-context/#step-1-create-the-context","title":"Step 1: Create the context","text":"<p>First, you need to create the context. You'll need to export it from a file so that your components can use it:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section&gt;\n&lt;Heading level={1}&gt;Title&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Heading level={2}&gt;Heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading level={3}&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>export default function Section({ children }) {\nreturn &lt;section className=\"section\"&gt;{children}&lt;/section&gt;;\n}\n</code></pre> <pre><code>export default function Heading({ level, children }) {\nswitch (level) {\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(1);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>The only argument to <code>createContext</code> is the default value. Here, <code>1</code> refers to the biggest heading level, but you could pass any kind of value (even an object). You will see the significance of the default value in the next step.</p>"},{"location":"learn/passing-data-deeply-with-context/#step-2-use-the-context","title":"Step 2: Use the context","text":"<p>Import the <code>useContext</code> Hook from React and your context:</p> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n</code></pre> <p>Currently, the <code>Heading</code> component reads <code>level</code> from props:</p> <pre><code>export default function Heading({ level, children }) {\n// ...\n}\n</code></pre> <p>Instead, remove the <code>level</code> prop and read the value from the context you just imported, <code>LevelContext</code>:</p> <pre><code>export default function Heading({ children }) {\nconst level = useContext(LevelContext);\n// ...\n}\n</code></pre> <p><code>useContext</code> is a Hook. Just like <code>useState</code> and <code>useReducer</code>, you can only call a Hook immediately inside a React component (not inside loops or conditions). <code>useContext</code> tells React that the <code>Heading</code> component wants to read the <code>LevelContext</code>.</p> <p>Now that the <code>Heading</code> component doesn't have a <code>level</code> prop, you don't need to pass the level prop to <code>Heading</code> in your JSX like this anymore:</p> <pre><code>&lt;Section&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading level={4}&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n</code></pre> <p>Update the JSX so that it's the <code>Section</code> that receives it instead:</p> <pre><code>&lt;Section level={4}&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n</code></pre> <p>As a reminder, this is the markup that you were trying to get working:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section level={1}&gt;\n&lt;Heading&gt;Title&lt;/Heading&gt;\n&lt;Section level={2}&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Section level={3}&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section level={4}&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>export default function Section({ children }) {\nreturn &lt;section className=\"section\"&gt;{children}&lt;/section&gt;;\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Heading({ children }) {\nconst level = useContext(LevelContext);\nswitch (level) {\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(1);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Notice this example doesn't quite work, yet! All the headings have the same size because even though you're using the context, you have not provided it yet. React doesn't know where to get it!</p> <p>If you don't provide the context, React will use the default value you've specified in the previous step. In this example, you specified <code>1</code> as the argument to <code>createContext</code>, so <code>useContext(LevelContext)</code> returns <code>1</code>, setting all those headings to <code>&lt;h1&gt;</code>. Let's fix this problem by having each <code>Section</code> provide its own context.</p>"},{"location":"learn/passing-data-deeply-with-context/#step-3-provide-the-context","title":"Step 3: Provide the context","text":"<p>The <code>Section</code> component currently renders its children:</p> <pre><code>export default function Section({ children }) {\nreturn &lt;section className=\"section\"&gt;{children}&lt;/section&gt;;\n}\n</code></pre> <p>Wrap them with a context provider to provide the <code>LevelContext</code> to them:</p> <pre><code>import { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ level, children }) {\nreturn (\n&lt;section className=\"section\"&gt;\n&lt;LevelContext.Provider value={level}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>This tells React: \"if any component inside this <code>&lt;Section&gt;</code> asks for <code>LevelContext</code>, give them this <code>level</code>.\" The component will use the value of the nearest <code>&lt;LevelContext.Provider&gt;</code> in the UI tree above it.</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section level={1}&gt;\n&lt;Heading&gt;Title&lt;/Heading&gt;\n&lt;Section level={2}&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Section level={3}&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section level={4}&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>import { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ level, children }) {\nreturn (\n&lt;section className=\"section\"&gt;\n&lt;LevelContext.Provider value={level}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Heading({ children }) {\nconst level = useContext(LevelContext);\nswitch (level) {\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(1);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>It's the same result as the original code, but you did not need to pass the <code>level</code> prop to each <code>Heading</code> component! Instead, it \"figures out\" its heading level by asking the closest <code>Section</code> above:</p> <ol> <li>You pass a <code>level</code> prop to the <code>&lt;Section&gt;</code>.</li> <li><code>Section</code> wraps its children into <code>&lt;LevelContext.Provider value={level}&gt;</code>.</li> <li><code>Heading</code> asks the closest value of <code>LevelContext</code> above with <code>useContext(LevelContext)</code>.</li> </ol>"},{"location":"learn/passing-data-deeply-with-context/#using-and-providing-context-from-the-same-component","title":"Using and providing context from the same component","text":"<p>Currently, you still have to specify each section's <code>level</code> manually:</p> <pre><code>export default function Page() {\nreturn (\n&lt;Section level={1}&gt;\n...\n&lt;Section level={2}&gt;\n...\n&lt;Section level={3}&gt;\n...\n</code></pre> <p>Since context lets you read information from a component above, each <code>Section</code> could read the <code>level</code> from the <code>Section</code> above, and pass <code>level + 1</code> down automatically. Here is how you could do it:</p> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ children }) {\nconst level = useContext(LevelContext);\nreturn (\n&lt;section className=\"section\"&gt;\n&lt;LevelContext.Provider value={level + 1}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <p>With this change, you don't need to pass the <code>level</code> prop either to the <code>&lt;Section&gt;</code> or to the <code>&lt;Heading&gt;</code>:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section&gt;\n&lt;Heading&gt;Title&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ children }) {\nconst level = useContext(LevelContext);\nreturn (\n&lt;section className=\"section\"&gt;\n&lt;LevelContext.Provider value={level + 1}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Heading({ children }) {\nconst level = useContext(LevelContext);\nswitch (level) {\ncase 0:\nthrow Error(\"Heading must be inside a Section!\");\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(0);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Now both <code>Heading</code> and <code>Section</code> read the <code>LevelContext</code> to figure out how \"deep\" they are. And the <code>Section</code> wraps its children into the <code>LevelContext</code> to specify that anything inside of it is at a \"deeper\" level.</p> <p> <p>This example uses heading levels because they show visually how nested components can override context. But context is useful for many other use cases too. You can pass down any information needed by the entire subtree: the current color theme, the currently logged in user, and so on.</p> <p></p>"},{"location":"learn/passing-data-deeply-with-context/#context-passes-through-intermediate-components","title":"Context passes through intermediate components","text":"<p>You can insert as many components as you like between the component that provides context and the one that uses it. This includes both built-in components like <code>&lt;div&gt;</code> and components you might build yourself.</p> <p>In this example, the same <code>Post</code> component (with a dashed border) is rendered at two different nesting levels. Notice that the <code>&lt;Heading&gt;</code> inside of it gets its level automatically from the closest <code>&lt;Section&gt;</code>:</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function ProfilePage() {\nreturn (\n&lt;Section&gt;\n&lt;Heading&gt;My Profile&lt;/Heading&gt;\n&lt;Post title=\"Hello traveller!\" body=\"Read about my adventures.\" /&gt;\n&lt;AllPosts /&gt;\n&lt;/Section&gt;\n);\n}\n\nfunction AllPosts() {\nreturn (\n&lt;Section&gt;\n&lt;Heading&gt;Posts&lt;/Heading&gt;\n&lt;RecentPosts /&gt;\n&lt;/Section&gt;\n);\n}\n\nfunction RecentPosts() {\nreturn (\n&lt;Section&gt;\n&lt;Heading&gt;Recent Posts&lt;/Heading&gt;\n&lt;Post title=\"Flavors of Lisbon\" body=\"...those past\u00e9is de nata!\" /&gt;\n&lt;Post\ntitle=\"Buenos Aires in the rhythm of tango\"\nbody=\"I loved it!\"\n/&gt;\n&lt;/Section&gt;\n);\n}\n\nfunction Post({ title, body }) {\nreturn (\n&lt;Section isFancy={true}&gt;\n&lt;Heading&gt;{title}&lt;/Heading&gt;\n&lt;p&gt;\n&lt;i&gt;{body}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ children, isFancy }) {\nconst level = useContext(LevelContext);\nreturn (\n&lt;section className={\"section \" + (isFancy ? \"fancy\" : \"\")}&gt;\n&lt;LevelContext.Provider value={level + 1}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Heading({ children }) {\nconst level = useContext(LevelContext);\nswitch (level) {\ncase 0:\nthrow Error(\"Heading must be inside a Section!\");\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(0);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n\n.fancy {\nborder: 4px dashed pink;\n}\n</code></pre> <p>You didn't do anything special for this to work. A <code>Section</code> specifies the context for the tree inside it, so you can insert a <code>&lt;Heading&gt;</code> anywhere, and it will have the correct size. Try it in the sandbox above!</p> <p>Context lets you write components that \"adapt to their surroundings\" and display themselves differently depending on where (or, in other words, in which context) they are being rendered.</p> <p>How context works might remind you of CSS property inheritance. In CSS, you can specify <code>color: blue</code> for a <code>&lt;div&gt;</code>, and any DOM node inside of it, no matter how deep, will inherit that color unless some other DOM node in the middle overrides it with <code>color: green</code>. Similarly, in React, the only way to override some context coming from above is to wrap children into a context provider with a different value.</p> <p>In CSS, different properties like <code>color</code> and <code>background-color</code> don't override each other. You can set all <code>&lt;div&gt;</code>'s <code>color</code> to red without impacting <code>background-color</code>. Similarly, different React contexts don't override each other. Each context that you make with <code>createContext()</code> is completely separate from other ones, and ties together components using and providing that particular context. One component may use or provide many different contexts without a problem.</p>"},{"location":"learn/passing-data-deeply-with-context/#before-you-use-context","title":"Before you use context","text":"<p>Context is very tempting to use! However, this also means it's too easy to overuse it. Just because you need to pass some props several levels deep doesn't mean you should put that information into context.</p> <p>Here's a few alternatives you should consider before using context:</p> <ol> <li>Start by passing props. If your components are not trivial, it's not unusual to pass a dozen props down through a dozen components. It may feel like a slog, but it makes it very clear which components use which data! The person maintaining your code will be glad you've made the data flow explicit with props.</li> <li>Extract components and pass JSX as <code>children</code> to them. If you pass some data through many layers of intermediate components that don't use that data (and only pass it further down), this often means that you forgot to extract some components along the way. For example, maybe you pass data props like <code>posts</code> to visual components that don't use them directly, like <code>&lt;Layout posts={posts} /&gt;</code>. Instead, make <code>Layout</code> take <code>children</code> as a prop, and render <code>&lt;Layout&gt;&lt;Posts posts={posts} /&gt;&lt;/Layout&gt;</code>. This reduces the number of layers between the component specifying the data and the one that needs it.</li> </ol> <p>If neither of these approaches works well for you, consider context.</p>"},{"location":"learn/passing-data-deeply-with-context/#use-cases-for-context","title":"Use cases for context","text":"<ul> <li>Theming: If your app lets the user change its appearance (e.g. dark mode), you can put a context provider at the top of your app, and use that context in components that need to adjust their visual look.</li> <li>Current account: Many components might need to know the currently logged in user. Putting it in context makes it convenient to read it anywhere in the tree. Some apps also let you operate multiple accounts at the same time (e.g. to leave a comment as a different user). In those cases, it can be convenient to wrap a part of the UI into a nested provider with a different current account value.</li> <li>Routing: Most routing solutions use context internally to hold the current route. This is how every link \"knows\" whether it's active or not. If you build your own router, you might want to do it too.</li> <li>Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.</li> </ul> <p>Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state.</p> <p>In general, if some information is needed by distant components in different parts of the tree, it's a good indication that context will help you.</p> <p> <ul> <li>Context lets a component provide some information to the entire tree below it.</li> <li>To pass context:<ol> <li>Create and export it with <code>export const MyContext = createContext(defaultValue)</code>.</li> <li>Pass it to the <code>useContext(MyContext)</code> Hook to read it in any child component, no matter how deep.</li> <li>Wrap children into <code>&lt;MyContext.Provider value={...}&gt;</code> to provide it from a parent.</li> </ol> </li> <li>Context passes through any components in the middle.</li> <li>Context lets you write components that \"adapt to their surroundings\".</li> <li>Before you use context, try passing props or passing JSX as <code>children</code>.</li> </ul> <p></p> <p>"},{"location":"learn/passing-data-deeply-with-context/#replace-prop-drilling-with-context","title":"Replace prop drilling with context","text":"<p>In this example, toggling the checkbox changes the <code>imageSize</code> prop passed to each <code>&lt;PlaceImage&gt;</code>. The checkbox state is held in the top-level <code>App</code> component, but each <code>&lt;PlaceImage&gt;</code> needs to be aware of it.</p> <p>Currently, <code>App</code> passes <code>imageSize</code> to <code>List</code>, which passes it to each <code>Place</code>, which passes it to the <code>PlaceImage</code>. Remove the <code>imageSize</code> prop, and instead pass it from the <code>App</code> component directly to <code>PlaceImage</code>.</p> <p>You can declare context in <code>Context.js</code>.</p> <pre><code>import { useState } from \"react\";\nimport { places } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function App() {\nconst [isLarge, setIsLarge] = useState(false);\nconst imageSize = isLarge ? 150 : 100;\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isLarge}\nonChange={(e) =&gt; {\nsetIsLarge(e.target.checked);\n}}\n/&gt;\nUse large images\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;List imageSize={imageSize} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction List({ imageSize }) {\nconst listItems = places.map((place) =&gt; (\n&lt;li key={place.id}&gt;\n&lt;Place place={place} imageSize={imageSize} /&gt;\n&lt;/li&gt;\n));\nreturn &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nfunction Place({ place, imageSize }) {\nreturn (\n&lt;&gt;\n&lt;PlaceImage place={place} imageSize={imageSize} /&gt;\n&lt;p&gt;\n&lt;b&gt;{place.name}&lt;/b&gt;\n{\": \" + place.description}\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n\nfunction PlaceImage({ place, imageSize }) {\nreturn (\n&lt;img\nsrc={getImageUrl(place)}\nalt={place.name}\nwidth={imageSize}\nheight={imageSize}\n/&gt;\n);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>export const places = [\n{\nid: 0,\nname: \"Bo-Kaap in Cape Town, South Africa\",\ndescription:\n\"The tradition of choosing bright colors for houses began in the late 20th century.\",\nimageId: \"K9HVAGH\",\n},\n{\nid: 1,\nname: \"Rainbow Village in Taichung, Taiwan\",\ndescription:\n\"To save the houses from demolition, Huang Yung-Fu, a local resident, painted all 1,200 of them in 1924.\",\nimageId: \"9EAYZrt\",\n},\n{\nid: 2,\nname: \"Macromural de Pachuca, Mexico\",\ndescription:\n\"One of the largest murals in the world covering homes in a hillside neighborhood.\",\nimageId: \"DgXHVwu\",\n},\n{\nid: 3,\nname: \"Selar\u00f3n Staircase in Rio de Janeiro, Brazil\",\ndescription:\n'This landmark was created by Jorge Selar\u00f3n, a Chilean-born artist, as a \"tribute to the Brazilian people.\"',\nimageId: \"aeO3rpI\",\n},\n{\nid: 4,\nname: \"Burano, Italy\",\ndescription:\n\"The houses are painted following a specific color system dating back to 16th century.\",\nimageId: \"kxsph5C\",\n},\n{\nid: 5,\nname: \"Chefchaouen, Marocco\",\ndescription:\n\"There are a few theories on why the houses are painted blue, including that the color repells mosquitos or that it symbolizes sky and heaven.\",\nimageId: \"rTqKo46\",\n},\n{\nid: 6,\nname: \"Gamcheon Culture Village in Busan, South Korea\",\ndescription:\n\"In 2009, the village was converted into a cultural hub by painting the houses and featuring exhibitions and art installations.\",\nimageId: \"ZfQOOzf\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(place) {\nreturn \"https://i.imgur.com/\" + place.imageId + \"l.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\n</code></pre> <p> <p>Remove <code>imageSize</code> prop from all the components.</p> <p>Create and export <code>ImageSizeContext</code> from <code>Context.js</code>. Then wrap the List into <code>&lt;ImageSizeContext.Provider value={imageSize}&gt;</code> to pass the value down, and <code>useContext(ImageSizeContext)</code> to read it in the <code>PlaceImage</code>:</p> <pre><code>import { useState, useContext } from \"react\";\nimport { places } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\nimport { ImageSizeContext } from \"./Context.js\";\n\nexport default function App() {\nconst [isLarge, setIsLarge] = useState(false);\nconst imageSize = isLarge ? 150 : 100;\nreturn (\n&lt;ImageSizeContext.Provider value={imageSize}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isLarge}\nonChange={(e) =&gt; {\nsetIsLarge(e.target.checked);\n}}\n/&gt;\nUse large images\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;List /&gt;\n&lt;/ImageSizeContext.Provider&gt;\n);\n}\n\nfunction List() {\nconst listItems = places.map((place) =&gt; (\n&lt;li key={place.id}&gt;\n&lt;Place place={place} /&gt;\n&lt;/li&gt;\n));\nreturn &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nfunction Place({ place }) {\nreturn (\n&lt;&gt;\n&lt;PlaceImage place={place} /&gt;\n&lt;p&gt;\n&lt;b&gt;{place.name}&lt;/b&gt;\n{\": \" + place.description}\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n\nfunction PlaceImage({ place }) {\nconst imageSize = useContext(ImageSizeContext);\nreturn (\n&lt;img\nsrc={getImageUrl(place)}\nalt={place.name}\nwidth={imageSize}\nheight={imageSize}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const ImageSizeContext = createContext(500);\n</code></pre> <pre><code>export const places = [\n{\nid: 0,\nname: \"Bo-Kaap in Cape Town, South Africa\",\ndescription:\n\"The tradition of choosing bright colors for houses began in the late 20th century.\",\nimageId: \"K9HVAGH\",\n},\n{\nid: 1,\nname: \"Rainbow Village in Taichung, Taiwan\",\ndescription:\n\"To save the houses from demolition, Huang Yung-Fu, a local resident, painted all 1,200 of them in 1924.\",\nimageId: \"9EAYZrt\",\n},\n{\nid: 2,\nname: \"Macromural de Pachuca, Mexico\",\ndescription:\n\"One of the largest murals in the world covering homes in a hillside neighborhood.\",\nimageId: \"DgXHVwu\",\n},\n{\nid: 3,\nname: \"Selar\u00f3n Staircase in Rio de Janeiro, Brazil\",\ndescription:\n'This landmark was created by Jorge Selar\u00f3n, a Chilean-born artist, as a \"tribute to the Brazilian people\".',\nimageId: \"aeO3rpI\",\n},\n{\nid: 4,\nname: \"Burano, Italy\",\ndescription:\n\"The houses are painted following a specific color system dating back to 16th century.\",\nimageId: \"kxsph5C\",\n},\n{\nid: 5,\nname: \"Chefchaouen, Marocco\",\ndescription:\n\"There are a few theories on why the houses are painted blue, including that the color repells mosquitos or that it symbolizes sky and heaven.\",\nimageId: \"rTqKo46\",\n},\n{\nid: 6,\nname: \"Gamcheon Culture Village in Busan, South Korea\",\ndescription:\n\"In 2009, the village was converted into a cultural hub by painting the houses and featuring exhibitions and art installations.\",\nimageId: \"ZfQOOzf\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(place) {\nreturn \"https://i.imgur.com/\" + place.imageId + \"l.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\n</code></pre> <p>Note how components in the middle don't need to pass <code>imageSize</code> anymore.</p> <p></p> <p></p>"},{"location":"learn/passing-props-to-a-component/","title":"Passing Props to a Component \ud83d\udea7","text":""},{"location":"learn/passing-props-to-a-component/#overview","title":"Overview","text":"<p>  React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.  </p> <p>You will learn</p> <ul> <li>How to pass props to a component</li> <li>How to read props from a component</li> <li>How to specify default values for props</li> <li>How to pass some JSX to a component</li> <li>How props change over time</li> </ul>"},{"location":"learn/passing-props-to-a-component/#familiar-props","title":"Familiar props","text":"<p>Props are the information that you pass to a JSX tag. For example, <code>className</code>, <code>src</code>, <code>alt</code>, <code>width</code>, and <code>height</code> are some of the props you can pass to an <code>&lt;img&gt;</code>:</p> <pre><code>function Avatar() {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc=\"https://i.imgur.com/1bX5QH6.jpg\"\nalt=\"Lin Lanying\"\nwidth={100}\nheight={100}\n/&gt;\n);\n}\n\nexport default function Profile() {\nreturn &lt;Avatar /&gt;;\n}\n</code></pre> <pre><code>body {\nmin-height: 120px;\n}\n.avatar {\nmargin: 20px;\nborder-radius: 50%;\n}\n</code></pre> <p>The props you can pass to an <code>&lt;img&gt;</code> tag are predefined (ReactDOM conforms to the HTML standard). But you can pass any props to your own components, such as <code>&lt;Avatar&gt;</code>, to customize them. Here's how!</p>"},{"location":"learn/passing-props-to-a-component/#passing-props-to-a-component","title":"Passing props to a component","text":"<p>In this code, the <code>Profile</code> component isn't passing any props to its child component, <code>Avatar</code>:</p> <pre><code>export default function Profile() {\nreturn &lt;Avatar /&gt;;\n}\n</code></pre> <p>You can give <code>Avatar</code> some props in two steps.</p>"},{"location":"learn/passing-props-to-a-component/#step-1-pass-props-to-the-child-component","title":"Step 1: Pass props to the child component","text":"<p>First, pass some props to <code>Avatar</code>. For example, let's pass two props: <code>person</code> (an object), and <code>size</code> (a number):</p> <pre><code>export default function Profile() {\nreturn (\n&lt;Avatar\nperson={{ name: \"Lin Lanying\", imageId: \"1bX5QH6\" }}\nsize={100}\n/&gt;\n);\n}\n</code></pre> <p> <p>If double curly braces after <code>person=</code> confuse you, recall they're merely an object inside the JSX curlies.</p> <p></p> <p>Now you can read these props inside the <code>Avatar</code> component.</p>"},{"location":"learn/passing-props-to-a-component/#step-2-read-props-inside-the-child-component","title":"Step 2: Read props inside the child component","text":"<p>You can read these props by listing their names <code>person, size</code> separated by the commas inside <code>({</code> and <code>})</code> directly after <code>function Avatar</code>. This lets you use them inside the <code>Avatar</code> code, like you would with a variable.</p> <pre><code>function Avatar({ person, size }) {\n// person and size are available here\n}\n</code></pre> <p>Add some logic to <code>Avatar</code> that uses the <code>person</code> and <code>size</code> props for rendering, and you're done.</p> <p>Now you can configure <code>Avatar</code> to render in many different ways with different props. Try tweaking the values!</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nfunction Avatar({ person, size }) {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person)}\nalt={person.name}\nwidth={size}\nheight={size}\n/&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;div&gt;\n&lt;Avatar\nsize={100}\nperson={{\nname: \"Katsuko Saruhashi\",\nimageId: \"YfeOqp2\",\n}}\n/&gt;\n&lt;Avatar\nsize={80}\nperson={{\nname: \"Aklilu Lemma\",\nimageId: \"OKS67lh\",\n}}\n/&gt;\n&lt;Avatar\nsize={50}\nperson={{\nname: \"Lin Lanying\",\nimageId: \"1bX5QH6\",\n}}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size = \"s\") {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>body {\nmin-height: 120px;\n}\n.avatar {\nmargin: 10px;\nborder-radius: 50%;\n}\n</code></pre> <p>Props let you think about parent and child components independently. For example, you can change the <code>person</code> or the <code>size</code> props inside <code>Profile</code> without having to think about how <code>Avatar</code> uses them. Similarly, you can change how the <code>Avatar</code> uses these props, without looking at the <code>Profile</code>.</p> <p>You can think of props like \"knobs\" that you can adjust. They serve the same role as arguments serve for functions\u2014in fact, props are the only argument to your component! React component functions accept a single argument, a <code>props</code> object:</p> <pre><code>function Avatar(props) {\nlet person = props.person;\nlet size = props.size;\n// ...\n}\n</code></pre> <p>Usually you don't need the whole <code>props</code> object itself, so you destructure it into individual props.</p> <p> <p>Don't miss the pair of <code>{</code> and <code>}</code> curlies inside of <code>(</code> and <code>)</code> when declaring props:</p> <pre><code>function Avatar({ person, size }) {\n// ...\n}\n</code></pre> <p>This syntax is called \"destructuring\" and is equivalent to reading properties from a function parameter:</p> <pre><code>function Avatar(props) {\nlet person = props.person;\nlet size = props.size;\n// ...\n}\n</code></pre> <p></p>"},{"location":"learn/passing-props-to-a-component/#specifying-a-default-value-for-a-prop","title":"Specifying a default value for a prop","text":"<p>If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting <code>=</code> and the default value right after the parameter:</p> <pre><code>function Avatar({ person, size = 100 }) {\n// ...\n}\n</code></pre> <p>Now, if <code>&lt;Avatar person={...} /&gt;</code> is rendered with no <code>size</code> prop, the <code>size</code> will be set to <code>100</code>.</p> <p>The default value is only used if the <code>size</code> prop is missing or if you pass <code>size={undefined}</code>. But if you pass <code>size={null}</code> or <code>size={0}</code>, the default value will not be used.</p>"},{"location":"learn/passing-props-to-a-component/#forwarding-props-with-the-jsx-spread-syntax","title":"Forwarding props with the JSX spread syntax","text":"<p>Sometimes, passing props gets very repetitive:</p> <pre><code>function Profile({ person, size, isSepia, thickBorder }) {\nreturn (\n&lt;div className=\"card\"&gt;\n&lt;Avatar\nperson={person}\nsize={size}\nisSepia={isSepia}\nthickBorder={thickBorder}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>There's nothing wrong with repetitive code\u2014it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how this <code>Profile</code> does with <code>Avatar</code>. Because they don't use any of their props directly, it can make sense to use a more concise \"spread\" syntax:</p> <pre><code>function Profile(props) {\nreturn (\n&lt;div className=\"card\"&gt;\n&lt;Avatar {...props} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>This forwards all of <code>Profile</code>'s props to the <code>Avatar</code> without listing each of their names.</p> <p>Use spread syntax with restraint. If you're using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!</p>"},{"location":"learn/passing-props-to-a-component/#passing-jsx-as-children","title":"Passing JSX as children","text":"<p>It is common to nest built-in browser tags:</p> <pre><code>&lt;div&gt;\n&lt;img /&gt;\n&lt;/div&gt;\n</code></pre> <p>Sometimes you'll want to nest your own components the same way:</p> <pre><code>&lt;Card&gt;\n&lt;Avatar /&gt;\n&lt;/Card&gt;\n</code></pre> <p>When you nest content inside a JSX tag, the parent component will receive that content in a prop called <code>children</code>. For example, the <code>Card</code> component below will receive a <code>children</code> prop set to <code>&lt;Avatar /&gt;</code> and render it in a wrapper div:</p> <pre><code>import Avatar from \"./Avatar.js\";\n\nfunction Card({ children }) {\nreturn &lt;div className=\"card\"&gt;{children}&lt;/div&gt;;\n}\n\nexport default function Profile() {\nreturn (\n&lt;Card&gt;\n&lt;Avatar\nsize={100}\nperson={{\nname: \"Katsuko Saruhashi\",\nimageId: \"YfeOqp2\",\n}}\n/&gt;\n&lt;/Card&gt;\n);\n}\n</code></pre> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nexport default function Avatar({ person, size }) {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person)}\nalt={person.name}\nwidth={size}\nheight={size}\n/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size = \"s\") {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.card {\nwidth: fit-content;\nmargin: 5px;\npadding: 5px;\nfont-size: 20px;\ntext-align: center;\nborder: 1px solid #aaa;\nborder-radius: 20px;\nbackground: #fff;\n}\n.avatar {\nmargin: 20px;\nborder-radius: 50%;\n}\n</code></pre> <p>Try replacing the <code>&lt;Avatar&gt;</code> inside <code>&lt;Card&gt;</code> with some text to see how the <code>Card</code> component can wrap any nested content. It doesn't need to \"know\" what's being rendered inside of it. You will see this flexible pattern in many places.</p> <p>You can think of a component with a <code>children</code> prop as having a \"hole\" that can be \"filled in\" by its parent components with arbitrary JSX. You will often use the <code>children</code> prop for visual wrappers: panels, grids, etc.</p> <p></p>"},{"location":"learn/passing-props-to-a-component/#how-props-change-over-time","title":"How props change over time","text":"<p>The <code>Clock</code> component below receives two props from its parent component: <code>color</code> and <code>time</code>. (The parent component's code is omitted because it uses state, which we won't dive into just yet.)</p> <p>Try changing the color in the select box below:</p> <pre><code>export default function Clock({ color, time }) {\nreturn &lt;h1 style={{ color: color }}&gt;{time}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nconst [color, setColor] = useState(\"lightcoral\");\nreturn (\n&lt;div&gt;\n&lt;p&gt;\nPick a color:{\" \"}\n&lt;select\nvalue={color}\nonChange={(e) =&gt; setColor(e.target.value)}\n&gt;\n&lt;option value=\"lightcoral\"&gt;lightcoral&lt;/option&gt;\n&lt;option value=\"midnightblue\"&gt;midnightblue&lt;/option&gt;\n&lt;option value=\"rebeccapurple\"&gt;rebeccapurple&lt;/option&gt;\n&lt;/select&gt;\n&lt;/p&gt;\n&lt;Clock color={color} time={time.toLocaleTimeString()} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>This example illustrates that a component may receive different props over time. Props are not always static! Here, the <code>time</code> prop changes every second, and the <code>color</code> prop changes when you select another color. Props reflect a component's data at any point in time, rather than only in the beginning.</p> <p>However, props are immutable\u2014a term from computer science meaning \"unchangeable\". When a component needs to change its props (for example, in response to a user interaction or new data), it will have to \"ask\" its parent component to pass it different props\u2014a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.</p> <p>Don't try to \"change props\". When you need to respond to the user input (like changing the selected color), you will need to \"set state\", which you can learn about in State: A Component's Memory.</p> <p> <ul> <li>To pass props, add them to the JSX, just like you would with HTML attributes.</li> <li>To read props, use the <code>function Avatar({ person, size })</code> destructuring syntax.</li> <li>You can specify a default value like <code>size = 100</code>, which is used for missing and <code>undefined</code> props.</li> <li>You can forward all props with <code>&lt;Avatar {...props} /&gt;</code> JSX spread syntax, but don't overuse it!</li> <li>Nested JSX like <code>&lt;Card&gt;&lt;Avatar /&gt;&lt;/Card&gt;</code> will appear as <code>Card</code> component's <code>children</code> prop.</li> <li>Props are read-only snapshots in time: every render receives a new version of props.</li> <li>You can't change props. When you need interactivity, you'll need to set state.</li> </ul> <p></p> <p>"},{"location":"learn/passing-props-to-a-component/#extract-a-component","title":"Extract a component","text":"<p>This <code>Gallery</code> component contains some very similar markup for two profiles. Extract a <code>Profile</code> component out of it to reduce the duplication. You'll need to choose what props to pass to it.</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nexport default function Gallery() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Notable Scientists&lt;/h1&gt;\n&lt;section className=\"profile\"&gt;\n&lt;h2&gt;Maria Sk\u0142odowska-Curie&lt;/h2&gt;\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(\"szV5sdG\")}\nalt=\"Maria Sk\u0142odowska-Curie\"\nwidth={70}\nheight={70}\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;b&gt;Profession: &lt;/b&gt;\nphysicist and chemist\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Awards: 4 &lt;/b&gt;\n(Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal,\nMatteucci Medal)\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Discovered: &lt;/b&gt;\npolonium (element)\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n&lt;section className=\"profile\"&gt;\n&lt;h2&gt;Katsuko Saruhashi&lt;/h2&gt;\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(\"YfeOqp2\")}\nalt=\"Katsuko Saruhashi\"\nwidth={70}\nheight={70}\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;b&gt;Profession: &lt;/b&gt;\ngeochemist\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Awards: 2 &lt;/b&gt;\n(Miyake Prize for geochemistry, Tanaka Prize)\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Discovered: &lt;/b&gt;a method for measuring carbon dioxide\nin seawater\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(imageId, size = \"s\") {\nreturn \"https://i.imgur.com/\" + imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 5px;\nborder-radius: 50%;\nmin-height: 70px;\n}\n.profile {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nmargin-top: 20px;\npadding: 10px;\n}\nh1,\nh2 {\nmargin: 5px;\n}\nh1 {\nmargin-bottom: 10px;\n}\nul {\npadding: 0px 10px 0px 20px;\n}\nli {\nmargin: 5px;\n}\n</code></pre> <p> <p>Start by extracting the markup for one of the scientists. Then find the pieces that don't match it in the second example, and make them configurable by props.</p> <p></p> <p> <p>In this solution, the <code>Profile</code> component accepts multiple props: <code>imageId</code> (a string), <code>name</code> (a string), <code>profession</code> (a string), <code>awards</code> (an array of strings), <code>discovery</code> (a string), and <code>imageSize</code> (a number).</p> <p>Note that the <code>imageSize</code> prop has a default value, which is why we don't pass it to the component.</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nfunction Profile({\nimageId,\nname,\nprofession,\nawards,\ndiscovery,\nimageSize = 70,\n}) {\nreturn (\n&lt;section className=\"profile\"&gt;\n&lt;h2&gt;{name}&lt;/h2&gt;\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(imageId)}\nalt={name}\nwidth={imageSize}\nheight={imageSize}\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;b&gt;Profession:&lt;/b&gt; {profession}\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Awards: {awards.length} &lt;/b&gt;({awards.join(\", \")})\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Discovered: &lt;/b&gt;\n{discovery}\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n\nexport default function Gallery() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Notable Scientists&lt;/h1&gt;\n&lt;Profile\nimageId=\"szV5sdG\"\nname=\"Maria Sk\u0142odowska-Curie\"\nprofession=\"physicist and chemist\"\ndiscovery=\"polonium (chemical element)\"\nawards={[\n\"Nobel Prize in Physics\",\n\"Nobel Prize in Chemistry\",\n\"Davy Medal\",\n\"Matteucci Medal\",\n]}\n/&gt;\n&lt;Profile\nimageId=\"YfeOqp2\"\nname=\"Katsuko Saruhashi\"\nprofession=\"geochemist\"\ndiscovery=\"a method for measuring carbon dioxide in seawater\"\nawards={[\"Miyake Prize for geochemistry\", \"Tanaka Prize\"]}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(imageId, size = \"s\") {\nreturn \"https://i.imgur.com/\" + imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 5px;\nborder-radius: 50%;\nmin-height: 70px;\n}\n.profile {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nmargin-top: 20px;\npadding: 10px;\n}\nh1,\nh2 {\nmargin: 5px;\n}\nh1 {\nmargin-bottom: 10px;\n}\nul {\npadding: 0px 10px 0px 20px;\n}\nli {\nmargin: 5px;\n}\n</code></pre> <p>Note how you don't need a separate <code>awardCount</code> prop if <code>awards</code> is an array. Then you can use <code>awards.length</code> to count the number of awards. Remember that props can take any values, and that includes arrays too!</p> <p>Another solution, which is more similar to the earlier examples on this page, is to group all information about a person in a single object, and pass that object as one prop:</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nfunction Profile({ person, imageSize = 70 }) {\nconst imageSrc = getImageUrl(person);\n\nreturn (\n&lt;section className=\"profile\"&gt;\n&lt;h2&gt;{person.name}&lt;/h2&gt;\n&lt;img\nclassName=\"avatar\"\nsrc={imageSrc}\nalt={person.name}\nwidth={imageSize}\nheight={imageSize}\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;b&gt;Profession:&lt;/b&gt; {person.profession}\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Awards: {person.awards.length} &lt;/b&gt;(\n{person.awards.join(\", \")})\n&lt;/li&gt;\n&lt;li&gt;\n&lt;b&gt;Discovered: &lt;/b&gt;\n{person.discovery}\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n\nexport default function Gallery() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Notable Scientists&lt;/h1&gt;\n&lt;Profile\nperson={{\nimageId: \"szV5sdG\",\nname: \"Maria Sk\u0142odowska-Curie\",\nprofession: \"physicist and chemist\",\ndiscovery: \"polonium (chemical element)\",\nawards: [\n\"Nobel Prize in Physics\",\n\"Nobel Prize in Chemistry\",\n\"Davy Medal\",\n\"Matteucci Medal\",\n],\n}}\n/&gt;\n&lt;Profile\nperson={{\nimageId: \"YfeOqp2\",\nname: \"Katsuko Saruhashi\",\nprofession: \"geochemist\",\ndiscovery:\n\"a method for measuring carbon dioxide in seawater\",\nawards: [\"Miyake Prize for geochemistry\", \"Tanaka Prize\"],\n}}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size = \"s\") {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 5px;\nborder-radius: 50%;\nmin-height: 70px;\n}\n.profile {\nborder: 1px solid #aaa;\nborder-radius: 6px;\nmargin-top: 20px;\npadding: 10px;\n}\nh1,\nh2 {\nmargin: 5px;\n}\nh1 {\nmargin-bottom: 10px;\n}\nul {\npadding: 0px 10px 0px 20px;\n}\nli {\nmargin: 5px;\n}\n</code></pre> <p>Although the syntax looks slightly different because you're describing properties of a JavaScript object rather than a collection of JSX attributes, these examples are mostly equivalent, and you can pick either approach.</p> <p></p>"},{"location":"learn/passing-props-to-a-component/#adjust-the-image-size-based-on-a-prop","title":"Adjust the image size based on a prop","text":"<p>In this example, <code>Avatar</code> receives a numeric <code>size</code> prop which determines the <code>&lt;img&gt;</code> width and height. The <code>size</code> prop is set to <code>40</code> in this example. However, if you open the image in a new tab, you'll notice that the image itself is larger (<code>160</code> pixels). The real image size is determined by which thumbnail size you're requesting.</p> <p>Change the <code>Avatar</code> component to request the closest image size based on the <code>size</code> prop. Specifically, if the <code>size</code> is less than <code>90</code>, pass <code>'s'</code> (\"small\") rather than <code>'b'</code> (\"big\") to the <code>getImageUrl</code> function. Verify that your changes work by rendering avatars with different values of the <code>size</code> prop and opening images in a new tab.</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nfunction Avatar({ person, size }) {\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person, \"b\")}\nalt={person.name}\nwidth={size}\nheight={size}\n/&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;Avatar\nsize={40}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size) {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 20px;\nborder-radius: 50%;\n}\n</code></pre> <p> <p>Here is how you could go about it:</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nfunction Avatar({ person, size }) {\nlet thumbnailSize = \"s\";\nif (size &gt; 90) {\nthumbnailSize = \"b\";\n}\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person, thumbnailSize)}\nalt={person.name}\nwidth={size}\nheight={size}\n/&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;&gt;\n&lt;Avatar\nsize={40}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n&lt;Avatar\nsize={120}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size) {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 20px;\nborder-radius: 50%;\n}\n</code></pre> <p>You could also show a sharper image for high DPI screens by taking <code>window.devicePixelRatio</code> into account:</p> <pre><code>import { getImageUrl } from \"./utils.js\";\n\nconst ratio = window.devicePixelRatio;\n\nfunction Avatar({ person, size }) {\nlet thumbnailSize = \"s\";\nif (size * ratio &gt; 90) {\nthumbnailSize = \"b\";\n}\nreturn (\n&lt;img\nclassName=\"avatar\"\nsrc={getImageUrl(person, thumbnailSize)}\nalt={person.name}\nwidth={size}\nheight={size}\n/&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;&gt;\n&lt;Avatar\nsize={40}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n&lt;Avatar\nsize={70}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n&lt;Avatar\nsize={120}\nperson={{\nname: \"Gregorio Y. Zara\",\nimageId: \"7vQD0fP\",\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function getImageUrl(person, size) {\nreturn \"https://i.imgur.com/\" + person.imageId + size + \".jpg\";\n}\n</code></pre> <pre><code>.avatar {\nmargin: 20px;\nborder-radius: 50%;\n}\n</code></pre> <p>Props let you encapsulate logic like this inside the <code>Avatar</code> component (and change it later if needed) so that everyone can use the <code>&lt;Avatar&gt;</code> component without thinking about how the images are requested and resized.</p> <p></p>"},{"location":"learn/passing-props-to-a-component/#passing-jsx-in-a-children-prop","title":"Passing JSX in a <code>children</code> prop","text":"<p>Extract a <code>Card</code> component from the markup below, and use the <code>children</code> prop to pass different JSX to it:</p> <pre><code>export default function Profile() {\nreturn (\n&lt;div&gt;\n&lt;div className=\"card\"&gt;\n&lt;div className=\"card-content\"&gt;\n&lt;h1&gt;Photo&lt;/h1&gt;\n&lt;img\nclassName=\"avatar\"\nsrc=\"https://i.imgur.com/OKS67lhm.jpg\"\nalt=\"Aklilu Lemma\"\nwidth={70}\nheight={70}\n/&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div className=\"card\"&gt;\n&lt;div className=\"card-content\"&gt;\n&lt;h1&gt;About&lt;/h1&gt;\n&lt;p&gt;\nAklilu Lemma was a distinguished Ethiopian scientist who\ndiscovered a natural treatment to schistosomiasis.\n&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.card {\nwidth: fit-content;\nmargin: 20px;\npadding: 20px;\nborder: 1px solid #aaa;\nborder-radius: 20px;\nbackground: #fff;\n}\n.card-content {\ntext-align: center;\n}\n.avatar {\nmargin: 10px;\nborder-radius: 50%;\n}\nh1 {\nmargin: 5px;\npadding: 0;\nfont-size: 24px;\n}\n</code></pre> <p> <p>Any JSX you put inside of a component's tag will be passed as the <code>children</code> prop to that component.</p> <p></p> <p> <p>This is how you can use the <code>Card</code> component in both places:</p> <pre><code>function Card({ children }) {\nreturn (\n&lt;div className=\"card\"&gt;\n&lt;div className=\"card-content\"&gt;{children}&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;div&gt;\n&lt;Card&gt;\n&lt;h1&gt;Photo&lt;/h1&gt;\n&lt;img\nclassName=\"avatar\"\nsrc=\"https://i.imgur.com/OKS67lhm.jpg\"\nalt=\"Aklilu Lemma\"\nwidth={100}\nheight={100}\n/&gt;\n&lt;/Card&gt;\n&lt;Card&gt;\n&lt;h1&gt;About&lt;/h1&gt;\n&lt;p&gt;\nAklilu Lemma was a distinguished Ethiopian scientist who\ndiscovered a natural treatment to schistosomiasis.\n&lt;/p&gt;\n&lt;/Card&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.card {\nwidth: fit-content;\nmargin: 20px;\npadding: 20px;\nborder: 1px solid #aaa;\nborder-radius: 20px;\nbackground: #fff;\n}\n.card-content {\ntext-align: center;\n}\n.avatar {\nmargin: 10px;\nborder-radius: 50%;\n}\nh1 {\nmargin: 5px;\npadding: 0;\nfont-size: 24px;\n}\n</code></pre> <p>You can also make <code>title</code> a separate prop if you want every <code>Card</code> to always have a title:</p> <pre><code>function Card({ children, title }) {\nreturn (\n&lt;div className=\"card\"&gt;\n&lt;div className=\"card-content\"&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nexport default function Profile() {\nreturn (\n&lt;div&gt;\n&lt;Card title=\"Photo\"&gt;\n&lt;img\nclassName=\"avatar\"\nsrc=\"https://i.imgur.com/OKS67lhm.jpg\"\nalt=\"Aklilu Lemma\"\nwidth={100}\nheight={100}\n/&gt;\n&lt;/Card&gt;\n&lt;Card title=\"About\"&gt;\n&lt;p&gt;\nAklilu Lemma was a distinguished Ethiopian scientist who\ndiscovered a natural treatment to schistosomiasis.\n&lt;/p&gt;\n&lt;/Card&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.card {\nwidth: fit-content;\nmargin: 20px;\npadding: 20px;\nborder: 1px solid #aaa;\nborder-radius: 20px;\nbackground: #fff;\n}\n.card-content {\ntext-align: center;\n}\n.avatar {\nmargin: 10px;\nborder-radius: 50%;\n}\nh1 {\nmargin: 5px;\npadding: 0;\nfont-size: 24px;\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/preserving-and-resetting-state/","title":"Preserving and Resetting State \ud83d\udea7","text":""},{"location":"learn/preserving-and-resetting-state/#overview","title":"Overview","text":"<p>  State is isolated between components. React keeps track of which state belongs to which component based on their place in the UI tree. You can control when to preserve state and when to reset it between re-renders.  </p> <p>You will learn</p> <ul> <li>How React \"sees\" component structures</li> <li>When React chooses to preserve or reset the state</li> <li>How to force React to reset component's state</li> <li>How keys and types affect whether the state is preserved</li> </ul>"},{"location":"learn/preserving-and-resetting-state/#the-ui-tree","title":"The UI tree","text":"<p>Browsers use many tree structures to model UI. The DOM represents HTML elements, the CSSOM does the same for CSS. There's even an Accessibility tree!</p> <p>React also uses tree structures to manage and model the UI you make. React makes UI trees from your JSX. Then React DOM updates the browser DOM elements to match that UI tree. (React Native translates these trees into elements specific to mobile platforms.)</p>"},{"location":"learn/preserving-and-resetting-state/#state-is-tied-to-a-position-in-the-tree","title":"State is tied to a position in the tree","text":"<p>When you give a component state, you might think the state \"lives\" inside the component. But the state is actually held inside React. React associates each piece of state it's holding with the correct component by where that component sits in the UI tree.</p> <p>Here, there is only one <code>&lt;Counter /&gt;</code> JSX tag, but it's rendered at two different positions:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst counter = &lt;Counter /&gt;;\nreturn (\n&lt;div&gt;\n{counter}\n{counter}\n&lt;/div&gt;\n);\n}\n\nfunction Counter() {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>Here's how these look as a tree:</p> <p>These are two separate counters because each is rendered at its own position in the tree. You don't usually have to think about these positions to use React, but it can be useful to understand how it works.</p> <p>In React, each component on the screen has fully isolated state. For example, if you render two <code>Counter</code> components side by side, each of them will get its own, independent, <code>score</code> and <code>hover</code> states.</p> <p>Try clicking both counters and notice they don't affect each other:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nreturn (\n&lt;div&gt;\n&lt;Counter /&gt;\n&lt;Counter /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter() {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>As you can see, when one counter is updated, only the state for that component is updated:</p> <p>React will keep the state around for as long as you render the same component at the same position. To see this, increment both counters, then remove the second component by unchecking \"Render the second counter\" checkbox, and then add it back by ticking it again:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [showB, setShowB] = useState(true);\nreturn (\n&lt;div&gt;\n&lt;Counter /&gt;\n{showB &amp;&amp; &lt;Counter /&gt;}\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showB}\nonChange={(e) =&gt; {\nsetShowB(e.target.checked);\n}}\n/&gt;\nRender the second counter\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter() {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>Notice how the moment you stop rendering the second counter, its state disappears completely. That's because when React removes a component, it destroys its state.</p> <p>When you tick \"Render the second counter\", a second <code>Counter</code> and its state are initialized from scratch (<code>score = 0</code>) and added to the DOM.</p> <p>React preserves a component's state for as long as it's being rendered at its position in the UI tree. If it gets removed, or a different component gets rendered at the same position, React discards its state.</p>"},{"location":"learn/preserving-and-resetting-state/#same-component-at-the-same-position-preserves-state","title":"Same component at the same position preserves state","text":"<p>In this example, there are two different <code>&lt;Counter /&gt;</code> tags:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [isFancy, setIsFancy] = useState(false);\nreturn (\n&lt;div&gt;\n{isFancy ? &lt;Counter isFancy={true} /&gt; : &lt;Counter isFancy={false} /&gt;}\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isFancy}\nonChange={(e) =&gt; {\nsetIsFancy(e.target.checked);\n}}\n/&gt;\nUse fancy styling\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ isFancy }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\nif (isFancy) {\nclassName += \" fancy\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.fancy {\nborder: 5px solid gold;\ncolor: #ff6767;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>When you tick or clear the checkbox, the counter state does not get reset. Whether <code>isFancy</code> is <code>true</code> or <code>false</code>, you always have a <code>&lt;Counter /&gt;</code> as the first child of the <code>div</code> returned from the root <code>App</code> component:</p> <p>It's the same component at the same position, so from React's perspective, it's the same counter.</p> <p> <p>Remember that it's the position in the UI tree--not in the JSX markup--that matters to React! This component has two <code>return</code> clauses with different <code>&lt;Counter /&gt;</code> JSX tags inside and outside the <code>if</code>:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [isFancy, setIsFancy] = useState(false);\nif (isFancy) {\nreturn (\n&lt;div&gt;\n&lt;Counter isFancy={true} /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isFancy}\nonChange={(e) =&gt; {\nsetIsFancy(e.target.checked);\n}}\n/&gt;\nUse fancy styling\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\nreturn (\n&lt;div&gt;\n&lt;Counter isFancy={false} /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isFancy}\nonChange={(e) =&gt; {\nsetIsFancy(e.target.checked);\n}}\n/&gt;\nUse fancy styling\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ isFancy }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\nif (isFancy) {\nclassName += \" fancy\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.fancy {\nborder: 5px solid gold;\ncolor: #ff6767;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>You might expect the state to reset when you tick checkbox, but it doesn't! This is because both of these <code>&lt;Counter /&gt;</code> tags are rendered at the same position. React doesn't know where you place the conditions in your function. All it \"sees\" is the tree you return.</p> <p>In both cases, the <code>App</code> component returns a <code>&lt;div&gt;</code> with <code>&lt;Counter /&gt;</code> as a first child. To React, these two counters have the same \"address\": the first child of the first child of the root. This is how React matches them up between the previous and next renders, regardless of how you structure your logic.</p> <p></p>"},{"location":"learn/preserving-and-resetting-state/#different-components-at-the-same-position-reset-state","title":"Different components at the same position reset state","text":"<p>In this example, ticking the checkbox will replace <code>&lt;Counter&gt;</code> with a <code>&lt;p&gt;</code>:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [isPaused, setIsPaused] = useState(false);\nreturn (\n&lt;div&gt;\n{isPaused ? &lt;p&gt;See you later!&lt;/p&gt; : &lt;Counter /&gt;}\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isPaused}\nonChange={(e) =&gt; {\nsetIsPaused(e.target.checked);\n}}\n/&gt;\nTake a break\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter() {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>Here, you switch between different component types at the same position. Initially, the first child of the <code>&lt;div&gt;</code> contained a <code>Counter</code>. But when you swapped in a <code>p</code>, React removed the <code>Counter</code> from the UI tree and destroyed its state.</p> <p>Also, when you render a different component in the same position, it resets the state of its entire subtree. To see how this works, increment the counter and then tick the checkbox:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [isFancy, setIsFancy] = useState(false);\nreturn (\n&lt;div&gt;\n{isFancy ? (\n&lt;div&gt;\n&lt;Counter isFancy={true} /&gt;\n&lt;/div&gt;\n) : (\n&lt;section&gt;\n&lt;Counter isFancy={false} /&gt;\n&lt;/section&gt;\n)}\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isFancy}\nonChange={(e) =&gt; {\nsetIsFancy(e.target.checked);\n}}\n/&gt;\nUse fancy styling\n&lt;/label&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ isFancy }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\nif (isFancy) {\nclassName += \" fancy\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;{score}&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nclear: both;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\nfloat: left;\n}\n\n.fancy {\nborder: 5px solid gold;\ncolor: #ff6767;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>The counter state gets reset when you click the checkbox. Although you render a <code>Counter</code>, the first child of the <code>div</code> changes from a <code>div</code> to a <code>section</code>. When the child <code>div</code> was removed from the DOM, the whole tree below it (including the <code>Counter</code> and its state) was destroyed as well.</p> <p>As a rule of thumb, if you want to preserve the state between re-renders, the structure of your tree needs to \"match up\" from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree.</p> <p> <p>This is why you should not nest component function definitions.</p> <p>Here, the <code>MyTextField</code> component function is defined inside <code>MyComponent</code>:</p> <pre><code>import { useState } from \"react\";\n\nexport default function MyComponent() {\nconst [counter, setCounter] = useState(0);\n\nfunction MyTextField() {\nconst [text, setText] = useState(\"\");\n\nreturn &lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;;\n}\n\nreturn (\n&lt;&gt;\n&lt;MyTextField /&gt;\n&lt;button\non_click={() =&gt; {\nsetCounter(counter + 1);\n}}\n&gt;\nClicked {counter} times\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Every time you click the button, the input state disappears! This is because a different <code>MyTextField</code> function is created for every render of <code>MyComponent</code>. You're rendering a different component in the same position, so React resets all state below. This leads to bugs and performance problems. To avoid this problem, always declare component functions at the top level, and don't nest their definitions.</p> <p></p>"},{"location":"learn/preserving-and-resetting-state/#resetting-state-at-the-same-position","title":"Resetting state at the same position","text":"<p>By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component's state. Consider this app that lets two players keep track of their scores during each turn:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Scoreboard() {\nconst [isPlayerA, setIsPlayerA] = useState(true);\nreturn (\n&lt;div&gt;\n{isPlayerA ? (\n&lt;Counter person=\"Taylor\" /&gt;\n) : (\n&lt;Counter person=\"Sarah\" /&gt;\n)}\n&lt;button\non_click={() =&gt; {\nsetIsPlayerA(!isPlayerA);\n}}\n&gt;\nNext player!\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ person }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;\n{person}'s score: {score}\n&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nfont-size: 18px;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>Currently, when you change the player, the score is preserved. The two <code>Counter</code>s appear in the same position, so React sees them as the same <code>Counter</code> whose <code>person</code> prop has changed.</p> <p>But conceptually, in this app they should be two separate counters. They might appear in the same place in the UI, but one is a counter for Taylor, and another is a counter for Sarah.</p> <p>There are two ways to reset state when switching between them:</p> <ol> <li>Render components in different positions</li> <li>Give each component an explicit identity with <code>key</code></li> </ol>"},{"location":"learn/preserving-and-resetting-state/#option-1-rendering-a-component-in-different-positions","title":"Option 1: Rendering a component in different positions","text":"<p>If you want these two <code>Counter</code>s to be independent, you can render them in two different positions:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Scoreboard() {\nconst [isPlayerA, setIsPlayerA] = useState(true);\nreturn (\n&lt;div&gt;\n{isPlayerA &amp;&amp; &lt;Counter person=\"Taylor\" /&gt;}\n{!isPlayerA &amp;&amp; &lt;Counter person=\"Sarah\" /&gt;}\n&lt;button\non_click={() =&gt; {\nsetIsPlayerA(!isPlayerA);\n}}\n&gt;\nNext player!\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ person }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;\n{person}'s score: {score}\n&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nfont-size: 18px;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <ul> <li>Initially, <code>isPlayerA</code> is <code>true</code>. So the first position contains <code>Counter</code> state, and the second one is empty.</li> <li>When you click the \"Next player\" button the first position clears but the second one now contains a <code>Counter</code>.</li> </ul> <p>Each <code>Counter</code>'s state gets destroyed each time its removed from the DOM. This is why they reset every time you click the button.</p> <p>This solution is convenient when you only have a few independent components rendered in the same place. In this example, you only have two, so it's not a hassle to render both separately in the JSX.</p>"},{"location":"learn/preserving-and-resetting-state/#option-2-resetting-state-with-a-key","title":"Option 2: Resetting state with a key","text":"<p>There is also another, more generic, way to reset a component's state.</p> <p>You might have seen <code>key</code>s when rendering lists. Keys aren't just for lists! You can use keys to make React distinguish between any components. By default, React uses order within the parent (\"first counter\", \"second counter\") to discern between components. But keys let you tell React that this is not just a first counter, or a second counter, but a specific counter--for example, Taylor's counter. This way, React will know Taylor's counter wherever it appears in the tree!</p> <p>In this example, the two <code>&lt;Counter /&gt;</code>s don't share state even though they appear in the same place in JSX:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Scoreboard() {\nconst [isPlayerA, setIsPlayerA] = useState(true);\nreturn (\n&lt;div&gt;\n{isPlayerA ? (\n&lt;Counter key=\"Taylor\" person=\"Taylor\" /&gt;\n) : (\n&lt;Counter key=\"Sarah\" person=\"Sarah\" /&gt;\n)}\n&lt;button\non_click={() =&gt; {\nsetIsPlayerA(!isPlayerA);\n}}\n&gt;\nNext player!\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Counter({ person }) {\nconst [score, setScore] = useState(0);\nconst [hover, setHover] = useState(false);\n\nlet className = \"counter\";\nif (hover) {\nclassName += \" hover\";\n}\n\nreturn (\n&lt;div\nclassName={className}\nonPointerEnter={() =&gt; setHover(true)}\nonPointerLeave={() =&gt; setHover(false)}\n&gt;\n&lt;h1&gt;\n{person}'s score: {score}\n&lt;/h1&gt;\n&lt;button on_click={() =&gt; setScore(score + 1)}&gt;Add one&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nfont-size: 18px;\n}\n\n.counter {\nwidth: 100px;\ntext-align: center;\nborder: 1px solid gray;\nborder-radius: 4px;\npadding: 20px;\nmargin: 0 20px 20px 0;\n}\n\n.hover {\nbackground: #ffffd8;\n}\n</code></pre> <p>Switching between Taylor and Sarah does not preserve the state. This is because you gave them different <code>key</code>s:</p> <pre><code>{\nisPlayerA ? (\n&lt;Counter key=\"Taylor\" person=\"Taylor\" /&gt;\n) : (\n&lt;Counter key=\"Sarah\" person=\"Sarah\" /&gt;\n);\n}\n</code></pre> <p>Specifying a <code>key</code> tells React to use the <code>key</code> itself as part of the position, instead of their order within the parent. This is why, even though you render them in the same place in JSX, React sees them as two different counters, and so they will never share state. Every time a counter appears on the screen, its state is created. Every time it is removed, its state is destroyed. Toggling between them resets their state over and over.</p> <p> <p>Remember that keys are not globally unique. They only specify the position within the parent.</p> <p></p>"},{"location":"learn/preserving-and-resetting-state/#resetting-a-form-with-a-key","title":"Resetting a form with a key","text":"<p>Resetting state with a key is particularly useful when dealing with forms.</p> <p>In this chat app, the <code>&lt;Chat&gt;</code> component contains the text input state:</p> <pre><code>import { useState } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\n\nexport default function Messenger() {\nconst [to, setTo] = useState(contacts[0]);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedContact={to}\nonSelect={(contact) =&gt; setTo(contact)}\n/&gt;\n&lt;Chat contact={to} /&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ selectedContact, contacts, onSelect }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact);\n}}\n&gt;\n{contact.name}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={text}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button&gt;Send to {contact.email}&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>Try entering something into the input, and then press \"Alice\" or \"Bob\" to choose a different recipient. You will notice that the input state is preserved because the <code>&lt;Chat&gt;</code> is rendered at the same position in the tree.</p> <p>In many apps, this may be the desired behavior, but not in a chat app! You don't want to let the user send a message they already typed to a wrong person due to an accidental click. To fix it, add a <code>key</code>:</p> <pre><code>&lt;Chat key={to.id} contact={to} /&gt;\n</code></pre> <p>This ensures that when you select a different recipient, the <code>Chat</code> component will be recreated from scratch, including any state in the tree below it. React will also re-create the DOM elements instead of reusing them.</p> <p>Now switching the recipient always clears the text field:</p> <pre><code>import { useState } from \"react\";\nimport Chat from \"./Chat.js\";\nimport ContactList from \"./ContactList.js\";\n\nexport default function Messenger() {\nconst [to, setTo] = useState(contacts[0]);\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedContact={to}\nonSelect={(contact) =&gt; setTo(contact)}\n/&gt;\n&lt;Chat key={to.id} contact={to} /&gt;\n&lt;/div&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ selectedContact, contacts, onSelect }) {\nreturn (\n&lt;section className=\"contact-list\"&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact);\n}}\n&gt;\n{contact.name}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Chat({ contact }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;section className=\"chat\"&gt;\n&lt;textarea\nvalue={text}\nplaceholder={\"Chat to \" + contact.name}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button&gt;Send to {contact.email}&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>.chat,\n.contact-list {\nfloat: left;\nmargin-bottom: 20px;\n}\nul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli button {\nwidth: 100px;\npadding: 10px;\nmargin-right: 10px;\n}\ntextarea {\nheight: 150px;\n}\n</code></pre> <p>"},{"location":"learn/preserving-and-resetting-state/#preserving-state-for-removed-components","title":"Preserving state for removed components","text":"<p>In a real chat app, you'd probably want to recover the input state when the user selects the previous recipient again. There are a few ways to keep the state \"alive\" for a component that's no longer visible:</p> <ul> <li>You could render all chats instead of just the current one, but hide all the others with CSS. The chats would not get removed from the tree, so their local state would be preserved. This solution works great for simple UIs. But it can get very slow if the hidden trees are large and contain a lot of DOM nodes.</li> <li>You could lift the state up and hold the pending message for each recipient in the parent component. This way, when the child components get removed, it doesn't matter, because it's the parent that keeps the important information. This is the most common solution.</li> <li>You might also use a different source in addition to React state. For example, you probably want a message draft to persist even if the user accidentally closes the page. To implement this, you could have the <code>Chat</code> component initialize its state by reading from the <code>localStorage</code>, and save the drafts there too.</li> </ul> <p>No matter which strategy you pick, a chat with Alice is conceptually distinct from a chat with Bob, so it makes sense to give a <code>key</code> to the <code>&lt;Chat&gt;</code> tree based on the current recipient.</p> <p></p> <p> <ul> <li>React keeps state for as long as the same component is rendered at the same position.</li> <li>State is not kept in JSX tags. It's associated with the tree position in which you put that JSX.</li> <li>You can force a subtree to reset its state by giving it a different key.</li> <li>Don't nest component definitions, or you'll reset state by accident.</li> </ul> <p></p> <p>"},{"location":"learn/preserving-and-resetting-state/#fix-disappearing-input-text","title":"Fix disappearing input text","text":"<p>This example shows a message when you press the button. However, pressing the button also accidentally resets the input. Why does this happen? Fix it so that pressing the button does not reset the input text.</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [showHint, setShowHint] = useState(false);\nif (showHint) {\nreturn (\n&lt;div&gt;\n&lt;p&gt;\n&lt;i&gt;Hint: Your favorite city?&lt;/i&gt;\n&lt;/p&gt;\n&lt;Form /&gt;\n&lt;button\non_click={() =&gt; {\nsetShowHint(false);\n}}\n&gt;\nHide hint\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\nreturn (\n&lt;div&gt;\n&lt;Form /&gt;\n&lt;button\non_click={() =&gt; {\nsetShowHint(true);\n}}\n&gt;\nShow hint\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Form() {\nconst [text, setText] = useState(\"\");\nreturn &lt;textarea value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;;\n}\n</code></pre> <pre><code>textarea {\ndisplay: block;\nmargin: 10px 0;\n}\n</code></pre> <p> <p>The problem is that <code>Form</code> is rendered in different positions. In the <code>if</code> branch, it is the second child of the <code>&lt;div&gt;</code>, but in the <code>else</code> branch, it is the first child. Therefore, the component type in each position changes. The first position changes between holding a <code>p</code> and a <code>Form</code>, while the second position changes between holding a <code>Form</code> and a <code>button</code>. React resets the state every time the component type changes.</p> <p>The easiest solution is to unify the branches so that <code>Form</code> always renders in the same position:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [showHint, setShowHint] = useState(false);\nreturn (\n&lt;div&gt;\n{showHint &amp;&amp; (\n&lt;p&gt;\n&lt;i&gt;Hint: Your favorite city?&lt;/i&gt;\n&lt;/p&gt;\n)}\n&lt;Form /&gt;\n{showHint ? (\n&lt;button\non_click={() =&gt; {\nsetShowHint(false);\n}}\n&gt;\nHide hint\n&lt;/button&gt;\n) : (\n&lt;button\non_click={() =&gt; {\nsetShowHint(true);\n}}\n&gt;\nShow hint\n&lt;/button&gt;\n)}\n&lt;/div&gt;\n);\n}\n\nfunction Form() {\nconst [text, setText] = useState(\"\");\nreturn &lt;textarea value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;;\n}\n</code></pre> <pre><code>textarea {\ndisplay: block;\nmargin: 10px 0;\n}\n</code></pre> <p>Technically, you could also add <code>null</code> before <code>&lt;Form /&gt;</code> in the <code>else</code> branch to match the <code>if</code> branch structure:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [showHint, setShowHint] = useState(false);\nif (showHint) {\nreturn (\n&lt;div&gt;\n&lt;p&gt;\n&lt;i&gt;Hint: Your favorite city?&lt;/i&gt;\n&lt;/p&gt;\n&lt;Form /&gt;\n&lt;button\non_click={() =&gt; {\nsetShowHint(false);\n}}\n&gt;\nHide hint\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\nreturn (\n&lt;div&gt;\n{null}\n&lt;Form /&gt;\n&lt;button\non_click={() =&gt; {\nsetShowHint(true);\n}}\n&gt;\nShow hint\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Form() {\nconst [text, setText] = useState(\"\");\nreturn &lt;textarea value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;;\n}\n</code></pre> <pre><code>textarea {\ndisplay: block;\nmargin: 10px 0;\n}\n</code></pre> <p>This way, <code>Form</code> is always the second child, so it stays in the same position and keeps its state. But this approach is much less obvious and introduces a risk that someone else will remove that <code>null</code>.</p> <p></p>"},{"location":"learn/preserving-and-resetting-state/#swap-two-form-fields","title":"Swap two form fields","text":"<p>This form lets you enter first and last name. It also has a checkbox controlling which field goes first. When you tick the checkbox, the \"Last name\" field will appear before the \"First name\" field.</p> <p>It almost works, but there is a bug. If you fill in the \"First name\" input and tick the checkbox, the text will stay in the first input (which is now \"Last name\"). Fix it so that the input text also moves when you reverse the order.</p> <p> <p>It seems like for these fields, their position within the parent is not enough. Is there some way to tell React how to match up the state between re-renders?</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [reverse, setReverse] = useState(false);\nlet checkbox = (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={reverse}\nonChange={(e) =&gt; setReverse(e.target.checked)}\n/&gt;\nReverse order\n&lt;/label&gt;\n);\nif (reverse) {\nreturn (\n&lt;&gt;\n&lt;Field label=\"Last name\" /&gt;\n&lt;Field label=\"First name\" /&gt;\n{checkbox}\n&lt;/&gt;\n);\n} else {\nreturn (\n&lt;&gt;\n&lt;Field label=\"First name\" /&gt;\n&lt;Field label=\"Last name\" /&gt;\n{checkbox}\n&lt;/&gt;\n);\n}\n}\n\nfunction Field({ label }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;label&gt;\n{label}:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={text}\nplaceholder={label}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin: 10px 0;\n}\n</code></pre> <p> <p>Give a <code>key</code> to both <code>&lt;Field&gt;</code> components in both <code>if</code> and <code>else</code> branches. This tells React how to \"match up\" the correct state for either <code>&lt;Field&gt;</code> even if their order within the parent changes:</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [reverse, setReverse] = useState(false);\nlet checkbox = (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={reverse}\nonChange={(e) =&gt; setReverse(e.target.checked)}\n/&gt;\nReverse order\n&lt;/label&gt;\n);\nif (reverse) {\nreturn (\n&lt;&gt;\n&lt;Field key=\"lastName\" label=\"Last name\" /&gt;\n&lt;Field key=\"firstName\" label=\"First name\" /&gt;\n{checkbox}\n&lt;/&gt;\n);\n} else {\nreturn (\n&lt;&gt;\n&lt;Field key=\"firstName\" label=\"First name\" /&gt;\n&lt;Field key=\"lastName\" label=\"Last name\" /&gt;\n{checkbox}\n&lt;/&gt;\n);\n}\n}\n\nfunction Field({ label }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;label&gt;\n{label}:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={text}\nplaceholder={label}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin: 10px 0;\n}\n</code></pre> <p></p>"},{"location":"learn/preserving-and-resetting-state/#reset-a-detail-form","title":"Reset a detail form","text":"<p>This is an editable contact list. You can edit the selected contact's details and then either press \"Save\" to update it, or \"Reset\" to undo your changes.</p> <p>When you select a different contact (for example, Alice), the state updates but the form keeps showing the previous contact's details. Fix it so that the form gets reset when the selected contact changes.</p> <pre><code>import { useState } from \"react\";\nimport ContactList from \"./ContactList.js\";\nimport EditContact from \"./EditContact.js\";\n\nexport default function ContactManager() {\nconst [contacts, setContacts] = useState(initialContacts);\nconst [selectedId, setSelectedId] = useState(0);\nconst selectedContact = contacts.find((c) =&gt; c.id === selectedId);\n\nfunction handleSave(updatedData) {\nconst nextContacts = contacts.map((c) =&gt; {\nif (c.id === updatedData.id) {\nreturn updatedData;\n} else {\nreturn c;\n}\n});\nsetContacts(nextContacts);\n}\n\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={selectedId}\nonSelect={(id) =&gt; setSelectedId(id)}\n/&gt;\n&lt;hr /&gt;\n&lt;EditContact initialData={selectedContact} onSave={handleSave} /&gt;\n&lt;/div&gt;\n);\n}\n\nconst initialContacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, onSelect }) {\nreturn (\n&lt;section&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact.id);\n}}\n&gt;\n{contact.id === selectedId ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function EditContact({ initialData, onSave }) {\nconst [name, setName] = useState(initialData.name);\nconst [email, setEmail] = useState(initialData.email);\nreturn (\n&lt;section&gt;\n&lt;label&gt;\nName:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:{\" \"}\n&lt;input\ntype=\"email\"\nvalue={email}\nonChange={(e) =&gt; setEmail(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;button\non_click={() =&gt; {\nconst updatedData = {\nid: initialData.id,\nname: name,\nemail: email,\n};\nonSave(updatedData);\n}}\n&gt;\nSave\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nsetName(initialData.name);\nsetEmail(initialData.email);\n}}\n&gt;\nReset\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\ndisplay: inline-block;\n}\nli button {\npadding: 10px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>Give <code>key={selectedId}</code> to the <code>EditContact</code> component. This way, switching between different contacts will reset the form:</p> <pre><code>import { useState } from \"react\";\nimport ContactList from \"./ContactList.js\";\nimport EditContact from \"./EditContact.js\";\n\nexport default function ContactManager() {\nconst [contacts, setContacts] = useState(initialContacts);\nconst [selectedId, setSelectedId] = useState(0);\nconst selectedContact = contacts.find((c) =&gt; c.id === selectedId);\n\nfunction handleSave(updatedData) {\nconst nextContacts = contacts.map((c) =&gt; {\nif (c.id === updatedData.id) {\nreturn updatedData;\n} else {\nreturn c;\n}\n});\nsetContacts(nextContacts);\n}\n\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={selectedId}\nonSelect={(id) =&gt; setSelectedId(id)}\n/&gt;\n&lt;hr /&gt;\n&lt;EditContact\nkey={selectedId}\ninitialData={selectedContact}\nonSave={handleSave}\n/&gt;\n&lt;/div&gt;\n);\n}\n\nconst initialContacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, onSelect }) {\nreturn (\n&lt;section&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact.id);\n}}\n&gt;\n{contact.id === selectedId ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function EditContact({ initialData, onSave }) {\nconst [name, setName] = useState(initialData.name);\nconst [email, setEmail] = useState(initialData.email);\nreturn (\n&lt;section&gt;\n&lt;label&gt;\nName:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:{\" \"}\n&lt;input\ntype=\"email\"\nvalue={email}\nonChange={(e) =&gt; setEmail(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;button\non_click={() =&gt; {\nconst updatedData = {\nid: initialData.id,\nname: name,\nemail: email,\n};\nonSave(updatedData);\n}}\n&gt;\nSave\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nsetName(initialData.name);\nsetEmail(initialData.email);\n}}\n&gt;\nReset\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\ndisplay: inline-block;\n}\nli button {\npadding: 10px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/preserving-and-resetting-state/#clear-an-image-while-its-loading","title":"Clear an image while it's loading","text":"<p>When you press \"Next\", the browser starts loading the next image. However, because it's displayed in the same <code>&lt;img&gt;</code> tag, by default you would still see the previous image until the next one loads. This may be undesirable if it's important for the text to always match the image. Change it so that the moment you press \"Next\", the previous image immediately clears.</p> <p> <p>Is there a way to tell React to re-create the DOM instead of reusing it?</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst hasNext = index &lt; images.length - 1;\n\nfunction handleClick() {\nif (hasNext) {\nsetIndex(index + 1);\n} else {\nsetIndex(0);\n}\n}\n\nlet image = images[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Next&lt;/button&gt;\n&lt;h3&gt;\nImage {index + 1} of {images.length}\n&lt;/h3&gt;\n&lt;img src={image.src} /&gt;\n&lt;p&gt;{image.place}&lt;/p&gt;\n&lt;/&gt;\n);\n}\n\nlet images = [\n{\nplace: \"Penang, Malaysia\",\nsrc: \"https://i.imgur.com/FJeJR8M.jpg\",\n},\n{\nplace: \"Lisbon, Portugal\",\nsrc: \"https://i.imgur.com/dB2LRbj.jpg\",\n},\n{\nplace: \"Bilbao, Spain\",\nsrc: \"https://i.imgur.com/z08o2TS.jpg\",\n},\n{\nplace: \"Valpara\u00edso, Chile\",\nsrc: \"https://i.imgur.com/Y3utgTi.jpg\",\n},\n{\nplace: \"Schwyz, Switzerland\",\nsrc: \"https://i.imgur.com/JBbMpWY.jpg\",\n},\n{\nplace: \"Prague, Czechia\",\nsrc: \"https://i.imgur.com/QwUKKmF.jpg\",\n},\n{\nplace: \"Ljubljana, Slovenia\",\nsrc: \"https://i.imgur.com/3aIiwfm.jpg\",\n},\n];\n</code></pre> <pre><code>img {\nwidth: 150px;\nheight: 150px;\n}\n</code></pre> <p> <p>You can provide a <code>key</code> to the <code>&lt;img&gt;</code> tag. When that <code>key</code> changes, React will re-create the <code>&lt;img&gt;</code> DOM node from scratch. This causes a brief flash when each image loads, so it's not something you'd want to do for every image in your app. But it makes sense if you want to ensure the image always matches the text.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst hasNext = index &lt; images.length - 1;\n\nfunction handleClick() {\nif (hasNext) {\nsetIndex(index + 1);\n} else {\nsetIndex(0);\n}\n}\n\nlet image = images[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Next&lt;/button&gt;\n&lt;h3&gt;\nImage {index + 1} of {images.length}\n&lt;/h3&gt;\n&lt;img key={image.src} src={image.src} /&gt;\n&lt;p&gt;{image.place}&lt;/p&gt;\n&lt;/&gt;\n);\n}\n\nlet images = [\n{\nplace: \"Penang, Malaysia\",\nsrc: \"https://i.imgur.com/FJeJR8M.jpg\",\n},\n{\nplace: \"Lisbon, Portugal\",\nsrc: \"https://i.imgur.com/dB2LRbj.jpg\",\n},\n{\nplace: \"Bilbao, Spain\",\nsrc: \"https://i.imgur.com/z08o2TS.jpg\",\n},\n{\nplace: \"Valpara\u00edso, Chile\",\nsrc: \"https://i.imgur.com/Y3utgTi.jpg\",\n},\n{\nplace: \"Schwyz, Switzerland\",\nsrc: \"https://i.imgur.com/JBbMpWY.jpg\",\n},\n{\nplace: \"Prague, Czechia\",\nsrc: \"https://i.imgur.com/QwUKKmF.jpg\",\n},\n{\nplace: \"Ljubljana, Slovenia\",\nsrc: \"https://i.imgur.com/3aIiwfm.jpg\",\n},\n];\n</code></pre> <pre><code>img {\nwidth: 150px;\nheight: 150px;\n}\n</code></pre> <p></p>"},{"location":"learn/preserving-and-resetting-state/#fix-misplaced-state-in-the-list","title":"Fix misplaced state in the list","text":"<p>In this list, each <code>Contact</code> has state that determines whether \"Show email\" has been pressed for it. Press \"Show email\" for Alice, and then tick the \"Show in reverse order\" checkbox. You will notice that it's Taylor's email that is expanded now, but Alice's--which has moved to the bottom--appears collapsed.</p> <p>Fix it so that the expanded state is associated with each contact, regardless of the chosen ordering.</p> <pre><code>import { useState } from \"react\";\nimport Contact from \"./Contact.js\";\n\nexport default function ContactList() {\nconst [reverse, setReverse] = useState(false);\n\nconst displayedContacts = [...contacts];\nif (reverse) {\ndisplayedContacts.reverse();\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nvalue={reverse}\nonChange={(e) =&gt; {\nsetReverse(e.target.checked);\n}}\n/&gt;{\" \"}\nShow in reverse order\n&lt;/label&gt;\n&lt;ul&gt;\n{displayedContacts.map((contact, i) =&gt; (\n&lt;li key={i}&gt;\n&lt;Contact contact={contact} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 1, name: \"Bob\", email: \"bob@mail.com\" },\n{ id: 2, name: \"Taylor\", email: \"taylor@mail.com\" },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Contact({ contact }) {\nconst [expanded, setExpanded] = useState(false);\nreturn (\n&lt;&gt;\n&lt;p&gt;\n&lt;b&gt;{contact.name}&lt;/b&gt;\n&lt;/p&gt;\n{expanded &amp;&amp; (\n&lt;p&gt;\n&lt;i&gt;{contact.email}&lt;/i&gt;\n&lt;/p&gt;\n)}\n&lt;button\non_click={() =&gt; {\nsetExpanded(!expanded);\n}}\n&gt;\n{expanded ? \"Hide\" : \"Show\"} email\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\nmargin-bottom: 20px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>The problem is that this example was using index as a <code>key</code>:</p> <pre><code>{displayedContacts.map((contact, i) =&gt;\n&lt;li key={i}&gt;\n</code></pre> <p>However, you want the state to be associated with each particular contact.</p> <p>Using the contact ID as a <code>key</code> instead fixes the issue:</p> <pre><code>import { useState } from \"react\";\nimport Contact from \"./Contact.js\";\n\nexport default function ContactList() {\nconst [reverse, setReverse] = useState(false);\n\nconst displayedContacts = [...contacts];\nif (reverse) {\ndisplayedContacts.reverse();\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nvalue={reverse}\nonChange={(e) =&gt; {\nsetReverse(e.target.checked);\n}}\n/&gt;{\" \"}\nShow in reverse order\n&lt;/label&gt;\n&lt;ul&gt;\n{displayedContacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;Contact contact={contact} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nconst contacts = [\n{ id: 0, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 1, name: \"Bob\", email: \"bob@mail.com\" },\n{ id: 2, name: \"Taylor\", email: \"taylor@mail.com\" },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Contact({ contact }) {\nconst [expanded, setExpanded] = useState(false);\nreturn (\n&lt;&gt;\n&lt;p&gt;\n&lt;b&gt;{contact.name}&lt;/b&gt;\n&lt;/p&gt;\n{expanded &amp;&amp; (\n&lt;p&gt;\n&lt;i&gt;{contact.email}&lt;/i&gt;\n&lt;/p&gt;\n)}\n&lt;button\non_click={() =&gt; {\nsetExpanded(!expanded);\n}}\n&gt;\n{expanded ? \"Hide\" : \"Show\"} email\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\nmargin-bottom: 20px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p>State is associated with the tree position. A <code>key</code> lets you specify a named position instead of relying on order.</p> <p></p> <p></p>"},{"location":"learn/python-in-psx-with-curly-braces/","title":"Python in psx with curly braces","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p> <p>See this issue for more details.</p>"},{"location":"learn/queueing-a-series-of-state-updates/","title":"Queueing a Series of State Updates \ud83d\udea7","text":""},{"location":"learn/queueing-a-series-of-state-updates/#overview","title":"Overview","text":"<p>  Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates.  </p> <p>You will learn</p> <ul> <li>What \"batching\" is and how React uses it to process multiple state updates</li> <li>How to apply several updates to the same state variable in a row</li> </ul>"},{"location":"learn/queueing-a-series-of-state-updates/#react-batches-state-updates","title":"React batches state updates","text":"<p>You might expect that clicking the \"+3\" button will increment the counter three times because it calls <code>setNumber(number + 1)</code> three times:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 1);\nsetNumber(number + 1);\nsetNumber(number + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>However, as you might recall from the previous section, each render's state values are fixed, so the value of <code>number</code> inside the first render's event handler is always <code>0</code>, no matter how many times you call <code>setNumber(1)</code>:</p> <pre><code>setNumber(0 + 1);\nsetNumber(0 + 1);\nsetNumber(0 + 1);\n</code></pre> <p>But there is one other factor at play here. React waits until all code in the event handlers has run before processing your state updates. This is why the re-render only happens after all these <code>setNumber()</code> calls.</p> <p>This might remind you of a waiter taking an order at the restaurant. A waiter doesn't run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table.</p> <p></p> <p>This lets you update multiple state variables--even from multiple components--without triggering too many re-renders. But this also means that the UI won't be updated until after your event handler, and any code in it, completes. This behavior, also known as batching, makes your React app run much faster. It also avoids dealing with confusing \"half-finished\" renders where only some of the variables have been updated.</p> <p>React does not batch across multiple intentional events like clicks--each click is handled separately. Rest assured that React only does batching when it's generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.</p>"},{"location":"learn/queueing-a-series-of-state-updates/#updating-the-same-state-multiple-times-before-the-next-render","title":"Updating the same state multiple times before the next render","text":"<p>It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing the next state value like <code>setNumber(number + 1)</code>, you can pass a function that calculates the next state based on the previous one in the queue, like <code>setNumber(n =&gt; n + 1)</code>. It is a way to tell React to \"do something with the state value\" instead of just replacing it.</p> <p>Try incrementing the counter now:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber((n) =&gt; n + 1);\nsetNumber((n) =&gt; n + 1);\nsetNumber((n) =&gt; n + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>Here, <code>n =&gt; n + 1</code> is called an updater function. When you pass it to a state setter:</p> <ol> <li>React queues this function to be processed after all the other code in the event handler has run.</li> <li>During the next render, React goes through the queue and gives you the final updated state.</li> </ol> <pre><code>setNumber((n) =&gt; n + 1);\nsetNumber((n) =&gt; n + 1);\nsetNumber((n) =&gt; n + 1);\n</code></pre> <p>Here's how React works through these lines of code while executing the event handler:</p> <ol> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> </ol> <p>When you call <code>useState</code> during the next render, React goes through the queue. The previous <code>number</code> state was <code>0</code>, so that's what React passes to the first updater function as the <code>n</code> argument. Then React takes the return value of your previous updater function and passes it to the next updater as <code>n</code>, and so on:</p> queued update <code>n</code> returns <code>n =&gt; n + 1</code> <code>0</code> <code>0 + 1 = 1</code> <code>n =&gt; n + 1</code> <code>1</code> <code>1 + 1 = 2</code> <code>n =&gt; n + 1</code> <code>2</code> <code>2 + 1 = 3</code> <p>React stores <code>3</code> as the final result and returns it from <code>useState</code>.</p> <p>This is why clicking \"+3\" in the above example correctly increments the value by 3.</p>"},{"location":"learn/queueing-a-series-of-state-updates/#what-happens-if-you-update-state-after-replacing-it","title":"What happens if you update state after replacing it","text":"<p>What about this event handler? What do you think <code>number</code> will be in the next render?</p> <pre><code>&lt;button on_click={() =&gt; {\nsetNumber(number + 5);\nsetNumber(n =&gt; n + 1);\n}}&gt;\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 5);\nsetNumber((n) =&gt; n + 1);\n}}\n&gt;\nIncrease the number\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>Here's what this event handler tells React to do:</p> <ol> <li><code>setNumber(number + 5)</code>: <code>number</code> is <code>0</code>, so <code>setNumber(0 + 5)</code>. React adds \"replace with <code>5</code>\" to its queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is an updater function. React adds that function to its queue.</li> </ol> <p>During the next render, React goes through the state queue:</p> queued update <code>n</code> returns \"replace with <code>5</code>\" <code>0</code> (unused) <code>5</code> <code>n =&gt; n + 1</code> <code>5</code> <code>5 + 1 = 6</code> <p>React stores <code>6</code> as the final result and returns it from <code>useState</code>.</p> <p> <p>You may have noticed that <code>setState(5)</code> actually works like <code>setState(n =&gt; 5)</code>, but <code>n</code> is unused!</p> <p></p>"},{"location":"learn/queueing-a-series-of-state-updates/#what-happens-if-you-replace-state-after-updating-it","title":"What happens if you replace state after updating it","text":"<p>Let's try one more example. What do you think <code>number</code> will be in the next render?</p> <pre><code>&lt;button on_click={() =&gt; {\nsetNumber(number + 5);\nsetNumber(n =&gt; n + 1);\nsetNumber(42);\n}}&gt;\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 5);\nsetNumber((n) =&gt; n + 1);\nsetNumber(42);\n}}\n&gt;\nIncrease the number\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>Here's how React works through these lines of code while executing this event handler:</p> <ol> <li><code>setNumber(number + 5)</code>: <code>number</code> is <code>0</code>, so <code>setNumber(0 + 5)</code>. React adds \"replace with <code>5</code>\" to its queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is an updater function. React adds that function to its queue.</li> <li><code>setNumber(42)</code>: React adds \"replace with <code>42</code>\" to its queue.</li> </ol> <p>During the next render, React goes through the state queue:</p> queued update <code>n</code> returns \"replace with <code>5</code>\" <code>0</code> (unused) <code>5</code> <code>n =&gt; n + 1</code> <code>5</code> <code>5 + 1 = 6</code> \"replace with <code>42</code>\" <code>6</code> (unused) <code>42</code> <p>Then React stores <code>42</code> as the final result and returns it from <code>useState</code>.</p> <p>To summarize, here's how you can think of what you're passing to the <code>setNumber</code> state setter:</p> <ul> <li>An updater function (e.g. <code>n =&gt; n + 1</code>) gets added to the queue.</li> <li>Any other value (e.g. number <code>5</code>) adds \"replace with <code>5</code>\" to the queue, ignoring what's already queued.</li> </ul> <p>After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, so updater functions must be pure and only return the result. Don't try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.</p>"},{"location":"learn/queueing-a-series-of-state-updates/#naming-conventions","title":"Naming conventions","text":"<p>It's common to name the updater function argument by the first letters of the corresponding state variable:</p> <pre><code>setEnabled((e) =&gt; !e);\nsetLastName((ln) =&gt; ln.reverse());\nsetFriendCount((fc) =&gt; fc * 2);\n</code></pre> <p>If you prefer more verbose code, another common convention is to repeat the full state variable name, like <code>setEnabled(enabled =&gt; !enabled)</code>, or to use a prefix like <code>setEnabled(prevEnabled =&gt; !prevEnabled)</code>.</p> <p> <ul> <li>Setting state does not change the variable in the existing render, but it requests a new render.</li> <li>React processes state updates after event handlers have finished running. This is called batching.</li> <li>To update some state multiple times in one event, you can use <code>setNumber(n =&gt; n + 1)</code> updater function.</li> </ul> <p></p> <p>"},{"location":"learn/queueing-a-series-of-state-updates/#fix-a-request-counter","title":"Fix a request counter","text":"<p>You're working on an art marketplace app that lets the user submit multiple orders for an art item at the same time. Each time the user presses the \"Buy\" button, the \"Pending\" counter should increase by one. After three seconds, the \"Pending\" counter should decrease, and the \"Completed\" counter should increase.</p> <p>However, the \"Pending\" counter does not behave as intended. When you press \"Buy\", it decreases to <code>-1</code> (which should not be possible!). And if you click fast twice, both counters seem to behave unpredictably.</p> <p>Why does this happen? Fix both counters.</p> <pre><code>import { useState } from \"react\";\n\nexport default function RequestTracker() {\nconst [pending, setPending] = useState(0);\nconst [completed, setCompleted] = useState(0);\n\nasync function handleClick() {\nsetPending(pending + 1);\nawait delay(3000);\nsetPending(pending - 1);\nsetCompleted(completed + 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;h3&gt;Pending: {pending}&lt;/h3&gt;\n&lt;h3&gt;Completed: {completed}&lt;/h3&gt;\n&lt;button on_click={handleClick}&gt;Buy&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nfunction delay(ms) {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(resolve, ms);\n});\n}\n</code></pre> <p> <p>Inside the <code>handleClick</code> event handler, the values of <code>pending</code> and <code>completed</code> correspond to what they were at the time of the click event. For the first render, <code>pending</code> was <code>0</code>, so <code>setPending(pending - 1)</code> becomes <code>setPending(-1)</code>, which is wrong. Since you want to increment or decrement the counters, rather than set them to a concrete value determined during the click, you can instead pass the updater functions:</p> <pre><code>import { useState } from \"react\";\n\nexport default function RequestTracker() {\nconst [pending, setPending] = useState(0);\nconst [completed, setCompleted] = useState(0);\n\nasync function handleClick() {\nsetPending((p) =&gt; p + 1);\nawait delay(3000);\nsetPending((p) =&gt; p - 1);\nsetCompleted((c) =&gt; c + 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;h3&gt;Pending: {pending}&lt;/h3&gt;\n&lt;h3&gt;Completed: {completed}&lt;/h3&gt;\n&lt;button on_click={handleClick}&gt;Buy&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nfunction delay(ms) {\nreturn new Promise((resolve) =&gt; {\nsetTimeout(resolve, ms);\n});\n}\n</code></pre> <p>This ensures that when you increment or decrement a counter, you do it in relation to its latest state rather than what the state was at the time of the click.</p> <p></p>"},{"location":"learn/queueing-a-series-of-state-updates/#implement-the-state-queue-yourself","title":"Implement the state queue yourself","text":"<p>In this challenge, you will reimplement a tiny part of React from scratch! It's not as hard as it sounds.</p> <p>Scroll through the sandbox preview. Notice that it shows four test cases. They correspond to the examples you've seen earlier on this page. Your task is to implement the <code>getFinalState</code> function so that it returns the correct result for each of those cases. If you implement it correctly, all four tests should pass.</p> <p>You will receive two arguments: <code>baseState</code> is the initial state (like <code>0</code>), and the <code>queue</code> is an array which contains a mix of numbers (like <code>5</code>) and updater functions (like <code>n =&gt; n + 1</code>) in the order they were added.</p> <p>Your task is to return the final state, just like the tables on this page show!</p> <p> <p>If you're feeling stuck, start with this code structure:</p> <pre><code>export function getFinalState(baseState, queue) {\nlet finalState = baseState;\n\nfor (let update of queue) {\nif (typeof update === \"function\") {\n// TODO: apply the updater function\n} else {\n// TODO: replace the state\n}\n}\n\nreturn finalState;\n}\n</code></pre> <p>Fill out the missing lines!</p> <p></p> <pre><code>export function getFinalState(baseState, queue) {\nlet finalState = baseState;\n\n// TODO: do something with the queue...\n\nreturn finalState;\n}\n</code></pre> <pre><code>import { getFinalState } from \"./processQueue.js\";\n\nfunction increment(n) {\nreturn n + 1;\n}\nincrement.toString = () =&gt; \"n =&gt; n+1\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;TestCase baseState={0} queue={[1, 1, 1]} expected={1} /&gt;\n&lt;hr /&gt;\n&lt;TestCase\nbaseState={0}\nqueue={[increment, increment, increment]}\nexpected={3}\n/&gt;\n&lt;hr /&gt;\n&lt;TestCase baseState={0} queue={[5, increment]} expected={6} /&gt;\n&lt;hr /&gt;\n&lt;TestCase baseState={0} queue={[5, increment, 42]} expected={42} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction TestCase({ baseState, queue, expected }) {\nconst actual = getFinalState(baseState, queue);\nreturn (\n&lt;&gt;\n&lt;p&gt;\nBase state: &lt;b&gt;{baseState}&lt;/b&gt;\n&lt;/p&gt;\n&lt;p&gt;\nQueue: &lt;b&gt;[{queue.join(\", \")}]&lt;/b&gt;\n&lt;/p&gt;\n&lt;p&gt;\nExpected result: &lt;b&gt;{expected}&lt;/b&gt;\n&lt;/p&gt;\n&lt;p\nstyle={{\ncolor: actual === expected ? \"green\" : \"red\",\n}}\n&gt;\nYour result: &lt;b&gt;{actual}&lt;/b&gt; (\n{actual === expected ? \"correct\" : \"wrong\"})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p> <p>This is the exact algorithm described on this page that React uses to calculate the final state:</p> <pre><code>export function getFinalState(baseState, queue) {\nlet finalState = baseState;\n\nfor (let update of queue) {\nif (typeof update === \"function\") {\n// Apply the updater function.\nfinalState = update(finalState);\n} else {\n// Replace the next state.\nfinalState = update;\n}\n}\n\nreturn finalState;\n}\n</code></pre> <pre><code>import { getFinalState } from \"./processQueue.js\";\n\nfunction increment(n) {\nreturn n + 1;\n}\nincrement.toString = () =&gt; \"n =&gt; n+1\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;TestCase baseState={0} queue={[1, 1, 1]} expected={1} /&gt;\n&lt;hr /&gt;\n&lt;TestCase\nbaseState={0}\nqueue={[increment, increment, increment]}\nexpected={3}\n/&gt;\n&lt;hr /&gt;\n&lt;TestCase baseState={0} queue={[5, increment]} expected={6} /&gt;\n&lt;hr /&gt;\n&lt;TestCase baseState={0} queue={[5, increment, 42]} expected={42} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction TestCase({ baseState, queue, expected }) {\nconst actual = getFinalState(baseState, queue);\nreturn (\n&lt;&gt;\n&lt;p&gt;\nBase state: &lt;b&gt;{baseState}&lt;/b&gt;\n&lt;/p&gt;\n&lt;p&gt;\nQueue: &lt;b&gt;[{queue.join(\", \")}]&lt;/b&gt;\n&lt;/p&gt;\n&lt;p&gt;\nExpected result: &lt;b&gt;{expected}&lt;/b&gt;\n&lt;/p&gt;\n&lt;p\nstyle={{\ncolor: actual === expected ? \"green\" : \"red\",\n}}\n&gt;\nYour result: &lt;b&gt;{actual}&lt;/b&gt; (\n{actual === expected ? \"correct\" : \"wrong\"})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now you know how this part of React works!</p> <p></p> <p></p>"},{"location":"learn/quick-start/","title":"Quick start","text":""},{"location":"learn/quick-start/#overview","title":"Overview","text":"<p>  Welcome to the ReactPy documentation! This page will give you an introduction to the 80% of React concepts that you will use on a daily basis.  </p> <p>You will learn</p> <ul> <li>How to create and nest components</li> <li>How to add markup and styles</li> <li>How to display data</li> <li>How to render conditions and lists</li> <li>How to respond to events and update the screen</li> <li>How to share data between components</li> </ul>"},{"location":"learn/quick-start/#creating-and-nesting-components","title":"Creating and nesting components","text":"<p>React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.</p> <p>React components are Python functions that return markup:</p> <pre><code>@component\ndef my_button():\n    return html.button(\"I'm a button!\")\n</code></pre> <p>Now that you've declared <code>my_button</code>, you can nest it into another component:</p> <pre><code>@component\ndef my_app():\n    return html.div(\n        html.h1(\"Welcome to my app\"),\nmy_button(),\n)\n</code></pre> <p>Have a look at the result:</p> app.py Run <pre><code>from reactpy import component, html\n\n\n@component\ndef my_button():\n    return html.button(\"I'm a button!\")\n\n\n@component\ndef my_app():\n    return html.div(\n        html.h1(\"Welcome to my app\"),\n        my_button(),\n    )\n</code></pre> <pre><code># TODO\n</code></pre>"},{"location":"learn/quick-start/#adding-styles","title":"Adding styles","text":"<p>In React, you specify a CSS class with <code>className</code>. It works the same way as the HTML <code>class</code> attribute:</p> <pre><code>html.img({\"className\": \"avatar\"})\n</code></pre> <p>Then you write the CSS rules for it in a separate CSS file:</p> <pre><code>/* In your CSS */\n.avatar {\nborder-radius: 50%;\n}\n</code></pre> <p>React does not prescribe how you add CSS files. In the simplest case, you'll add a <code>&lt;link&gt;</code> tag to your HTML. If you use a build tool or web framework, consult its documentation to learn how to add a CSS file to your project.</p>"},{"location":"learn/quick-start/#displaying-data","title":"Displaying data","text":"<p>You can fetch data from a variety of sources and directly embed it into your components. You can also use the <code>style</code> attribute when your styles depend on JavaScript variables.</p> app.pystyles.css Run <pre><code>from reactpy import component, html\n\nuser = {\n    \"name\": \"Hedy Lamarr\",\n    \"image_url\": \"https://i.imgur.com/yXOvdOSs.jpg\",\n    \"image_size\": 90,\n}\n\n\n@component\ndef profile():\n    return html.div(\n        html.h3(user[\"name\"]),\n        html.img(\n            {\n                \"className\": \"avatar\",\n                \"src\": user[\"image_url\"],\n                \"alt\": f\"Photo of {user['name']}\",\n                \"style\": {\n                    \"width\": user[\"image_size\"],\n                    \"height\": user[\"image_size\"],\n                },\n            }\n        ),\n    )\n</code></pre> <pre><code>.avatar {\nborder-radius: 50%;\n}\n\n.large {\nborder: 4px solid gold;\n}\n</code></pre> <pre><code># TODO\n</code></pre>"},{"location":"learn/quick-start/#conditional-rendering","title":"Conditional rendering","text":"<p>In React, there is no special syntax for writing conditions. Instead, you'll use the same techniques as you use when writing regular Python code. For example, you can use an <code>if</code> statement to conditionally include components:</p> <pre><code>@component\ndef my_component():\n    if is_logged_in:\n        content = admin_panel()\n    else:\n        content = login_form()\n    return html.div(content)\n</code></pre> <p>If you prefer more compact code, you can use the ternary operator.:</p> <pre><code>@component\ndef my_component():\n    return html.div(admin_panel() if is_logged_in else login_form())\n</code></pre> <p>When you don't need the <code>else</code> branch, you can also use a shorter logical <code>and</code> syntax:</p> <pre><code>@component\ndef my_component():\n    return html.div(is_logged_in and admin_panel())\n</code></pre> <p>All of these approaches also work for conditionally specifying attributes. If you're unfamiliar with some of this Python syntax, you can start by always using <code>if...else</code>.</p>"},{"location":"learn/quick-start/#rendering-lists","title":"Rendering lists","text":"<p>You will rely on Python features like <code>for</code> loop and list comprehension to render lists of components.</p> <p>For example, let's say you have an array of products:</p> <pre><code>products = [\n    {\"title\": \"Cabbage\", \"id\": 1},\n    {\"title\": \"Garlic\", \"id\": 2},\n    {\"title\": \"Apple\", \"id\": 3},\n]\n</code></pre> <p>Inside your component, use list comprehension to transform an array of products into an array of <code>&lt;li&gt;</code> items:</p> <pre><code>list_items = [html.li({\"key\": product[\"id\"]}, product[\"title\"]) for product in products]\n</code></pre> <p>Notice how <code>&lt;li&gt;</code> has a <code>key</code> attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.</p> app.py Run <pre><code>from reactpy import component, html\n\nproducts = [\n    {\"title\": \"Cabbage\", \"is_fruit\": False, \"id\": 1},\n    {\"title\": \"Garlic\", \"is_fruit\": False, \"id\": 2},\n    {\"title\": \"Apple\", \"is_fruit\": True, \"id\": 3},\n]\n\n\n@component\ndef shopping_list():\n    list_items = [\n        html.li(\n            {\n                \"key\": product[\"id\"],\n                \"style\": {\"color\": \"magenta\" if product[\"is_fruit\"] else \"darkgreen\"},\n            },\n            product[\"title\"],\n        )\n        for product in products\n    ]\n\n    return html.ul(list_items)\n</code></pre> <pre><code># TODO\n</code></pre>"},{"location":"learn/quick-start/#responding-to-events","title":"Responding to events","text":"<p>You can respond to events by declaring event handler functions inside your components:</p> <pre><code>@component\ndef my_button():\ndef handle_click(event):\nprint(\"You clicked me!\")\nreturn html.button(\n{\"onClick\": handle_click},\n\"Click me\",\n    )\n</code></pre> <p>Notice how <code>\"onClick\": handle_click</code> has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button.</p>"},{"location":"learn/quick-start/#updating-the-screen","title":"Updating the screen","text":"<p>Often, you'll want your component to \"remember\" some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component.</p> <p>First, import <code>use_state</code> from React:</p> <pre><code>from reactpy import use_state\n</code></pre> <p>Now you can declare a state variable inside your component:</p> <pre><code>@component\ndef my_button():\n    count, set_count = use_state(0)\n    # ...\n</code></pre> <p>You\u2019ll get two things from <code>use_state</code>: the current state (<code>count</code>), and the function that lets you update it (<code>set_count</code>). You can give them any names, but the convention is to write <code>something, set_something = ...</code>.</p> <p>The first time the button is displayed, <code>count</code> will be <code>0</code> because you passed <code>0</code> to <code>use_state()</code>. When you want to change state, call <code>set_count()</code> and pass the new value to it. Clicking this button will increment the counter:</p> <pre><code>@component\ndef my_button():\n    count, set_count = use_state(0)\n\n    def handle_click(event):\nset_count(count + 1)\nreturn html.button({\"onClick\": handle_click}, f\"Clicked {count} times\")\n</code></pre> <p>React will call your component function again. This time, <code>count</code> will be <code>1</code>. Then it will be <code>2</code>. And so on.</p> <p>If you render the same component multiple times, each will get its own state. Click each button separately:</p> app.pystyles.css Run <pre><code>from reactpy import component, html, use_state\n\n\n@component\ndef my_app():\n    return html.div(\n        html.h1(\"Counters that update separately\"),\n        my_button(),\n        my_button(),\n    )\n\n\n@component\ndef my_button():\n    count, set_count = use_state(0)\n\n    def handle_click(event):\n        set_count(count + 1)\n\n    return html.button({\"onClick\": handle_click}, f\"Clicked {count} times\")\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>Notice how each button \"remembers\" its own <code>count</code> state and doesn't affect other buttons.</p>"},{"location":"learn/quick-start/#using-hooks","title":"Using Hooks","text":"<p>Functions starting with <code>use</code> are called Hooks. <code>use_state</code> is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones.</p> <p>Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use <code>use_state</code> in a condition or a loop, extract a new component and put it there.</p>"},{"location":"learn/quick-start/#sharing-data-between-components","title":"Sharing data between components","text":"<p>In the previous example, each <code>my_button</code> had its own independent <code>count</code>, and when each button was clicked, only the <code>count</code> for the button clicked changed:</p> <p>However, often you'll need components to share data and always update together.</p> <p>To make both <code>my_button</code> components display the same <code>count</code> and update together, you need to move the state from the individual buttons \"upwards\" to the closest component containing all of them.</p> <p>In this example, it is <code>my_app</code>.</p> <p>Now when you click either button, the <code>count</code> in <code>my_app</code> will change, which will change both of the counts in <code>my_button</code>. Here's how you can express this in code.</p> <p>First, move the state up from <code>my_button</code> into <code>my_app</code>:</p> <pre><code>@component\ndef my_app():\ncount, set_count = use_state(0)\ndef handle_click(event):\nset_count(count + 1)\nreturn html.div(\n        html.h1(\"Counters that update separately\"),\n        my_button(),\n        my_button(),\n    )\n\n\n@component\ndef my_button():\n# ... we're moving code from here ...\n</code></pre> <p>Then, pass the state down from <code>my_app</code> to each <code>my_button</code>, together with the shared click handler. You can pass information to <code>my_button</code> using props:</p> <pre><code>@component\ndef my_app():\n    count, set_count = use_state(0)\n\n    def handle_click(event):\n        set_count(count + 1)\n\n    return html.div(\n        html.h1(\"Counters that update together\"),\nmy_button(count, handle_click),\nmy_button(count, handle_click),\n)\n</code></pre> <p>The information you pass down like this is called props. Now the <code>my_app</code> component contains the <code>count</code> state and the <code>handle_click</code> event handler, and passes both of them down as props to each of the buttons.</p> <p>Finally, change <code>my_button</code> to read the props you have passed from its parent component:</p> <pre><code>@component\ndef my_button(count, on_click):\n    return html.button({\"onClick\": on_click}, f\"Clicked {count} times\")\n</code></pre> <p>When you click the button, the <code>on_click</code> handler fires. Each button's <code>on_click</code> prop was set to the <code>handle_click</code> function inside <code>my_app</code>, so the code inside of it runs. That code calls <code>set_count(count + 1)</code>, incrementing the <code>count</code> state variable. The new <code>count</code> value is passed as a prop to each button, so they all show the new value. This is called \"lifting state up\". By moving state up, you've shared it between components.</p> app.pystyles.css Run <pre><code>from reactpy import component, html, use_state\n\n\n@component\ndef my_app():\n    count, set_count = use_state(0)\n\n    def handle_click(event):\n        set_count(count + 1)\n\n    return html.div(\n        html.h1(\"Counters that update together\"),\n        my_button(count, handle_click),\n        my_button(count, handle_click),\n    )\n\n\n@component\ndef my_button(count, on_click):\n    return html.button({\"onClick\": on_click}, f\"Clicked {count} times\")\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <pre><code># TODO\n</code></pre>"},{"location":"learn/quick-start/#next-steps","title":"Next Steps","text":"<p>By now, you know the basics of how to write React code!</p> <p>Check out the Tutorial to put them into practice and build your first mini-app with React.</p>"},{"location":"learn/react-developer-tools/","title":"React developer tools","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p> <p>See this issue for more details.</p>"},{"location":"learn/reacting-to-input-with-state/","title":"Reacting to Input with State \ud83d\udea7","text":""},{"location":"learn/reacting-to-input-with-state/#overview","title":"Overview","text":"<p>  React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.  </p> <p>You will learn</p> <ul> <li>How declarative UI programming differs from imperative UI programming</li> <li>How to enumerate the different visual states your component can be in</li> <li>How to trigger the changes between the different visual states from code</li> </ul>"},{"location":"learn/reacting-to-input-with-state/#how-declarative-ui-compares-to-imperative","title":"How declarative UI compares to imperative","text":"<p>When you design UI interactions, you probably think about how the UI changes in response to user actions. Consider a form that lets the user submit an answer:</p> <ul> <li>When you type something into the form, the \"Submit\" button becomes enabled.</li> <li>When you press \"Submit\", both the form and the button become disabled, and a spinner appears.</li> <li>If the network request succeeds, the form gets hidden, and the \"Thank you\" message appears.</li> <li>If the network request fails, an error message appears, and the form becomes enabled again.</li> </ul> <p>In imperative programming, the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here's another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.</p> <p></p> <p>They don't know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It's called imperative because you have to \"command\" each element, from the spinner to the button, telling the computer how to update the UI.</p> <p>In this example of imperative UI programming, the form is built without React. It only uses the browser DOM:</p> <pre><code>async function handleFormSubmit(e) {\ne.preventDefault();\ndisable(textarea);\ndisable(button);\nshow(loadingMessage);\nhide(errorMessage);\ntry {\nawait submitForm(textarea.value);\nshow(successMessage);\nhide(form);\n} catch (err) {\nshow(errorMessage);\nerrorMessage.textContent = err.message;\n} finally {\nhide(loadingMessage);\nenable(textarea);\nenable(button);\n}\n}\n\nfunction handleTextareaChange() {\nif (textarea.value.length === 0) {\ndisable(button);\n} else {\nenable(button);\n}\n}\n\nfunction hide(el) {\nel.style.display = \"none\";\n}\n\nfunction show(el) {\nel.style.display = \"\";\n}\n\nfunction enable(el) {\nel.disabled = false;\n}\n\nfunction disable(el) {\nel.disabled = true;\n}\n\nfunction submitForm(answer) {\n// Pretend it's hitting the network.\nreturn new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; {\nif (answer.toLowerCase() == \"istanbul\") {\nresolve();\n} else {\nreject(new Error(\"Good guess but a wrong answer. Try again!\"));\n}\n}, 1500);\n});\n}\n\nlet form = document.getElementById(\"form\");\nlet textarea = document.getElementById(\"textarea\");\nlet button = document.getElementById(\"button\");\nlet loadingMessage = document.getElementById(\"loading\");\nlet errorMessage = document.getElementById(\"error\");\nlet successMessage = document.getElementById(\"success\");\nform.onsubmit = handleFormSubmit;\ntextarea.oninput = handleTextareaChange;\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <pre><code>&lt;form id=\"form\"&gt;\n    &lt;h2&gt;City quiz&lt;/h2&gt;\n    &lt;p&gt;What city is located on two continents?&lt;/p&gt;\n    &lt;textarea id=\"textarea\"&gt;&lt;/textarea&gt;\n    &lt;br /&gt;\n    &lt;button id=\"button\" disabled&gt;Submit&lt;/button&gt;\n    &lt;p id=\"loading\" style=\"display: none\"&gt;Loading...&lt;/p&gt;\n    &lt;p id=\"error\" style=\"display: none; color: red;\"&gt;&lt;/p&gt;\n&lt;/form&gt;\n&lt;h1 id=\"success\" style=\"display: none\"&gt;That's right!&lt;/h1&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n&lt;/style&gt;\n</code></pre> <p>Manipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven't introduced a bug (for example, forgetting to show or hide something).</p> <p>React was built to solve this problem.</p> <p>In React, you don't directly manipulate the UI--meaning you don't enable, disable, show, or hide components directly. Instead, you declare what you want to show, and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It's the driver's job to get you there, and they might even know some shortcuts you haven't considered!</p> <p></p>"},{"location":"learn/reacting-to-input-with-state/#thinking-about-ui-declaratively","title":"Thinking about UI declaratively","text":"<p>You've seen how to implement a form imperatively above. To better understand how to think in React, you'll walk through reimplementing this UI in React below:</p> <ol> <li>Identify your component's different visual states</li> <li>Determine what triggers those state changes</li> <li>Represent the state in memory using <code>useState</code></li> <li>Remove any non-essential state variables</li> <li>Connect the event handlers to set the state</li> </ol>"},{"location":"learn/reacting-to-input-with-state/#step-1-identify-your-components-different-visual-states","title":"Step 1: Identify your component's different visual states","text":"<p>In computer science, you may hear about a \"state machine\" being in one of several \u201cstates\u201d. If you work with a designer, you may have seen mockups for different \"visual states\". React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.</p> <p>First, you need to visualize all the different \"states\" of the UI the user might see:</p> <ul> <li>Empty: Form has a disabled \"Submit\" button.</li> <li>Typing: Form has an enabled \"Submit\" button.</li> <li>Submitting: Form is completely disabled. Spinner is shown.</li> <li>Success: \"Thank you\" message is shown instead of a form.</li> <li>Error: Same as Typing state, but with an extra error message.</li> </ul> <p>Just like a designer, you'll want to \"mock up\" or create \"mocks\" for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called <code>status</code> with a default value of <code>'empty'</code>:</p> <pre><code>export default function Form({ status = \"empty\" }) {\nif (status === \"success\") {\nreturn &lt;h1&gt;That's right!&lt;/h1&gt;;\n}\nreturn (\n&lt;&gt;\n&lt;h2&gt;City quiz&lt;/h2&gt;\n&lt;p&gt;\nIn which city is there a billboard that turns air into drinkable\nwater?\n&lt;/p&gt;\n&lt;form&gt;\n&lt;textarea /&gt;\n&lt;br /&gt;\n&lt;button&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>You could call that prop anything you like, the naming is not important. Try editing <code>status = 'empty'</code> to <code>status = 'success'</code> to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still \"controlled\" by the <code>status</code> prop:</p> <pre><code>export default function Form({\n// Try 'submitting', 'error', 'success':\nstatus = \"empty\",\n}) {\nif (status === \"success\") {\nreturn &lt;h1&gt;That's right!&lt;/h1&gt;;\n}\nreturn (\n&lt;&gt;\n&lt;h2&gt;City quiz&lt;/h2&gt;\n&lt;p&gt;\nIn which city is there a billboard that turns air into drinkable\nwater?\n&lt;/p&gt;\n&lt;form&gt;\n&lt;textarea disabled={status === \"submitting\"} /&gt;\n&lt;br /&gt;\n&lt;button\ndisabled={status === \"empty\" || status === \"submitting\"}\n&gt;\nSubmit\n&lt;/button&gt;\n{status === \"error\" &amp;&amp; (\n&lt;p className=\"Error\"&gt;\nGood guess but a wrong answer. Try again!\n&lt;/p&gt;\n)}\n&lt;/form&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>.Error {\ncolor: red;\n}\n</code></pre> <p>"},{"location":"learn/reacting-to-input-with-state/#displaying-many-visual-states-at-once","title":"Displaying many visual states at once","text":"<p>If a component has a lot of visual states, it can be convenient to show them all on one page:</p> <pre><code>import Form from \"./Form.js\";\n\nlet statuses = [\"empty\", \"typing\", \"submitting\", \"success\", \"error\"];\n\nexport default function App() {\nreturn (\n&lt;&gt;\n{statuses.map((status) =&gt; (\n&lt;section key={status}&gt;\n&lt;h4&gt;Form ({status}):&lt;/h4&gt;\n&lt;Form status={status} /&gt;\n&lt;/section&gt;\n))}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export default function Form({ status }) {\nif (status === \"success\") {\nreturn &lt;h1&gt;That's right!&lt;/h1&gt;;\n}\nreturn (\n&lt;form&gt;\n&lt;textarea disabled={status === \"submitting\"} /&gt;\n&lt;br /&gt;\n&lt;button disabled={status === \"empty\" || status === \"submitting\"}&gt;\nSubmit\n&lt;/button&gt;\n{status === \"error\" &amp;&amp; (\n&lt;p className=\"Error\"&gt;\nGood guess but a wrong answer. Try again!\n&lt;/p&gt;\n)}\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>section {\nborder-bottom: 1px solid #aaa;\npadding: 20px;\n}\nh4 {\ncolor: #222;\n}\nbody {\nmargin: 0;\n}\n.Error {\ncolor: red;\n}\n</code></pre> <p>Pages like this are often called \"living styleguides\" or \"storybooks\".</p> <p></p>"},{"location":"learn/reacting-to-input-with-state/#step-2-determine-what-triggers-those-state-changes","title":"Step 2: Determine what triggers those state changes","text":"<p>You can trigger state updates in response to two kinds of inputs:</p> <ul> <li>Human inputs, like clicking a button, typing in a field, navigating a link.</li> <li>Computer inputs, like a network response arriving, a timeout completing, an image loading.</li> </ul> <p> </p> <p>In both cases, you must set state variables to update the UI. For the form you're developing, you will need to change state in response to a few different inputs:</p> <ul> <li>Changing the text input (human) should switch it from the Empty state to the Typing state or back, depending on whether the text box is empty or not.</li> <li>Clicking the Submit button (human) should switch it to the Submitting state.</li> <li>Successful network response (computer) should switch it to the Success state.</li> <li>Failed network response (computer) should switch it to the Error state with the matching error message.</li> </ul> <p> <p>Notice that human inputs often require event handlers!</p> <p></p> <p>To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.</p>"},{"location":"learn/reacting-to-input-with-state/#step-3-represent-the-state-in-memory-with-usestate","title":"Step 3: Represent the state in memory with <code>useState</code>","text":"<p>Next you'll need to represent the visual states of your component in memory with <code>useState</code>. Simplicity is key: each piece of state is a \"moving piece\", and you want as few \"moving pieces\" as possible. More complexity leads to more bugs!</p> <p>Start with the state that absolutely must be there. For example, you'll need to store the <code>answer</code> for the input, and the <code>error</code> (if it exists) to store the last error:</p> <pre><code>const [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);\n</code></pre> <p>Then, you'll need a state variable representing which one of the visual states that you want to display. There's usually more than a single way to represent that in memory, so you'll need to experiment with it.</p> <p>If you struggle to think of the best way immediately, start by adding enough state that you're definitely sure that all the possible visual states are covered:</p> <pre><code>const [isEmpty, setIsEmpty] = useState(true);\nconst [isTyping, setIsTyping] = useState(false);\nconst [isSubmitting, setIsSubmitting] = useState(false);\nconst [isSuccess, setIsSuccess] = useState(false);\nconst [isError, setIsError] = useState(false);\n</code></pre> <p>Your first idea likely won't be the best, but that's ok--refactoring state is a part of the process!</p>"},{"location":"learn/reacting-to-input-with-state/#step-4-remove-any-non-essential-state-variables","title":"Step 4: Remove any non-essential state variables","text":"<p>You want to avoid duplication in the state content so you're only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to prevent the cases where the state in memory doesn't represent any valid UI that you'd want a user to see. (For example, you never want to show an error message and disable the input at the same time, or the user won't be able to correct the error!)</p> <p>Here are some questions you can ask about your state variables:</p> <ul> <li>Does this state cause a paradox? For example, <code>isTyping</code> and <code>isSubmitting</code> can't both be <code>true</code>. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the \"impossible\" state, you can combine these into a <code>status</code> that must be one of three values: <code>'typing'</code>, <code>'submitting'</code>, or <code>'success'</code>.</li> <li>Is the same information available in another state variable already? Another paradox: <code>isEmpty</code> and <code>isTyping</code> can't be <code>true</code> at the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can remove <code>isEmpty</code> and instead check <code>answer.length === 0</code>.</li> <li>Can you get the same information from the inverse of another state variable? <code>isError</code> is not needed because you can check <code>error !== null</code> instead.</li> </ul> <p>After this clean-up, you're left with 3 (down from 7!) essential state variables:</p> <pre><code>const [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [status, setStatus] = useState(\"typing\"); // 'typing', 'submitting', or 'success'\n</code></pre> <p>You know they are essential, because you can't remove any of them without breaking the functionality.</p> <p>"},{"location":"learn/reacting-to-input-with-state/#eliminating-impossible-states-with-a-reducer","title":"Eliminating \u201cimpossible\u201d states with a reducer","text":"<p>These three variables are a good enough representation of this form's state. However, there are still some intermediate states that don't fully make sense. For example, a non-null <code>error</code> doesn't make sense when <code>status</code> is <code>'success'</code>. To model the state more precisely, you can extract it into a reducer. Reducers let you unify multiple state variables into a single object and consolidate all the related logic!</p> <p></p>"},{"location":"learn/reacting-to-input-with-state/#step-5-connect-the-event-handlers-to-set-state","title":"Step 5: Connect the event handlers to set state","text":"<p>Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [status, setStatus] = useState(\"typing\");\n\nif (status === \"success\") {\nreturn &lt;h1&gt;That's right!&lt;/h1&gt;;\n    }\n\n    async function handleSubmit(e) {\n        e.preventDefault();\n        setStatus(\"submitting\");\n        try {\n            await submitForm(answer);\n            setStatus(\"success\");\n        } catch (err) {\n            setStatus(\"typing\");\n            setError(err);\n        }\n    }\n\n    function handleTextareaChange(e) {\n        setAnswer(e.target.value);\n    }\n\n    return (\n        &lt;&gt;\n            &lt;h2&gt;City quiz&lt;/h2&gt;\n            &lt;p&gt;\n                In which city is there a billboard that turns air into drinkable\n                water?\n            &lt;/p&gt;\n            &lt;form onSubmit={handleSubmit}&gt;\n                &lt;textarea\n                    value={answer}\n                    onChange={handleTextareaChange}\n                    disabled={status === \"submitting\"}\n                /&gt;\n                &lt;br /&gt;\n                &lt;button\n                    disabled={answer.length === 0 || status === \"submitting\"}\n                &gt;\n                    Submit\n                &lt;/button&gt;\n                {error !== null &amp;&amp; &lt;p className=\"Error\"&gt;{error.message}&lt;/p&gt;}\n            &lt;/form&gt;\n        &lt;/&gt;\n    );\n}\n\nfunction submitForm(answer) {\n    // Pretend it's hitting the network.\nreturn new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; {\nlet shouldError = answer.toLowerCase() !== \"lima\";\nif (shouldError) {\nreject(new Error(\"Good guess but a wrong answer. Try again!\"));\n} else {\nresolve();\n}\n}, 1500);\n});\n}\n</code></pre> <pre><code>.Error {\ncolor: red;\n}\n</code></pre> <p>Although this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.</p> <p> <ul> <li>Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).</li> <li>When developing a component:<ol> <li>Identify all its visual states.</li> <li>Determine the human and computer triggers for state changes.</li> <li>Model the state with <code>useState</code>.</li> <li>Remove non-essential state to avoid bugs and paradoxes.</li> <li>Connect the event handlers to set state.</li> </ol> </li> </ul> <p></p> <p>"},{"location":"learn/reacting-to-input-with-state/#add-and-remove-a-css-class","title":"Add and remove a CSS class","text":"<p>Make it so that clicking on the picture removes the <code>background--active</code> CSS class from the outer <code>&lt;div&gt;</code>, but adds the <code>picture--active</code> class to the <code>&lt;img&gt;</code>. Clicking the background again should restore the original CSS classes.</p> <p>Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.</p> <pre><code>export default function Picture() {\nreturn (\n&lt;div className=\"background background--active\"&gt;\n&lt;img\nclassName=\"picture\"\nalt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\nsrc=\"https://i.imgur.com/5qwVYb1.jpeg\"\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n\n.background {\nwidth: 100vw;\nheight: 100vh;\ndisplay: flex;\njustify-content: center;\nalign-items: center;\nbackground: #eee;\n}\n\n.background--active {\nbackground: #a6b5ff;\n}\n\n.picture {\nwidth: 200px;\nheight: 200px;\nborder-radius: 10px;\n}\n\n.picture--active {\nborder: 5px solid #a6b5ff;\n}\n</code></pre> <p> <p>This component has two visual states: when the image is active, and when the image is inactive:</p> <ul> <li>When the image is active, the CSS classes are <code>background</code> and <code>picture picture--active</code>.</li> <li>When the image is inactive, the CSS classes are <code>background background--active</code> and <code>picture</code>.</li> </ul> <p>A single boolean state variable is enough to remember whether the image is active. The original task was to remove or add CSS classes. However, in React you need to describe what you want to see rather than manipulate the UI elements. So you need to calculate both CSS classes based on the current state. You also need to stop the propagation so that clicking the image doesn't register as a click on the background.</p> <p>Verify that this version works by clicking the image and then outside of it:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Picture() {\nconst [isActive, setIsActive] = useState(false);\n\nlet backgroundClassName = \"background\";\nlet pictureClassName = \"picture\";\nif (isActive) {\npictureClassName += \" picture--active\";\n} else {\nbackgroundClassName += \" background--active\";\n}\n\nreturn (\n&lt;div\nclassName={backgroundClassName}\non_click={() =&gt; setIsActive(false)}\n&gt;\n&lt;img\non_click={(e) =&gt; {\ne.stopPropagation();\nsetIsActive(true);\n}}\nclassName={pictureClassName}\nalt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\nsrc=\"https://i.imgur.com/5qwVYb1.jpeg\"\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n\n.background {\nwidth: 100vw;\nheight: 100vh;\ndisplay: flex;\njustify-content: center;\nalign-items: center;\nbackground: #eee;\n}\n\n.background--active {\nbackground: #a6b5ff;\n}\n\n.picture {\nwidth: 200px;\nheight: 200px;\nborder-radius: 10px;\nborder: 5px solid transparent;\n}\n\n.picture--active {\nborder: 5px solid #a6b5ff;\n}\n</code></pre> <p>Alternatively, you could return two separate chunks of JSX:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Picture() {\nconst [isActive, setIsActive] = useState(false);\nif (isActive) {\nreturn (\n&lt;div className=\"background\" on_click={() =&gt; setIsActive(false)}&gt;\n&lt;img\nclassName=\"picture picture--active\"\nalt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\nsrc=\"https://i.imgur.com/5qwVYb1.jpeg\"\non_click={(e) =&gt; e.stopPropagation()}\n/&gt;\n&lt;/div&gt;\n);\n}\nreturn (\n&lt;div className=\"background background--active\"&gt;\n&lt;img\nclassName=\"picture\"\nalt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\nsrc=\"https://i.imgur.com/5qwVYb1.jpeg\"\non_click={() =&gt; setIsActive(true)}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n\n.background {\nwidth: 100vw;\nheight: 100vh;\ndisplay: flex;\njustify-content: center;\nalign-items: center;\nbackground: #eee;\n}\n\n.background--active {\nbackground: #a6b5ff;\n}\n\n.picture {\nwidth: 200px;\nheight: 200px;\nborder-radius: 10px;\nborder: 5px solid transparent;\n}\n\n.picture--active {\nborder: 5px solid #a6b5ff;\n}\n</code></pre> <p>Keep in mind that if two different JSX chunks describe the same tree, their nesting (first <code>&lt;div&gt;</code> \u2192 first <code>&lt;img&gt;</code>) has to line up. Otherwise, toggling <code>isActive</code> would recreate the whole tree below and reset its state. This is why, if a similar JSX tree gets returned in both cases, it is better to write them as a single piece of JSX.</p> <p></p>"},{"location":"learn/reacting-to-input-with-state/#profile-editor","title":"Profile editor","text":"<p>Here is a small form implemented with plain JavaScript and DOM. Play with it to understand its behavior:</p> <pre><code>function handleFormSubmit(e) {\ne.preventDefault();\nif (editButton.textContent === \"Edit Profile\") {\neditButton.textContent = \"Save Profile\";\nhide(firstNameText);\nhide(lastNameText);\nshow(firstNameInput);\nshow(lastNameInput);\n} else {\neditButton.textContent = \"Edit Profile\";\nhide(firstNameInput);\nhide(lastNameInput);\nshow(firstNameText);\nshow(lastNameText);\n}\n}\n\nfunction handleFirstNameChange() {\nfirstNameText.textContent = firstNameInput.value;\nhelloText.textContent =\n\"Hello \" + firstNameInput.value + \" \" + lastNameInput.value + \"!\";\n}\n\nfunction handleLastNameChange() {\nlastNameText.textContent = lastNameInput.value;\nhelloText.textContent =\n\"Hello \" + firstNameInput.value + \" \" + lastNameInput.value + \"!\";\n}\n\nfunction hide(el) {\nel.style.display = \"none\";\n}\n\nfunction show(el) {\nel.style.display = \"\";\n}\n\nlet form = document.getElementById(\"form\");\nlet editButton = document.getElementById(\"editButton\");\nlet firstNameInput = document.getElementById(\"firstNameInput\");\nlet firstNameText = document.getElementById(\"firstNameText\");\nlet lastNameInput = document.getElementById(\"lastNameInput\");\nlet lastNameText = document.getElementById(\"lastNameText\");\nlet helloText = document.getElementById(\"helloText\");\nform.onsubmit = handleFormSubmit;\nfirstNameInput.oninput = handleFirstNameChange;\nlastNameInput.oninput = handleLastNameChange;\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <pre><code>&lt;form id=\"form\"&gt;\n    &lt;label&gt;\n        First name:\n        &lt;b id=\"firstNameText\"&gt;Jane&lt;/b&gt;\n        &lt;input id=\"firstNameInput\" value=\"Jane\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n        Last name:\n        &lt;b id=\"lastNameText\"&gt;Jacobs&lt;/b&gt;\n        &lt;input id=\"lastNameInput\" value=\"Jacobs\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;button type=\"submit\" id=\"editButton\"&gt;Edit Profile&lt;/button&gt;\n    &lt;p&gt;&lt;i id=\"helloText\"&gt;Hello, Jane Jacobs!&lt;/i&gt;&lt;/p&gt;\n&lt;/form&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\nlabel {\ndisplay: block;\nmargin-bottom: 20px;\n}\n&lt;/style&gt;\n</code></pre> <p>This form switches between two modes: in the editing mode, you see the inputs, and in the viewing mode, you only see the result. The button label changes between \"Edit\" and \"Save\" depending on the mode you're in. When you change the inputs, the welcome message at the bottom updates in real time.</p> <p>Your task is to reimplement it in React in the sandbox below. For your convenience, the markup was already converted to JSX, but you'll need to make it show and hide the inputs like the original does.</p> <p>Make sure that it updates the text at the bottom, too!</p> <pre><code>export default function EditProfile() {\nreturn (\n&lt;form&gt;\n&lt;label&gt;\nFirst name: &lt;b&gt;Jane&lt;/b&gt;\n&lt;input /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name: &lt;b&gt;Jacobs&lt;/b&gt;\n&lt;input /&gt;\n&lt;/label&gt;\n&lt;button type=\"submit\"&gt;Edit Profile&lt;/button&gt;\n&lt;p&gt;\n&lt;i&gt;Hello, Jane Jacobs!&lt;/i&gt;\n&lt;/p&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p> <p>You will need two state variables to hold the input values: <code>firstName</code> and <code>lastName</code>. You're also going to need an <code>isEditing</code> state variable that holds whether to display the inputs or not. You should not need a <code>fullName</code> variable because the full name can always be calculated from the <code>firstName</code> and the <code>lastName</code>.</p> <p>Finally, you should use conditional rendering to show or hide the inputs depending on <code>isEditing</code>.</p> <pre><code>import { useState } from \"react\";\n\nexport default function EditProfile() {\nconst [isEditing, setIsEditing] = useState(false);\nconst [firstName, setFirstName] = useState(\"Jane\");\nconst [lastName, setLastName] = useState(\"Jacobs\");\n\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nsetIsEditing(!isEditing);\n}}\n&gt;\n&lt;label&gt;\nFirst name:{\" \"}\n{isEditing ? (\n&lt;input\nvalue={firstName}\nonChange={(e) =&gt; {\nsetFirstName(e.target.value);\n}}\n/&gt;\n) : (\n&lt;b&gt;{firstName}&lt;/b&gt;\n)}\n&lt;/label&gt;\n&lt;label&gt;\nLast name:{\" \"}\n{isEditing ? (\n&lt;input\nvalue={lastName}\nonChange={(e) =&gt; {\nsetLastName(e.target.value);\n}}\n/&gt;\n) : (\n&lt;b&gt;{lastName}&lt;/b&gt;\n)}\n&lt;/label&gt;\n&lt;button type=\"submit\"&gt;{isEditing ? \"Save\" : \"Edit\"} Profile&lt;/button&gt;\n&lt;p&gt;\n&lt;i&gt;\nHello, {firstName} {lastName}!\n&lt;/i&gt;\n&lt;/p&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p>Compare this solution to the original imperative code. How are they different?</p> <p></p>"},{"location":"learn/reacting-to-input-with-state/#refactor-the-imperative-solution-without-react","title":"Refactor the imperative solution without React","text":"<p>Here is the original sandbox from the previous challenge, written imperatively without React:</p> <pre><code>function handleFormSubmit(e) {\ne.preventDefault();\nif (editButton.textContent === \"Edit Profile\") {\neditButton.textContent = \"Save Profile\";\nhide(firstNameText);\nhide(lastNameText);\nshow(firstNameInput);\nshow(lastNameInput);\n} else {\neditButton.textContent = \"Edit Profile\";\nhide(firstNameInput);\nhide(lastNameInput);\nshow(firstNameText);\nshow(lastNameText);\n}\n}\n\nfunction handleFirstNameChange() {\nfirstNameText.textContent = firstNameInput.value;\nhelloText.textContent =\n\"Hello \" + firstNameInput.value + \" \" + lastNameInput.value + \"!\";\n}\n\nfunction handleLastNameChange() {\nlastNameText.textContent = lastNameInput.value;\nhelloText.textContent =\n\"Hello \" + firstNameInput.value + \" \" + lastNameInput.value + \"!\";\n}\n\nfunction hide(el) {\nel.style.display = \"none\";\n}\n\nfunction show(el) {\nel.style.display = \"\";\n}\n\nlet form = document.getElementById(\"form\");\nlet editButton = document.getElementById(\"editButton\");\nlet firstNameInput = document.getElementById(\"firstNameInput\");\nlet firstNameText = document.getElementById(\"firstNameText\");\nlet lastNameInput = document.getElementById(\"lastNameInput\");\nlet lastNameText = document.getElementById(\"lastNameText\");\nlet helloText = document.getElementById(\"helloText\");\nform.onsubmit = handleFormSubmit;\nfirstNameInput.oninput = handleFirstNameChange;\nlastNameInput.oninput = handleLastNameChange;\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <pre><code>&lt;form id=\"form\"&gt;\n    &lt;label&gt;\n        First name:\n        &lt;b id=\"firstNameText\"&gt;Jane&lt;/b&gt;\n        &lt;input id=\"firstNameInput\" value=\"Jane\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n        Last name:\n        &lt;b id=\"lastNameText\"&gt;Jacobs&lt;/b&gt;\n        &lt;input id=\"lastNameInput\" value=\"Jacobs\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;button type=\"submit\" id=\"editButton\"&gt;Edit Profile&lt;/button&gt;\n    &lt;p&gt;&lt;i id=\"helloText\"&gt;Hello, Jane Jacobs!&lt;/i&gt;&lt;/p&gt;\n&lt;/form&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\nlabel {\ndisplay: block;\nmargin-bottom: 20px;\n}\n&lt;/style&gt;\n</code></pre> <p>Imagine React didn't exist. Can you refactor this code in a way that makes the logic less fragile and more similar to the React version? What would it look like if the state was explicit, like in React?</p> <p>If you're struggling to think where to start, the stub below already has most of the structure in place. If you start here, fill in the missing logic in the <code>updateDOM</code> function. (Refer to the original code where needed.)</p> <pre><code>let firstName = \"Jane\";\nlet lastName = \"Jacobs\";\nlet isEditing = false;\n\nfunction handleFormSubmit(e) {\ne.preventDefault();\nsetIsEditing(!isEditing);\n}\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\n}\n\nfunction setFirstName(value) {\nfirstName = value;\nupdateDOM();\n}\n\nfunction setLastName(value) {\nlastName = value;\nupdateDOM();\n}\n\nfunction setIsEditing(value) {\nisEditing = value;\nupdateDOM();\n}\n\nfunction updateDOM() {\nif (isEditing) {\neditButton.textContent = \"Save Profile\";\n// TODO: show inputs, hide content\n} else {\neditButton.textContent = \"Edit Profile\";\n// TODO: hide inputs, show content\n}\n// TODO: update text labels\n}\n\nfunction hide(el) {\nel.style.display = \"none\";\n}\n\nfunction show(el) {\nel.style.display = \"\";\n}\n\nlet form = document.getElementById(\"form\");\nlet editButton = document.getElementById(\"editButton\");\nlet firstNameInput = document.getElementById(\"firstNameInput\");\nlet firstNameText = document.getElementById(\"firstNameText\");\nlet lastNameInput = document.getElementById(\"lastNameInput\");\nlet lastNameText = document.getElementById(\"lastNameText\");\nlet helloText = document.getElementById(\"helloText\");\nform.onsubmit = handleFormSubmit;\nfirstNameInput.oninput = handleFirstNameChange;\nlastNameInput.oninput = handleLastNameChange;\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <pre><code>&lt;form id=\"form\"&gt;\n    &lt;label&gt;\n        First name:\n        &lt;b id=\"firstNameText\"&gt;Jane&lt;/b&gt;\n        &lt;input id=\"firstNameInput\" value=\"Jane\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n        Last name:\n        &lt;b id=\"lastNameText\"&gt;Jacobs&lt;/b&gt;\n        &lt;input id=\"lastNameInput\" value=\"Jacobs\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;button type=\"submit\" id=\"editButton\"&gt;Edit Profile&lt;/button&gt;\n    &lt;p&gt;&lt;i id=\"helloText\"&gt;Hello, Jane Jacobs!&lt;/i&gt;&lt;/p&gt;\n&lt;/form&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\nlabel {\ndisplay: block;\nmargin-bottom: 20px;\n}\n&lt;/style&gt;\n</code></pre> <p> <p>The missing logic included toggling the display of inputs and content, and updating the labels:</p> <pre><code>let firstName = \"Jane\";\nlet lastName = \"Jacobs\";\nlet isEditing = false;\n\nfunction handleFormSubmit(e) {\ne.preventDefault();\nsetIsEditing(!isEditing);\n}\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\n}\n\nfunction setFirstName(value) {\nfirstName = value;\nupdateDOM();\n}\n\nfunction setLastName(value) {\nlastName = value;\nupdateDOM();\n}\n\nfunction setIsEditing(value) {\nisEditing = value;\nupdateDOM();\n}\n\nfunction updateDOM() {\nif (isEditing) {\neditButton.textContent = \"Save Profile\";\nhide(firstNameText);\nhide(lastNameText);\nshow(firstNameInput);\nshow(lastNameInput);\n} else {\neditButton.textContent = \"Edit Profile\";\nhide(firstNameInput);\nhide(lastNameInput);\nshow(firstNameText);\nshow(lastNameText);\n}\nfirstNameText.textContent = firstName;\nlastNameText.textContent = lastName;\nhelloText.textContent = \"Hello \" + firstName + \" \" + lastName + \"!\";\n}\n\nfunction hide(el) {\nel.style.display = \"none\";\n}\n\nfunction show(el) {\nel.style.display = \"\";\n}\n\nlet form = document.getElementById(\"form\");\nlet editButton = document.getElementById(\"editButton\");\nlet firstNameInput = document.getElementById(\"firstNameInput\");\nlet firstNameText = document.getElementById(\"firstNameText\");\nlet lastNameInput = document.getElementById(\"lastNameInput\");\nlet lastNameText = document.getElementById(\"lastNameText\");\nlet helloText = document.getElementById(\"helloText\");\nform.onsubmit = handleFormSubmit;\nfirstNameInput.oninput = handleFirstNameChange;\nlastNameInput.oninput = handleLastNameChange;\n</code></pre> <pre><code>{\n\"hardReloadOnChange\": true\n}\n</code></pre> <pre><code>&lt;form id=\"form\"&gt;\n    &lt;label&gt;\n        First name:\n        &lt;b id=\"firstNameText\"&gt;Jane&lt;/b&gt;\n        &lt;input id=\"firstNameInput\" value=\"Jane\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n        Last name:\n        &lt;b id=\"lastNameText\"&gt;Jacobs&lt;/b&gt;\n        &lt;input id=\"lastNameInput\" value=\"Jacobs\" style=\"display: none\" /&gt;\n    &lt;/label&gt;\n    &lt;button type=\"submit\" id=\"editButton\"&gt;Edit Profile&lt;/button&gt;\n    &lt;p&gt;&lt;i id=\"helloText\"&gt;Hello, Jane Jacobs!&lt;/i&gt;&lt;/p&gt;\n&lt;/form&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\nlabel {\ndisplay: block;\nmargin-bottom: 20px;\n}\n&lt;/style&gt;\n</code></pre> <p>The <code>updateDOM</code> function you wrote shows what React does under the hood when you set the state. (However, React also avoids touching the DOM for properties that have not changed since the last time they were set.)</p> <p></p> <p></p>"},{"location":"learn/referencing-values-with-refs/","title":"Referencing Values with Refs \ud83d\udea7","text":""},{"location":"learn/referencing-values-with-refs/#overview","title":"Overview","text":"<p>  When you want a component to \"remember\" some information, but you don't want that information to trigger new renders, you can use a ref.  </p> <p>You will learn</p> <ul> <li>How to add a ref to your component</li> <li>How to update a ref's value</li> <li>How refs are different from state</li> <li>How to use refs safely</li> </ul>"},{"location":"learn/referencing-values-with-refs/#adding-a-ref-to-your-component","title":"Adding a ref to your component","text":"<p>You can add a ref to your component by importing the <code>useRef</code> Hook from React:</p> <pre><code>import { useRef } from \"react\";\n</code></pre> <p>Inside your component, call the <code>useRef</code> Hook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value <code>0</code>:</p> <pre><code>const ref = useRef(0);\n</code></pre> <p><code>useRef</code> returns an object like this:</p> <pre><code>{\ncurrent: 0; // The value you passed to useRef\n}\n</code></pre> <p></p> <p>You can access the current value of that ref through the <code>ref.current</code> property. This value is intentionally mutable, meaning you can both read and write to it. It's like a secret pocket of your component that React doesn't track. (This is what makes it an \"escape hatch\" from React's one-way data flow--more on that below!)</p> <p>Here, a button will increment <code>ref.current</code> on every click:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Counter() {\nlet ref = useRef(0);\n\nfunction handleClick() {\nref.current = ref.current + 1;\nalert(\"You clicked \" + ref.current + \" times!\");\n}\n\nreturn &lt;button on_click={handleClick}&gt;Click me!&lt;/button&gt;;\n}\n</code></pre> <p>The ref points to a number, but, like state, you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with the <code>current</code> property that you can read and modify.</p> <p>Note that the component doesn't re-render with every increment. Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!</p>"},{"location":"learn/referencing-values-with-refs/#example-building-a-stopwatch","title":"Example: building a stopwatch","text":"<p>You can combine refs and state in a single component. For example, let's make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed \"Start\", you will need to keep track of when the Start button was pressed and what the current time is. This information is used for rendering, so you'll keep it in state:</p> <pre><code>const [startTime, setStartTime] = useState(null);\nconst [now, setNow] = useState(null);\n</code></pre> <p>When the user presses \"Start\", you'll use <code>setInterval</code> in order to update the time every 10 milliseconds:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Stopwatch() {\nconst [startTime, setStartTime] = useState(null);\nconst [now, setNow] = useState(null);\n\nfunction handleStart() {\n// Start counting.\nsetStartTime(Date.now());\nsetNow(Date.now());\n\nsetInterval(() =&gt; {\n// Update the current time every 10ms.\nsetNow(Date.now());\n}, 10);\n}\n\nlet secondsPassed = 0;\nif (startTime != null &amp;&amp; now != null) {\nsecondsPassed = (now - startTime) / 1000;\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Time passed: {secondsPassed.toFixed(3)}&lt;/h1&gt;\n&lt;button on_click={handleStart}&gt;Start&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>When the \"Stop\" button is pressed, you need to cancel the existing interval so that it stops updating the <code>now</code> state variable. You can do this by calling <code>clearInterval</code>, but you need to give it the interval ID that was previously returned by the <code>setInterval</code> call when the user pressed Start. You need to keep the interval ID somewhere. Since the interval ID is not used for rendering, you can keep it in a ref:</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Stopwatch() {\nconst [startTime, setStartTime] = useState(null);\nconst [now, setNow] = useState(null);\nconst intervalRef = useRef(null);\n\nfunction handleStart() {\nsetStartTime(Date.now());\nsetNow(Date.now());\n\nclearInterval(intervalRef.current);\nintervalRef.current = setInterval(() =&gt; {\nsetNow(Date.now());\n}, 10);\n}\n\nfunction handleStop() {\nclearInterval(intervalRef.current);\n}\n\nlet secondsPassed = 0;\nif (startTime != null &amp;&amp; now != null) {\nsecondsPassed = (now - startTime) / 1000;\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Time passed: {secondsPassed.toFixed(3)}&lt;/h1&gt;\n&lt;button on_click={handleStart}&gt;Start&lt;/button&gt;\n&lt;button on_click={handleStop}&gt;Stop&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>When a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn't require a re-render, using a ref may be more efficient.</p>"},{"location":"learn/referencing-values-with-refs/#differences-between-refs-and-state","title":"Differences between refs and state","text":"<p>Perhaps you're thinking refs seem less \"strict\" than state\u2014you can mutate them instead of always having to use a state setting function, for instance. But in most cases, you'll want to use state. Refs are an \"escape hatch\" you won't need often. Here's how state and refs compare:</p> refs state <code>useRef(initialValue)</code> returns <code>{ current: initialValue }</code> <code>useState(initialValue)</code> returns the current value of a state variable and a state setter function ( <code>[value, setValue]</code>) Doesn't trigger re-render when you change it. Triggers re-render when you change it. Mutable\u2014you can modify and update <code>current</code>'s value outside of the rendering process. \"Immutable\"\u2014you must use the state setting function to modify state variables to queue a re-render. You shouldn't read (or write) the <code>current</code> value during rendering. You can read state at any time. However, each render has its own snapshot of state which does not change. <p>Here is a counter button that's implemented with state:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nfunction handleClick() {\nsetCount(count + 1);\n}\n\nreturn &lt;button on_click={handleClick}&gt;You clicked {count} times&lt;/button&gt;;\n}\n</code></pre> <p>Because the <code>count</code> value is displayed, it makes sense to use a state value for it. When the counter's value is set with <code>setCount()</code>, React re-renders the component and the screen updates to reflect the new count.</p> <p>If you tried to implement this with a ref, React would never re-render the component, so you'd never see the count change! See how clicking this button does not update its text:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Counter() {\nlet countRef = useRef(0);\n\nfunction handleClick() {\n// This doesn't re-render the component!\ncountRef.current = countRef.current + 1;\n}\n\nreturn (\n&lt;button on_click={handleClick}&gt;\nYou clicked {countRef.current} times\n&lt;/button&gt;\n);\n}\n</code></pre> <p>This is why reading <code>ref.current</code> during render leads to unreliable code. If you need that, use state instead.</p> <p>"},{"location":"learn/referencing-values-with-refs/#how-does-useref-work-inside","title":"How does useRef work inside?","text":"<p>Although both <code>useState</code> and <code>useRef</code> are provided by React, in principle <code>useRef</code> could be implemented on top of <code>useState</code>. You can imagine that inside of React, <code>useRef</code> is implemented like this:</p> <pre><code>// Inside of React\nfunction useRef(initialValue) {\nconst [ref, unused] = useState({ current: initialValue });\nreturn ref;\n}\n</code></pre> <p>During the first render, <code>useRef</code> returns <code>{ current: initialValue }</code>. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary because <code>useRef</code> always needs to return the same object!</p> <p>React provides a built-in version of <code>useRef</code> because it is common enough in practice. But you can think of it as a regular state variable without a setter. If you're familiar with object-oriented programming, refs might remind you of instance fields--but instead of <code>this.something</code> you write <code>somethingRef.current</code>.</p> <p></p>"},{"location":"learn/referencing-values-with-refs/#when-to-use-refs","title":"When to use refs","text":"<p>Typically, you will use a ref when your component needs to \"step outside\" React and communicate with external APIs\u2014often a browser API that won't impact the appearance of the component. Here are a few of these rare situations:</p> <ul> <li>Storing timeout IDs</li> <li>Storing and manipulating DOM elements, which we cover on the next page</li> <li>Storing other objects that aren't necessary to calculate the JSX.</li> </ul> <p>If your component needs to store some value, but it doesn't impact the rendering logic, choose refs.</p>"},{"location":"learn/referencing-values-with-refs/#best-practices-for-refs","title":"Best practices for refs","text":"<p>Following these principles will make your components more predictable:</p> <ul> <li>Treat refs as an escape hatch. Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.</li> <li>Don't read or write <code>ref.current</code> during rendering. If some information is needed during rendering, use state instead. Since React doesn't know when <code>ref.current</code> changes, even reading it while rendering makes your component's behavior difficult to predict. (The only exception to this is code like <code>if (!ref.current) ref.current = new Thing()</code> which only sets the ref once during the first render.)</li> </ul> <p>Limitations of React state don't apply to refs. For example, state acts like a snapshot for every render and doesn't update synchronously. But when you mutate the current value of a ref, it changes immediately:</p> <pre><code>ref.current = 5;\nconsole.log(ref.current); // 5\n</code></pre> <p>This is because the ref itself is a regular JavaScript object, and so it behaves like one.</p> <p>You also don't need to worry about avoiding mutation when you work with a ref. As long as the object you're mutating isn't used for rendering, React doesn't care what you do with the ref or its contents.</p>"},{"location":"learn/referencing-values-with-refs/#refs-and-the-dom","title":"Refs and the DOM","text":"<p>You can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to a <code>ref</code> attribute in JSX, like <code>&lt;div ref={myRef}&gt;</code>, React will put the corresponding DOM element into <code>myRef.current</code>. You can read more about this in Manipulating the DOM with Refs.</p> <p> <ul> <li>Refs are an escape hatch to hold onto values that aren't used for rendering. You won't need them often.</li> <li>A ref is a plain JavaScript object with a single property called <code>current</code>, which you can read or set.</li> <li>You can ask React to give you a ref by calling the <code>useRef</code> Hook.</li> <li>Like state, refs let you retain information between re-renders of a component.</li> <li>Unlike state, setting the ref's <code>current</code> value does not trigger a re-render.</li> <li>Don't read or write <code>ref.current</code> during rendering. This makes your component hard to predict.</li> </ul> <p></p> <p>"},{"location":"learn/referencing-values-with-refs/#fix-a-broken-chat-input","title":"Fix a broken chat input","text":"<p>Type a message and click \"Send\". You will notice there is a three second delay before you see the \"Sent!\" alert. During this delay, you can see an \"Undo\" button. Click it. This \"Undo\" button is supposed to stop the \"Sent!\" message from appearing. It does this by calling <code>clearTimeout</code> for the timeout ID saved during <code>handleSend</code>. However, even after \"Undo\" is clicked, the \"Sent!\" message still appears. Find why it doesn't work, and fix it.</p> <p> <p>Regular variables like <code>let timeoutID</code> don't \"survive\" between re-renders because every render runs your component (and initializes its variables) from scratch. Should you keep the timeout ID somewhere else?</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function Chat() {\nconst [text, setText] = useState(\"\");\nconst [isSending, setIsSending] = useState(false);\nlet timeoutID = null;\n\nfunction handleSend() {\nsetIsSending(true);\ntimeoutID = setTimeout(() =&gt; {\nalert(\"Sent!\");\nsetIsSending(false);\n}, 3000);\n}\n\nfunction handleUndo() {\nsetIsSending(false);\nclearTimeout(timeoutID);\n}\n\nreturn (\n&lt;&gt;\n&lt;input\ndisabled={isSending}\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button disabled={isSending} on_click={handleSend}&gt;\n{isSending ? \"Sending...\" : \"Send\"}\n&lt;/button&gt;\n{isSending &amp;&amp; &lt;button on_click={handleUndo}&gt;Undo&lt;/button&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <p> <p>Whenever your component re-renders (such as when you set state), all local variables get initialized from scratch. This is why you can't save the timeout ID in a local variable like <code>timeoutID</code> and then expect another event handler to \"see\" it in the future. Instead, store it in a ref, which React will preserve between renders.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Chat() {\nconst [text, setText] = useState(\"\");\nconst [isSending, setIsSending] = useState(false);\nconst timeoutRef = useRef(null);\n\nfunction handleSend() {\nsetIsSending(true);\ntimeoutRef.current = setTimeout(() =&gt; {\nalert(\"Sent!\");\nsetIsSending(false);\n}, 3000);\n}\n\nfunction handleUndo() {\nsetIsSending(false);\nclearTimeout(timeoutRef.current);\n}\n\nreturn (\n&lt;&gt;\n&lt;input\ndisabled={isSending}\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button disabled={isSending} on_click={handleSend}&gt;\n{isSending ? \"Sending...\" : \"Send\"}\n&lt;/button&gt;\n{isSending &amp;&amp; &lt;button on_click={handleUndo}&gt;Undo&lt;/button&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"learn/referencing-values-with-refs/#fix-a-component-failing-to-re-render","title":"Fix a component failing to re-render","text":"<p>This button is supposed to toggle between showing \"On\" and \"Off\". However, it always shows \"Off\". What is wrong with this code? Fix it.</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Toggle() {\nconst isOnRef = useRef(false);\n\nreturn (\n&lt;button\non_click={() =&gt; {\nisOnRef.current = !isOnRef.current;\n}}\n&gt;\n{isOnRef.current ? \"On\" : \"Off\"}\n&lt;/button&gt;\n);\n}\n</code></pre> <p> <p>In this example, the current value of a ref is used to calculate the rendering output: <code>{isOnRef.current ? 'On' : 'Off'}</code>. This is a sign that this information should not be in a ref, and should have instead been put in state. To fix it, remove the ref and use state instead:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Toggle() {\nconst [isOn, setIsOn] = useState(false);\n\nreturn (\n&lt;button\non_click={() =&gt; {\nsetIsOn(!isOn);\n}}\n&gt;\n{isOn ? \"On\" : \"Off\"}\n&lt;/button&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"learn/referencing-values-with-refs/#fix-debouncing","title":"Fix debouncing","text":"<p>In this example, all button click handlers are \"debounced\". To see what this means, press one of the buttons. Notice how the message appears a second later. If you press the button while waiting for the message, the timer will reset. So if you keep clicking the same button fast many times, the message won't appear until a second after you stop clicking. Debouncing lets you delay some action until the user \"stops doing things\".</p> <p>This example works, but not quite as intended. The buttons are not independent. To see the problem, click one of the buttons, and then immediately click another button. You'd expect that after a delay, you would see both button's messages. But only the last button's message shows up. The first button's message gets lost.</p> <p>Why are the buttons interfering with each other? Find and fix the issue.</p> <p> <p>The last timeout ID variable is shared between all <code>DebouncedButton</code> components. This is why clicking one button resets another button's timeout. Can you store a separate timeout ID for each button?</p> <p></p> <pre><code>let timeoutID;\n\nfunction DebouncedButton({ on_click, children }) {\nreturn (\n&lt;button\non_click={() =&gt; {\nclearTimeout(timeoutID);\ntimeoutID = setTimeout(() =&gt; {\non_click();\n}, 1000);\n}}\n&gt;\n{children}\n&lt;/button&gt;\n);\n}\n\nexport default function Dashboard() {\nreturn (\n&lt;&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Spaceship launched!\")}&gt;\nLaunch the spaceship\n&lt;/DebouncedButton&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Soup boiled!\")}&gt;\nBoil the soup\n&lt;/DebouncedButton&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Lullaby sung!\")}&gt;\nSing a lullaby\n&lt;/DebouncedButton&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin: 10px;\n}\n</code></pre> <p> <p>A variable like <code>timeoutID</code> is shared between all components. This is why clicking on the second button resets the first button's pending timeout. To fix this, you can keep timeout in a ref. Each button will get its own ref, so they won't conflict with each other. Notice how clicking two buttons fast will show both messages.</p> <pre><code>import { useRef } from \"react\";\n\nfunction DebouncedButton({ on_click, children }) {\nconst timeoutRef = useRef(null);\nreturn (\n&lt;button\non_click={() =&gt; {\nclearTimeout(timeoutRef.current);\ntimeoutRef.current = setTimeout(() =&gt; {\non_click();\n}, 1000);\n}}\n&gt;\n{children}\n&lt;/button&gt;\n);\n}\n\nexport default function Dashboard() {\nreturn (\n&lt;&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Spaceship launched!\")}&gt;\nLaunch the spaceship\n&lt;/DebouncedButton&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Soup boiled!\")}&gt;\nBoil the soup\n&lt;/DebouncedButton&gt;\n&lt;DebouncedButton on_click={() =&gt; alert(\"Lullaby sung!\")}&gt;\nSing a lullaby\n&lt;/DebouncedButton&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/referencing-values-with-refs/#read-the-latest-state","title":"Read the latest state","text":"<p>In this example, after you press \"Send\", there is a small delay before the message is shown. Type \"hello\", press Send, and then quickly edit the input again. Despite your edits, the alert would still show \"hello\" (which was the value of state at the time the button was clicked).</p> <p>Usually, this behavior is what you want in an app. However, there may be occasional cases where you want some asynchronous code to read the latest version of some state. Can you think of a way to make the alert show the current input text rather than what it was at the time of the click?</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Chat() {\nconst [text, setText] = useState(\"\");\n\nfunction handleSend() {\nsetTimeout(() =&gt; {\nalert(\"Sending: \" + text);\n}, 3000);\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleSend}&gt;Send&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p> <p>State works like a snapshot, so you can't read the latest state from an asynchronous operation like a timeout. However, you can keep the latest input text in a ref. A ref is mutable, so you can read the <code>current</code> property at any time. Since the current text is also used for rendering, in this example, you will need both a state variable (for rendering), and a ref (to read it in the timeout). You will need to update the current ref value manually.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Chat() {\nconst [text, setText] = useState(\"\");\nconst textRef = useRef(text);\n\nfunction handleChange(e) {\nsetText(e.target.value);\ntextRef.current = e.target.value;\n}\n\nfunction handleSend() {\nsetTimeout(() =&gt; {\nalert(\"Sending: \" + textRef.current);\n}, 3000);\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={handleChange} /&gt;\n&lt;button on_click={handleSend}&gt;Send&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/removing-effect-dependencies/","title":"Removing Effect Dependencies \ud83d\udea7","text":""},{"location":"learn/removing-effect-dependencies/#overview","title":"Overview","text":"<p>  When you write an Effect, the linter will verify that you've included every reactive value (like props and state) that the Effect reads in the list of your Effect's dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.  </p> <p>You will learn</p> <ul> <li>How to fix infinite Effect dependency loops</li> <li>What to do when you want to remove a dependency</li> <li>How to read a value from your Effect without \"reacting\" to it</li> <li>How and why to avoid object and function dependencies</li> <li>Why suppressing the dependency linter is dangerous, and what to do instead</li> </ul>"},{"location":"learn/removing-effect-dependencies/#dependencies-should-match-the-code","title":"Dependencies should match the code","text":"<p>When you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing:</p> <pre><code>const serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n// ...\n}\n</code></pre> <p>Then, if you leave the Effect dependencies empty (<code>[]</code>), the linter will suggest the correct dependencies:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // &lt;-- Fix the mistake here!\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Fill them in according to what the linter says:</p> <pre><code>function ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Effects \"react\" to reactive values. Since <code>roomId</code> is a reactive value (it can change due to a re-render), the linter verifies that you've specified it as a dependency. If <code>roomId</code> receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and \"reacts\" to the dropdown:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre>"},{"location":"learn/removing-effect-dependencies/#to-remove-a-dependency-prove-that-its-not-a-dependency","title":"To remove a dependency, prove that it's not a dependency","text":"<p>Notice that you can't \"choose\" the dependencies of your Effect. Every reactive value used by your Effect's code must be declared in your dependency list. The dependency list is determined by the surrounding code:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\n// This is a reactive value\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 So you must specify that reactive value as a dependency of your Effect\n// ...\n}\n</code></pre> <p>Reactive values include props and all variables and functions declared directly inside of your component. Since <code>roomId</code> is a reactive value, you can't remove it from the dependency list. The linter wouldn't allow it:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \ud83d\udd34 React Hook useEffect has a missing dependency: 'roomId'\n// ...\n}\n</code></pre> <p>And the linter would be right! Since <code>roomId</code> may change over time, this would introduce a bug in your code.</p> <p>To remove a dependency, \"prove\" to the linter that it doesn't need to be a dependency. For example, you can move <code>roomId</code> out of your component to prove that it's not reactive and won't change on re-renders:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\nconst roomId = \"music\"; // Not a reactive value anymore\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Now that <code>roomId</code> is not a reactive value (and can't change on a re-render), it doesn't need to be a dependency:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\nconst roomId = \"music\";\n\nexport default function ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []);\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>This is why you could now specify an empty (<code>[]</code>) dependency list. Your Effect really doesn't depend on any reactive value anymore, so it really doesn't need to re-run when any of the component's props or state change.</p>"},{"location":"learn/removing-effect-dependencies/#to-change-the-dependencies-change-the-code","title":"To change the dependencies, change the code","text":"<p>You might have noticed a pattern in your workflow:</p> <ol> <li>First, you change the code of your Effect or how your reactive values are declared.</li> <li>Then, you follow the linter and adjust the dependencies to match the code you have changed.</li> <li>If you're not happy with the list of dependencies, you go back to the first step (and change the code again).</li> </ol> <p>The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effect's code. You don't choose what to put on that list. The list describes your code. To change the dependency list, change the code.</p> <p>This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to \"find\" the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.</p> <p> <p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p> <pre><code>useEffect(() =&gt; {\n// ...\n// \ud83d\udd34 Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}, []);\n</code></pre> <p>When dependencies don't match the code, there is a very high risk of introducing bugs. By suppressing the linter, you \"lie\" to React about the values your Effect depends on.</p> <p>Instead, use the techniques below.</p> <p></p> <p>"},{"location":"learn/removing-effect-dependencies/#why-is-suppressing-the-dependency-linter-so-dangerous","title":"Why is suppressing the dependency linter so dangerous?","text":"<p>Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here's one example:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\n\nfunction onTick() {\nsetCount(count + increment);\n}\n\nuseEffect(() =&gt; {\nconst id = setInterval(onTick, 1000);\nreturn () =&gt; clearInterval(id);\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nEvery second, increment by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p>Let's say that you wanted to run the Effect \"only on mount\". You've read that empty (<code>[]</code>) dependencies do that, so you've decided to ignore the linter, and forcefully specified <code>[]</code> as the dependencies.</p> <p>This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you \"lied\" to React that this Effect doesn't depend on anything, React forever keeps using the <code>onTick</code> function from the initial render. During that render, <code>count</code> was <code>0</code> and <code>increment</code> was <code>1</code>. This is why <code>onTick</code> from that render always calls <code>setCount(0 + 1)</code> every second, and you always see <code>1</code>. Bugs like this are harder to fix when they're spread across multiple components.</p> <p>There's always a better solution than ignoring the linter! To fix this code, you need to add <code>onTick</code> to the dependency list. (To ensure the interval is only setup once, make <code>onTick</code> an Effect Event.)</p> <p>We recommend treating the dependency lint error as a compilation error. If you don't suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases.</p> <p></p>"},{"location":"learn/removing-effect-dependencies/#removing-unnecessary-dependencies","title":"Removing unnecessary dependencies","text":"<p>Every time you adjust the Effect's dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is \"no\":</p> <ul> <li>You might want to re-execute different parts of your Effect under different conditions.</li> <li>You might want to only read the latest value of some dependency instead of \"reacting\" to its changes.</li> <li>A dependency may change too often unintentionally because it's an object or a function.</li> </ul> <p>To find the right solution, you'll need to answer a few questions about your Effect. Let's walk through them.</p>"},{"location":"learn/removing-effect-dependencies/#should-this-code-move-to-an-event-handler","title":"Should this code move to an event handler?","text":"<p>The first thing you should think about is whether this code should be an Effect at all.</p> <p>Imagine a form. On submit, you set the <code>submitted</code> state variable to <code>true</code>. You need to send a POST request and show a notification. You've put this logic inside an Effect that \"reacts\" to <code>submitted</code> being <code>true</code>:</p> <pre><code>function Form() {\nconst [submitted, setSubmitted] = useState(false);\n\nuseEffect(() =&gt; {\nif (submitted) {\n// \ud83d\udd34 Avoid: Event-specific logic inside an Effect\npost(\"/api/register\");\nshowNotification(\"Successfully registered!\");\n}\n}, [submitted]);\n\nfunction handleSubmit() {\nsetSubmitted(true);\n}\n\n// ...\n}\n</code></pre> <p>Later, you want to style the notification message according to the current theme, so you read the current theme. Since <code>theme</code> is declared in the component body, it is a reactive value, so you add it as a dependency:</p> <pre><code>function Form() {\nconst [submitted, setSubmitted] = useState(false);\nconst theme = useContext(ThemeContext);\n\nuseEffect(() =&gt; {\nif (submitted) {\n// \ud83d\udd34 Avoid: Event-specific logic inside an Effect\npost(\"/api/register\");\nshowNotification(\"Successfully registered!\", theme);\n}\n}, [submitted, theme]); // \u2705 All dependencies declared\n\nfunction handleSubmit() {\nsetSubmitted(true);\n}\n\n// ...\n}\n</code></pre> <p>By doing this, you've introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The <code>theme</code> will change, the Effect will re-run, and so it will display the same notification again!</p> <p>The problem here is that this shouldn't be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:</p> <pre><code>function Form() {\nconst theme = useContext(ThemeContext);\n\nfunction handleSubmit() {\n// \u2705 Good: Event-specific logic is called from event handlers\npost(\"/api/register\");\nshowNotification(\"Successfully registered!\", theme);\n}\n\n// ...\n}\n</code></pre> <p>Now that the code is in an event handler, it's not reactive--so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects.</p>"},{"location":"learn/removing-effect-dependencies/#is-your-effect-doing-several-unrelated-things","title":"Is your Effect doing several unrelated things?","text":"<p>The next question you should ask yourself is whether your Effect is doing several unrelated things.</p> <p>Imagine you're creating a shipping form where the user needs to choose their city and area. You fetch the list of <code>cities</code> from the server according to the selected <code>country</code> to show them in a dropdown:</p> <pre><code>function ShippingForm({ country }) {\nconst [cities, setCities] = useState(null);\nconst [city, setCity] = useState(null);\n\nuseEffect(() =&gt; {\nlet ignore = false;\nfetch(`/api/cities?country=${country}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetCities(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [country]); // \u2705 All dependencies declared\n\n// ...\n</code></pre> <p>This is a good example of fetching data in an Effect. You are synchronizing the <code>cities</code> state with the network according to the <code>country</code> prop. You can't do this in an event handler because you need to fetch as soon as <code>ShippingForm</code> is displayed and whenever the <code>country</code> changes (no matter which interaction causes it).</p> <p>Now let's say you're adding a second select box for city areas, which should fetch the <code>areas</code> for the currently selected <code>city</code>. You might start by adding a second <code>fetch</code> call for the list of areas inside the same Effect:</p> <pre><code>function ShippingForm({ country }) {\nconst [cities, setCities] = useState(null);\nconst [city, setCity] = useState(null);\nconst [areas, setAreas] = useState(null);\n\nuseEffect(() =&gt; {\nlet ignore = false;\nfetch(`/api/cities?country=${country}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetCities(json);\n}\n});\n// \ud83d\udd34 Avoid: A single Effect synchronizes two independent processes\nif (city) {\nfetch(`/api/areas?city=${city}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetAreas(json);\n}\n});\n}\nreturn () =&gt; {\nignore = true;\n};\n}, [country, city]); // \u2705 All dependencies declared\n\n// ...\n</code></pre> <p>However, since the Effect now uses the <code>city</code> state variable, you've had to add <code>city</code> to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call <code>fetchCities(country)</code>. As a result, you will be unnecessarily refetching the list of cities many times.</p> <p>The problem with this code is that you're synchronizing two different unrelated things:</p> <ol> <li>You want to synchronize the <code>cities</code> state to the network based on the <code>country</code> prop.</li> <li>You want to synchronize the <code>areas</code> state to the network based on the <code>city</code> state.</li> </ol> <p>Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:</p> <pre><code>function ShippingForm({ country }) {\nconst [cities, setCities] = useState(null);\nuseEffect(() =&gt; {\nlet ignore = false;\nfetch(`/api/cities?country=${country}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetCities(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [country]); // \u2705 All dependencies declared\n\nconst [city, setCity] = useState(null);\nconst [areas, setAreas] = useState(null);\nuseEffect(() =&gt; {\nif (city) {\nlet ignore = false;\nfetch(`/api/areas?city=${city}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetAreas(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}\n}, [city]); // \u2705 All dependencies declared\n\n// ...\n</code></pre> <p>Now the first Effect only re-runs if the <code>country</code> changes, while the second Effect re-runs when the <code>city</code> changes. You've separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won't trigger each other unintentionally.</p> <p>The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesn't break the other Effect's logic. This means they synchronize different things, and it's good to split them up. If you're concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook.</p>"},{"location":"learn/removing-effect-dependencies/#are-you-reading-some-state-to-calculate-the-next-state","title":"Are you reading some state to calculate the next state?","text":"<p>This Effect updates the <code>messages</code> state variable with a newly created array every time a new message arrives:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nsetMessages([...messages, receivedMessage]);\n});\n// ...\n</code></pre> <p>It uses the <code>messages</code> variable to create a new array starting with all the existing messages and adds the new message at the end. However, since <code>messages</code> is a reactive value read by an Effect, it must be a dependency:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nsetMessages([...messages, receivedMessage]);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, messages]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>And making <code>messages</code> a dependency introduces a problem.</p> <p>Every time you receive a message, <code>setMessages()</code> causes the component to re-render with a new <code>messages</code> array that includes the received message. However, since this Effect now depends on <code>messages</code>, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!</p> <p>To fix the issue, don't read <code>messages</code> inside the Effect. Instead, pass an updater function to <code>setMessages</code>:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nsetMessages(msgs =&gt; [...msgs, receivedMessage]);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Notice how your Effect does not read the <code>messages</code> variable at all now. You only need to pass an updater function like <code>msgs =&gt; [...msgs, receivedMessage]</code>. React puts your updater function in a queue and will provide the <code>msgs</code> argument to it during the next render. This is why the Effect itself doesn't need to depend on <code>messages</code> anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.</p>"},{"location":"learn/removing-effect-dependencies/#do-you-want-to-read-a-value-without-reacting-to-its-changes","title":"Do you want to read a value without \"reacting\" to its changes?","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>Suppose that you want to play a sound when the user receives a new message unless <code>isMuted</code> is <code>true</code>:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nconst [isMuted, setIsMuted] = useState(false);\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nsetMessages(msgs =&gt; [...msgs, receivedMessage]);\nif (!isMuted) {\nplaySound();\n}\n});\n// ...\n</code></pre> <p>Since your Effect now uses <code>isMuted</code> in its code, you have to add it to the dependencies:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nconst [isMuted, setIsMuted] = useState(false);\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nsetMessages(msgs =&gt; [...msgs, receivedMessage]);\nif (!isMuted) {\nplaySound();\n}\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, isMuted]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>The problem is that every time <code>isMuted</code> changes (for example, when the user presses the \"Muted\" toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work--if you do that, <code>isMuted</code> would get \"stuck\" with its old value.)</p> <p>To solve this problem, you need to extract the logic that shouldn't be reactive out of the Effect. You don't want this Effect to \"react\" to the changes in <code>isMuted</code>. Move this non-reactive piece of logic into an Effect Event:</p> <pre><code>import { useState, useEffect, useEffectEvent } from 'react';\n\nfunction ChatRoom({ roomId }) {\nconst [messages, setMessages] = useState([]);\nconst [isMuted, setIsMuted] = useState(false);\n\nconst onMessage = useEffectEvent(receivedMessage =&gt; {\nsetMessages(msgs =&gt; [...msgs, receivedMessage]);\nif (!isMuted) {\nplaySound();\n}\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nonMessage(receivedMessage);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Effect Events let you split an Effect into reactive parts (which should \"react\" to reactive values like <code>roomId</code> and their changes) and non-reactive parts (which only read their latest values, like <code>onMessage</code> reads <code>isMuted</code>). Now that you read <code>isMuted</code> inside an Effect Event, it doesn't need to be a dependency of your Effect. As a result, the chat won't re-connect when you toggle the \"Muted\" setting on and off, solving the original issue!</p>"},{"location":"learn/removing-effect-dependencies/#wrapping-an-event-handler-from-the-props","title":"Wrapping an event handler from the props","text":"<p>You might run into a similar problem when your component receives an event handler as a prop:</p> <pre><code>function ChatRoom({ roomId, onReceiveMessage }) {\nconst [messages, setMessages] = useState([]);\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nonReceiveMessage(receivedMessage);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, onReceiveMessage]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Suppose that the parent component passes a different <code>onReceiveMessage</code> function on every render:</p> <pre><code>&lt;ChatRoom\nroomId={roomId}\nonReceiveMessage={(receivedMessage) =&gt; {\n// ...\n}}\n/&gt;\n</code></pre> <p>Since <code>onReceiveMessage</code> is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:</p> <pre><code>function ChatRoom({ roomId, onReceiveMessage }) {\nconst [messages, setMessages] = useState([]);\n\nconst onMessage = useEffectEvent(receivedMessage =&gt; {\nonReceiveMessage(receivedMessage);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nconnection.on('message', (receivedMessage) =&gt; {\nonMessage(receivedMessage);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Effect Events aren't reactive, so you don't need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that's different on every re-render.</p>"},{"location":"learn/removing-effect-dependencies/#separating-reactive-and-non-reactive-code","title":"Separating reactive and non-reactive code","text":"<p>In this example, you want to log a visit every time <code>roomId</code> changes. You want to include the current <code>notificationCount</code> with every log, but you don't want a change to <code>notificationCount</code> to trigger a log event.</p> <p>The solution is again to split out the non-reactive code into an Effect Event:</p> <pre><code>function Chat({ roomId, notificationCount }) {\nconst onVisit = useEffectEvent((visitedRoomId) =&gt; {\nlogVisit(visitedRoomId, notificationCount);\n});\n\nuseEffect(() =&gt; {\nonVisit(roomId);\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>You want your logic to be reactive with regards to <code>roomId</code>, so you read <code>roomId</code> inside of your Effect. However, you don't want a change to <code>notificationCount</code> to log an extra visit, so you read <code>notificationCount</code> inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events.</p>"},{"location":"learn/removing-effect-dependencies/#does-some-reactive-value-change-unintentionally","title":"Does some reactive value change unintentionally?","text":"<p>Sometimes, you do want your Effect to \"react\" to a certain value, but that value changes more often than you'd like--and might not reflect any actual change from the user's perspective. For example, let's say that you create an <code>options</code> object in the body of your component, and then read that object from inside of your Effect:</p> <pre><code>function ChatRoom({ roomId }) {\n// ...\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId\n};\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\n// ...\n</code></pre> <p>This object is declared in the component body, so it's a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect \"reacts\" to its changes:</p> <pre><code>// ...\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>It is important to declare it as a dependency! This ensures, for example, that if the <code>roomId</code> changes, your Effect will re-connect to the chat with the new <code>options</code>. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\n// Temporarily disable the linter to demonstrate the problem\n// eslint-disable-next-line react-hooks/exhaustive-deps\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>In the sandbox above, the input only updates the <code>message</code> state variable. From the user's perspective, this should not affect the chat connection. However, every time you update the <code>message</code>, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p> <p>A new <code>options</code> object is created from scratch on every re-render of the <code>ChatRoom</code> component. React sees that the <code>options</code> object is a different object from the <code>options</code> object created during the last render. This is why it re-synchronizes your Effect (which depends on <code>options</code>), and the chat re-connects as you type.</p> <p>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn't matter that the contents inside of them may be the same!</p> <pre><code>// During the first render\nconst options1 = { serverUrl: \"https://localhost:1234\", roomId: \"music\" };\n\n// During the next render\nconst options2 = { serverUrl: \"https://localhost:1234\", roomId: \"music\" };\n\n// These are two different objects!\nconsole.log(Object.is(options1, options2)); // false\n</code></pre> <p>Object and function dependencies can make your Effect re-synchronize more often than you need.</p> <p>This is why, whenever possible, you should try to avoid objects and functions as your Effect's dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p>"},{"location":"learn/removing-effect-dependencies/#move-static-objects-and-functions-outside-your-component","title":"Move static objects and functions outside your component","text":"<p>If the object does not depend on any props and state, you can move that object outside your component:</p> <pre><code>const options = {\nserverUrl: 'https://localhost:1234',\nroomId: 'music'\n};\n\nfunction ChatRoom() {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>This way, you prove to the linter that it's not reactive. It can't change as a result of a re-render, so it doesn't need to be a dependency. Now re-rendering <code>ChatRoom</code> won't cause your Effect to re-synchronize.</p> <p>This works for functions too:</p> <pre><code>function createOptions() {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: 'music'\n};\n}\n\nfunction ChatRoom() {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nconst options = createOptions();\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Since <code>createOptions</code> is declared outside your component, it's not a reactive value. This is why it doesn't need to be specified in your Effect's dependencies, and why it won't ever cause your Effect to re-synchronize.</p>"},{"location":"learn/removing-effect-dependencies/#move-dynamic-objects-and-functions-inside-your-effect","title":"Move dynamic objects and functions inside your Effect","text":"<p>If your object depends on some reactive value that may change as a result of a re-render, like a <code>roomId</code> prop, you can't pull it outside your component. You can, however, move its creation inside of your Effect's code:</p> <pre><code>const serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Now that <code>options</code> is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is <code>roomId</code>. Since <code>roomId</code> is not an object or function, you can be sure that it won't be unintentionally different. In JavaScript, numbers and strings are compared by their content:</p> <pre><code>// During the first render\nconst roomId1 = \"music\";\n\n// During the next render\nconst roomId2 = \"music\";\n\n// These two strings are the same!\nconsole.log(Object.is(roomId1, roomId2)); // true\n</code></pre> <p>Thanks to this fix, the chat no longer re-connects if you edit the input:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>However, it does re-connect when you change the <code>roomId</code> dropdown, as you would expect.</p> <p>This works for functions, too:</p> <pre><code>const serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nfunction createOptions() {\nreturn {\nserverUrl: serverUrl,\nroomId: roomId\n};\n}\n\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, they're not reactive values, and so they don't need to be dependencies of your Effect.</p>"},{"location":"learn/removing-effect-dependencies/#read-primitive-values-from-objects","title":"Read primitive values from objects","text":"<p>Sometimes, you may receive an object from props:</p> <pre><code>function ChatRoom({ options }) {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>The risk here is that the parent component will create the object during rendering:</p> <pre><code>&lt;ChatRoom\nroomId={roomId}\noptions={{\nserverUrl: serverUrl,\nroomId: roomId,\n}}\n/&gt;\n</code></pre> <p>This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies:</p> <pre><code>function ChatRoom({ options }) {\nconst [message, setMessage] = useState('');\n\nconst { roomId, serverUrl } = options;\nuseEffect(() =&gt; {\nconst connection = createConnection({\nroomId: roomId,\nserverUrl: serverUrl\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if <code>options.roomId</code> or <code>options.serverUrl</code> really are different, the chat would re-connect.</p>"},{"location":"learn/removing-effect-dependencies/#calculate-primitive-values-from-functions","title":"Calculate primitive values from functions","text":"<p>The same approach can work for functions. For example, suppose the parent component passes a function:</p> <pre><code>&lt;ChatRoom\nroomId={roomId}\ngetOptions={() =&gt; {\nreturn {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n}}\n/&gt;\n</code></pre> <p>To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the <code>roomId</code> and <code>serverUrl</code> values that aren't objects, and that you can read from inside your Effect:</p> <pre><code>function ChatRoom({ getOptions }) {\nconst [message, setMessage] = useState('');\n\nconst { roomId, serverUrl } = getOptions();\nuseEffect(() =&gt; {\nconst connection = createConnection({\nroomId: roomId,\nserverUrl: serverUrl\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>This only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you don't want its changes to re-synchronize your Effect, wrap it into an Effect Event instead.</p> <p> <ul> <li>Dependencies should always match the code.</li> <li>When you're not happy with your dependencies, what you need to edit is the code.</li> <li>Suppressing the linter leads to very confusing bugs, and you should always avoid it.</li> <li>To remove a dependency, you need to \"prove\" to the linter that it's not necessary.</li> <li>If some code should run in response to a specific interaction, move that code to an event handler.</li> <li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li> <li>If you want to update some state based on the previous state, pass an updater function.</li> <li>If you want to read the latest value without \"reacting\" it, extract an Effect Event from your Effect.</li> <li>In JavaScript, objects and functions are considered different if they were created at different times.</li> <li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.</li> </ul> <p></p> <p>"},{"location":"learn/removing-effect-dependencies/#fix-a-resetting-interval","title":"Fix a resetting interval","text":"<p>This Effect sets up an interval that ticks every second. You've noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn't get constantly re-created.</p> <p> <p>It seems like this Effect's code depends on <code>count</code>. Is there some way to not need this dependency? There should be a way to update the <code>count</code> state based on its previous value without adding a dependency on that value.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconsole.log(\"\u2705 Creating an interval\");\nconst id = setInterval(() =&gt; {\nconsole.log(\"\u23f0 Interval tick\");\nsetCount(count + 1);\n}, 1000);\nreturn () =&gt; {\nconsole.log(\"\u274c Clearing an interval\");\nclearInterval(id);\n};\n}, [count]);\n\nreturn &lt;h1&gt;Counter: {count}&lt;/h1&gt;;\n}\n</code></pre> <p> <p>You want to update the <code>count</code> state to be <code>count + 1</code> from inside the Effect. However, this makes your Effect depend on <code>count</code>, which changes with every tick, and that's why your interval gets re-created on every tick.</p> <p>To solve this, use the updater function and write <code>setCount(c =&gt; c + 1)</code> instead of <code>setCount(count + 1)</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconsole.log(\"\u2705 Creating an interval\");\nconst id = setInterval(() =&gt; {\nconsole.log(\"\u23f0 Interval tick\");\nsetCount((c) =&gt; c + 1);\n}, 1000);\nreturn () =&gt; {\nconsole.log(\"\u274c Clearing an interval\");\nclearInterval(id);\n};\n}, []);\n\nreturn &lt;h1&gt;Counter: {count}&lt;/h1&gt;;\n}\n</code></pre> <p>Instead of reading <code>count</code> inside the Effect, you pass a <code>c =&gt; c + 1</code> instruction (\"increment this number!\") to React. React will apply it on the next render. And since you don't need to read the value of <code>count</code> inside your Effect anymore, so you can keep your Effect's dependencies empty (<code>[]</code>). This prevents your Effect from re-creating the interval on every tick.</p> <p></p>"},{"location":"learn/removing-effect-dependencies/#fix-a-retriggering-animation","title":"Fix a retriggering animation","text":"<p>In this example, when you press \"Show\", a welcome message fades in. The animation takes a second. When you press \"Remove\", the welcome message immediately disappears. The logic for the fade-in animation is implemented in the <code>animation.js</code> file as plain JavaScript animation loop. You don't need to change that logic. You can treat it as a third-party library. Your Effect creates an instance of <code>FadeInAnimation</code> for the DOM node, and then calls <code>start(duration)</code> or <code>stop()</code> to control the animation. The <code>duration</code> is controlled by a slider. Adjust the slider and see how the animation changes.</p> <p>This code already works, but there is something you want to change. Currently, when you move the slider that controls the <code>duration</code> state variable, it retriggers the animation. Change the behavior so that the Effect does not \"react\" to the <code>duration</code> variable. When you press \"Show\", the Effect should use the current <code>duration</code> on the slider. However, moving the slider itself should not by itself retrigger the animation.</p> <p> <p>Is there a line of code inside the Effect that should not be reactive? How can you move non-reactive code out of the Effect?</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { FadeInAnimation } from \"./animation.js\";\n\nfunction Welcome({ duration }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst animation = new FadeInAnimation(ref.current);\nanimation.start(duration);\nreturn () =&gt; {\nanimation.stop();\n};\n}, [duration]);\n\nreturn (\n&lt;h1\nref={ref}\nstyle={{\nopacity: 0,\ncolor: \"white\",\npadding: 50,\ntextAlign: \"center\",\nfontSize: 50,\nbackgroundImage:\n\"radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)\",\n}}\n&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [duration, setDuration] = useState(1000);\nconst [show, setShow] = useState(false);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"range\"\nmin=\"100\"\nmax=\"3000\"\nvalue={duration}\nonChange={(e) =&gt; setDuration(Number(e.target.value))}\n/&gt;\n&lt;br /&gt;\nFade in duration: {duration} ms\n&lt;/label&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome duration={duration} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export class FadeInAnimation {\nconstructor(node) {\nthis.node = node;\n}\nstart(duration) {\nthis.duration = duration;\nif (this.duration === 0) {\n// Jump to end immediately\nthis.onProgress(1);\n} else {\nthis.onProgress(0);\n// Start animating\nthis.startTime = performance.now();\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonFrame() {\nconst timePassed = performance.now() - this.startTime;\nconst progress = Math.min(timePassed / this.duration, 1);\nthis.onProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonProgress(progress) {\nthis.node.style.opacity = progress;\n}\nstop() {\ncancelAnimationFrame(this.frameId);\nthis.startTime = null;\nthis.frameId = null;\nthis.duration = 0;\n}\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n</code></pre> <p> <p>Your Effect needs to read the latest value of <code>duration</code>, but you don't want it to \"react\" to changes in <code>duration</code>. You use <code>duration</code> to start the animation, but starting animation isn't reactive. Extract the non-reactive line of code into an Effect Event, and call that function from your Effect.</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { FadeInAnimation } from \"./animation.js\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nfunction Welcome({ duration }) {\nconst ref = useRef(null);\n\nconst onAppear = useEffectEvent((animation) =&gt; {\nanimation.start(duration);\n});\n\nuseEffect(() =&gt; {\nconst animation = new FadeInAnimation(ref.current);\nonAppear(animation);\nreturn () =&gt; {\nanimation.stop();\n};\n}, []);\n\nreturn (\n&lt;h1\nref={ref}\nstyle={{\nopacity: 0,\ncolor: \"white\",\npadding: 50,\ntextAlign: \"center\",\nfontSize: 50,\nbackgroundImage:\n\"radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)\",\n}}\n&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [duration, setDuration] = useState(1000);\nconst [show, setShow] = useState(false);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"range\"\nmin=\"100\"\nmax=\"3000\"\nvalue={duration}\nonChange={(e) =&gt; setDuration(Number(e.target.value))}\n/&gt;\n&lt;br /&gt;\nFade in duration: {duration} ms\n&lt;/label&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome duration={duration} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export class FadeInAnimation {\nconstructor(node) {\nthis.node = node;\n}\nstart(duration) {\nthis.duration = duration;\nthis.onProgress(0);\nthis.startTime = performance.now();\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\nonFrame() {\nconst timePassed = performance.now() - this.startTime;\nconst progress = Math.min(timePassed / this.duration, 1);\nthis.onProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonProgress(progress) {\nthis.node.style.opacity = progress;\n}\nstop() {\ncancelAnimationFrame(this.frameId);\nthis.startTime = null;\nthis.frameId = null;\nthis.duration = 0;\n}\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n</code></pre> <p>Effect Events like <code>onAppear</code> are not reactive, so you can read <code>duration</code> inside without retriggering the animation.</p> <p></p>"},{"location":"learn/removing-effect-dependencies/#fix-a-reconnecting-chat","title":"Fix a reconnecting chat","text":"<p>In this example, every time you press \"Toggle theme\", the chat re-connects. Why does this happen? Fix the mistake so that the chat re-connects only when you edit the Server URL or choose a different chat room.</p> <p>Treat <code>chat.js</code> as an external third-party library: you can consult it to check its API, but don't edit it.</p> <p> <p>There's more than one way to fix this, but ultimately you want to avoid having an object as your dependency.</p> <p></p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n\nreturn (\n&lt;div className={isDark ? \"dark\" : \"light\"}&gt;\n&lt;button on_click={() =&gt; setIsDark(!isDark)}&gt;Toggle theme&lt;/button&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom options={options} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport default function ChatRoom({ options }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]);\n\nreturn &lt;h1&gt;Welcome to the {options.roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 5px;\n}\n.dark {\nbackground: #222;\ncolor: #eee;\n}\n</code></pre> <p> <p>Your Effect is re-running because it depends on the <code>options</code> object. Objects can be re-created unintentionally, you should try to avoid them as dependencies of your Effects whenever possible.</p> <p>The least invasive fix is to read <code>roomId</code> and <code>serverUrl</code> right outside the Effect, and then make the Effect depend on those primitive values (which can't change unintentionally). Inside the Effect, create an object and it pass to <code>createConnection</code>:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n\nreturn (\n&lt;div className={isDark ? \"dark\" : \"light\"}&gt;\n&lt;button on_click={() =&gt; setIsDark(!isDark)}&gt;Toggle theme&lt;/button&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom options={options} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport default function ChatRoom({ options }) {\nconst { roomId, serverUrl } = options;\nuseEffect(() =&gt; {\nconst connection = createConnection({\nroomId: roomId,\nserverUrl: serverUrl,\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n\nreturn &lt;h1&gt;Welcome to the {options.roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 5px;\n}\n.dark {\nbackground: #222;\ncolor: #eee;\n}\n</code></pre> <p>It would be even better to replace the object <code>options</code> prop with the more specific <code>roomId</code> and <code>serverUrl</code> props:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nreturn (\n&lt;div className={isDark ? \"dark\" : \"light\"}&gt;\n&lt;button on_click={() =&gt; setIsDark(!isDark)}&gt;Toggle theme&lt;/button&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} serverUrl={serverUrl} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport default function ChatRoom({ roomId, serverUrl }) {\nuseEffect(() =&gt; {\nconst connection = createConnection({\nroomId: roomId,\nserverUrl: serverUrl,\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 5px;\n}\n.dark {\nbackground: #222;\ncolor: #eee;\n}\n</code></pre> <p>Sticking to primitive props where possible makes it easier to optimize your components later.</p> <p></p>"},{"location":"learn/removing-effect-dependencies/#fix-a-reconnecting-chat-again","title":"Fix a reconnecting chat, again","text":"<p>This example connects to the chat either with or without encryption. Toggle the checkbox and notice the different messages in the console when the encryption is on and off. Try changing the room. Then, try toggling the theme. When you're connected to a chat room, you will receive new messages every few seconds. Verify that their color matches the theme you've picked.</p> <p>In this example, the chat re-connects every time you try to change the theme. Fix this. After the fix, changing the theme should not re-connect the chat, but toggling encryption settings or changing the room should re-connect.</p> <p>Don't change any code in <code>chat.js</code>. Other than that, you can change any code as long as it results in the same behavior. For example, you may find it helpful to change which props are being passed down.</p> <p> <p>You're passing down two functions: <code>onMessage</code> and <code>createConnection</code>. Both of them are created from scratch every time <code>App</code> re-renders. They are considered to be new values every time, which is why they re-trigger your Effect.</p> <p>One of these functions is an event handler. Do you know some way to call an event handler an Effect without \"reacting\" to the new values of the event handler function? That would come in handy!</p> <p>Another of these functions only exists to pass some state to an imported API method. Is this function really necessary? What is the essential information that's being passed down? You might need to move some imports from <code>App.js</code> to <code>ChatRoom.js</code>.</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\nimport {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isEncrypted, setIsEncrypted] = useState(false);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isEncrypted}\nonChange={(e) =&gt; setIsEncrypted(e.target.checked)}\n/&gt;\nEnable encryption\n&lt;/label&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom\nroomId={roomId}\nonMessage={(msg) =&gt; {\nshowNotification(\n\"New message: \" + msg,\nisDark ? \"dark\" : \"light\"\n);\n}}\ncreateConnection={() =&gt; {\nconst options = {\nserverUrl: \"https://localhost:1234\",\nroomId: roomId,\n};\nif (isEncrypted) {\nreturn createEncryptedConnection(options);\n} else {\nreturn createUnencryptedConnection(options);\n}\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function ChatRoom({ roomId, createConnection, onMessage }) {\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.on(\"message\", (msg) =&gt; onMessage(msg));\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [createConnection, onMessage]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createEncryptedConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 \ud83d\udd10 Connecting to \"' + roomId + '\" room... (encrypted)'\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c \ud83d\udd10 Disconnected from \"' + roomId + '\" room (encrypted)'\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n\nexport function createUnencryptedConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room (unencrypted)...'\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room (unencrypted)'\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <p> <p>There's more than one correct way to solve this, but here is one possible solution.</p> <p>In the original example, toggling the theme caused different <code>onMessage</code> and <code>createConnection</code> functions to be created and passed down. Since the Effect depended on these functions, the chat would re-connect every time you toggle the theme.</p> <p>To fix the problem with <code>onMessage</code>, you needed to wrap it into an Effect Event:</p> <pre><code>export default function ChatRoom({ roomId, createConnection, onMessage }) {\nconst onReceiveMessage = useEffectEvent(onMessage);\n\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.on('message', (msg) =&gt; onReceiveMessage(msg));\n// ...\n</code></pre> <p>Unlike the <code>onMessage</code> prop, the <code>onReceiveMessage</code> Effect Event is not reactive. This is why it doesn't need to be a dependency of your Effect. As a result, changes to <code>onMessage</code> won't cause the chat to re-connect.</p> <p>You can't do the same with <code>createConnection</code> because it should be reactive. You want the Effect to re-trigger if the user switches between an encrypted and an unencryption connection, or if the user switches the current room. However, because <code>createConnection</code> is a function, you can't check whether the information it reads has actually changed or not. To solve this, instead of passing <code>createConnection</code> down from the <code>App</code> component, pass the raw <code>roomId</code> and <code>isEncrypted</code> values:</p> <pre><code>&lt;ChatRoom\nroomId={roomId}\nisEncrypted={isEncrypted}\nonMessage={(msg) =&gt; {\nshowNotification(\"New message: \" + msg, isDark ? \"dark\" : \"light\");\n}}\n/&gt;\n</code></pre> <p>Now you can move the <code>createConnection</code> function inside the Effect instead of passing it down from the <code>App</code>:</p> <pre><code>import {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from './chat.js';\n\nexport default function ChatRoom({ roomId, isEncrypted, onMessage }) {\nconst onReceiveMessage = useEffectEvent(onMessage);\n\nuseEffect(() =&gt; {\nfunction createConnection() {\nconst options = {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\nif (isEncrypted) {\nreturn createEncryptedConnection(options);\n} else {\nreturn createUnencryptedConnection(options);\n}\n}\n// ...\n</code></pre> <p>After these two changes, your Effect no longer depends on any function values:</p> <pre><code>export default function ChatRoom({ roomId, isEncrypted, onMessage }) { // Reactive values\nconst onReceiveMessage = useEffectEvent(onMessage); // Not reactive\n\nuseEffect(() =&gt; {\nfunction createConnection() {\nconst options = {\nserverUrl: 'https://localhost:1234',\nroomId: roomId // Reading a reactive value\n};\nif (isEncrypted) { // Reading a reactive value\nreturn createEncryptedConnection(options);\n} else {\nreturn createUnencryptedConnection(options);\n}\n}\n\nconst connection = createConnection();\nconnection.on('message', (msg) =&gt; onReceiveMessage(msg));\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, isEncrypted]); // \u2705 All dependencies declared\n</code></pre> <p>As a result, the chat re-connects only when something meaningful (<code>roomId</code> or <code>isEncrypted</code>) changes:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nimport { showNotification } from \"./notifications.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isEncrypted, setIsEncrypted] = useState(false);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isEncrypted}\nonChange={(e) =&gt; setIsEncrypted(e.target.checked)}\n/&gt;\nEnable encryption\n&lt;/label&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom\nroomId={roomId}\nisEncrypted={isEncrypted}\nonMessage={(msg) =&gt; {\nshowNotification(\n\"New message: \" + msg,\nisDark ? \"dark\" : \"light\"\n);\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport {\ncreateEncryptedConnection,\ncreateUnencryptedConnection,\n} from \"./chat.js\";\n\nexport default function ChatRoom({ roomId, isEncrypted, onMessage }) {\nconst onReceiveMessage = useEffectEvent(onMessage);\n\nuseEffect(() =&gt; {\nfunction createConnection() {\nconst options = {\nserverUrl: \"https://localhost:1234\",\nroomId: roomId,\n};\nif (isEncrypted) {\nreturn createEncryptedConnection(options);\n} else {\nreturn createUnencryptedConnection(options);\n}\n}\n\nconst connection = createConnection();\nconnection.on(\"message\", (msg) =&gt; onReceiveMessage(msg));\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, isEncrypted]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createEncryptedConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 \ud83d\udd10 Connecting to \"' + roomId + '\" room... (encrypted)'\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c \ud83d\udd10 Disconnected from \"' + roomId + '\" room (encrypted)'\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n\nexport function createUnencryptedConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room (unencrypted)...'\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room (unencrypted)'\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 5px;\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/render-and-commit/","title":"Render and Commit \ud83d\udea7","text":""},{"location":"learn/render-and-commit/#overview","title":"Overview","text":"<p>  Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.  </p> <p>You will learn</p> <ul> <li>What rendering means in React</li> <li>When and why React renders a component</li> <li>The steps involved in displaying a component on screen</li> <li>Why rendering does not always produce a DOM update</li> </ul> <p>Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:</p> <ol> <li>Triggering a render (delivering the guest's order to the kitchen)</li> <li>Rendering the component (preparing the order in the kitchen)</li> <li>Committing to the DOM (placing the order on the table)</li> </ol> <p> </p>"},{"location":"learn/render-and-commit/#step-1-trigger-a-render","title":"Step 1: Trigger a render","text":"<p>There are two reasons for a component to render:</p> <ol> <li>It's the component's initial render.</li> <li>The component's (or one of its ancestors') state has been updated.</li> </ol>"},{"location":"learn/render-and-commit/#initial-render","title":"Initial render","text":"<p>When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it's done by calling <code>createRoot</code> with the target DOM node, and then calling its <code>render</code> method with your component:</p> <pre><code>import Image from \"./Image.js\";\nimport { createRoot } from \"react-dom/client\";\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(&lt;Image /&gt;);\n</code></pre> <pre><code>export default function Image() {\nreturn (\n&lt;img\nsrc=\"https://i.imgur.com/ZF6s192.jpg\"\nalt=\"'Floralis Gen\u00e9rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals\"\n/&gt;\n);\n}\n</code></pre> <p>Try commenting out the <code>root.render()</code> call and see the component disappear!</p>"},{"location":"learn/render-and-commit/#re-renders-when-state-updates","title":"Re-renders when state updates","text":"<p>Once the component has been initially rendered, you can trigger further renders by updating its state with the <code>set</code> function. Updating your component's state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)</p> <p> </p>"},{"location":"learn/render-and-commit/#step-2-react-renders-your-components","title":"Step 2: React renders your components","text":"<p>After you trigger a render, React calls your components to figure out what to display on screen. \"Rendering\" is React calling your components.</p> <ul> <li>On initial render, React will call the root component.</li> <li>For subsequent renders, React will call the function component whose state update triggered the render.</li> </ul> <p>This process is recursive: if the updated component returns some other component, React will render that component next, and if that component also returns something, it will render that component next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.</p> <p>In the following example, React will call <code>Gallery()</code> and <code>Image()</code> several times:</p> <pre><code>export default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Inspiring Sculptures&lt;/h1&gt;\n&lt;Image /&gt;\n&lt;Image /&gt;\n&lt;Image /&gt;\n&lt;/section&gt;\n);\n}\n\nfunction Image() {\nreturn (\n&lt;img\nsrc=\"https://i.imgur.com/ZF6s192.jpg\"\nalt=\"'Floralis Gen\u00e9rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals\"\n/&gt;\n);\n}\n</code></pre> <pre><code>import Gallery from \"./Gallery.js\";\nimport { createRoot } from \"react-dom/client\";\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(&lt;Gallery /&gt;);\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\n}\n</code></pre> <ul> <li>During the initial render, React will create the DOM nodes for <code>&lt;section&gt;</code>, <code>&lt;h1&gt;</code>, and three <code>&lt;img&gt;</code> tags.</li> <li>During a re-render, React will calculate which of their properties, if any, have changed since the previous render. It won't do anything with that information until the next step, the commit phase.</li> </ul> <p> <p>Rendering must always be a pure calculation:</p> <ul> <li>Same inputs, same output. Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)</li> <li>It minds its own business. It should not change any objects or variables that existed before rendering. (One order should not change anyone else's order.)</li> </ul> <p>Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in \"Strict Mode\", React calls each component's function twice, which can help surface mistakes caused by impure functions.</p> <p></p> <p>"},{"location":"learn/render-and-commit/#optimizing-performance","title":"Optimizing performance","text":"<p>The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. If you run into a performance issue, there are several opt-in ways to solve it described in the Performance section. Don't optimize prematurely!</p> <p></p>"},{"location":"learn/render-and-commit/#step-3-react-commits-changes-to-the-dom","title":"Step 3: React commits changes to the DOM","text":"<p>After rendering (calling) your components, React will modify the DOM.</p> <ul> <li>For the initial render, React will use the <code>appendChild()</code> DOM API to put all the DOM nodes it has created on screen.</li> <li>For re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.</li> </ul> <p>React only changes the DOM nodes if there's a difference between renders. For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the <code>&lt;input&gt;</code>, updating its <code>value</code>, but the text doesn't disappear when the component re-renders:</p> <pre><code>export default function Clock({ time }) {\nreturn (\n&lt;&gt;\n&lt;h1&gt;{time}&lt;/h1&gt;\n&lt;input /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport Clock from \"./Clock.js\";\n\nfunction useTime() {\nconst [time, setTime] = useState(() =&gt; new Date());\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetTime(new Date());\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn time;\n}\n\nexport default function App() {\nconst time = useTime();\nreturn &lt;Clock time={time.toLocaleTimeString()} /&gt;;\n}\n</code></pre> <p>This works because during this last step, React only updates the content of <code>&lt;h1&gt;</code> with the new <code>time</code>. It sees that the <code>&lt;input&gt;</code> appears in the JSX in the same place as last time, so React doesn't touch the <code>&lt;input&gt;</code>\u2014or its <code>value</code>!</p>"},{"location":"learn/render-and-commit/#epilogue-browser-paint","title":"Epilogue: Browser paint","text":"<p>After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as \"browser rendering\", we'll refer to it as \"painting\" to avoid confusion throughout the docs.</p> <p></p> <p> <ul> <li>Any screen update in a React app happens in three steps:<ol> <li>Trigger</li> <li>Render</li> <li>Commit</li> </ol> </li> <li>You can use Strict Mode to find mistakes in your components</li> <li>React does not touch the DOM if the rendering result is the same as last time</li> </ul> <p></p>"},{"location":"learn/rendering-lists/","title":"Rendering Lists \ud83d\udea7","text":""},{"location":"learn/rendering-lists/#overview","title":"Overview","text":"<p>  You will often want to display multiple similar components from a collection of data. You can use the JavaScript array methods to manipulate an array of data. On this page, you'll use <code>filter()</code> and <code>map()</code> with React to filter and transform your array of data into an array of components.  </p> <p>You will learn</p> <ul> <li>How to render components from an array using JavaScript's <code>map()</code></li> <li>How to render only specific components using JavaScript's <code>filter()</code></li> <li>When and why to use React keys</li> </ul>"},{"location":"learn/rendering-lists/#rendering-data-from-arrays","title":"Rendering data from arrays","text":"<p>Say that you have a list of content.</p> <pre><code>&lt;ul&gt;\n&lt;li&gt;Creola Katherine Johnson: mathematician&lt;/li&gt;\n&lt;li&gt;Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez: chemist&lt;/li&gt;\n&lt;li&gt;Mohammad Abdus Salam: physicist&lt;/li&gt;\n&lt;li&gt;Percy Lavon Julian: chemist&lt;/li&gt;\n&lt;li&gt;Subrahmanyan Chandrasekhar: astrophysicist&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods like <code>map()</code> and <code>filter()</code> to render lists of components from them.</p> <p>Here\u2019s a short example of how to generate a list of items from an array:</p> <ol> <li>Move the data into an array:</li> </ol> <pre><code>const people = [\n\"Creola Katherine Johnson: mathematician\",\n\"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez: chemist\",\n\"Mohammad Abdus Salam: physicist\",\n\"Percy Lavon Julian: chemist\",\n\"Subrahmanyan Chandrasekhar: astrophysicist\",\n];\n</code></pre> <ol> <li>Map the <code>people</code> members into a new array of JSX nodes, <code>listItems</code>:</li> </ol> <pre><code>const listItems = people.map((person) =&gt; &lt;li&gt;{person}&lt;/li&gt;);\n</code></pre> <ol> <li>Return <code>listItems</code> from your component wrapped in a <code>&lt;ul&gt;</code>:</li> </ol> <pre><code>return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n</code></pre> <p>Here is the result:</p> <pre><code>const people = [\n\"Creola Katherine Johnson: mathematician\",\n\"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez: chemist\",\n\"Mohammad Abdus Salam: physicist\",\n\"Percy Lavon Julian: chemist\",\n\"Subrahmanyan Chandrasekhar: astrophysicist\",\n];\n\nexport default function List() {\nconst listItems = people.map((person) =&gt; &lt;li&gt;{person}&lt;/li&gt;);\nreturn &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>li {\nmargin-bottom: 10px;\n}\n</code></pre> <p>Notice the sandbox above displays a console error:</p> <p> <p>Warning: Each child in a list should have a unique \"key\" prop.</p> <p></p> <p>You'll learn how to fix this error later on this page. Before we get to that, let's add some structure to your data.</p>"},{"location":"learn/rendering-lists/#filtering-arrays-of-items","title":"Filtering arrays of items","text":"<p>This data can be structured even more.</p> <pre><code>const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\n},\n{\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\n},\n{\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\n},\n];\n</code></pre> <p>Let's say you want a way to only show people whose profession is <code>'chemist'</code>. You can use JavaScript's <code>filter()</code> method to return just those people. This method takes an array of items, passes them through a \u201ctest\u201d (a function that returns <code>true</code> or <code>false</code>), and returns a new array of only those items that passed the test (returned <code>true</code>).</p> <p>You only want the items where <code>profession</code> is <code>'chemist'</code>. The \"test\" function for this looks like <code>(person) =&gt; person.profession === 'chemist'</code>. Here's how to put it together:</p> <ol> <li>Create a new array of just \u201cchemist\u201d people, <code>chemists</code>, by calling <code>filter()</code> on the <code>people</code> filtering by <code>person.profession === 'chemist'</code>:</li> </ol> <pre><code>const chemists = people.filter((person) =&gt; person.profession === \"chemist\");\n</code></pre> <ol> <li>Now map over <code>chemists</code>:</li> </ol> <pre><code>const listItems = chemists.map((person) =&gt; (\n&lt;li&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n));\n</code></pre> <ol> <li>Lastly, return the <code>listItems</code> from your component:</li> </ol> <pre><code>return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n</code></pre> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function List() {\nconst chemists = people.filter((person) =&gt; person.profession === \"chemist\");\nconst listItems = chemists.map((person) =&gt; (\n&lt;li&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n));\nreturn &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3,\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4,\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p> <p>Arrow functions implicitly return the expression right after <code>=&gt;</code>, so you didn't need a <code>return</code> statement:</p> <pre><code>const listItems = chemists.map(\n(person) =&gt; &lt;li&gt;...&lt;/li&gt; // Implicit return!\n);\n</code></pre> <p>However, you must write <code>return</code> explicitly if your <code>=&gt;</code> is followed by a <code>{</code> curly brace!</p> <pre><code>const listItems = chemists.map((person) =&gt; {\n// Curly brace\nreturn &lt;li&gt;...&lt;/li&gt;;\n});\n</code></pre> <p>Arrow functions containing <code>=&gt; {</code> are said to have a \"block body\". They let you write more than a single line of code, but you have to write a <code>return</code> statement yourself. If you forget it, nothing gets returned!</p> <p></p>"},{"location":"learn/rendering-lists/#keeping-list-items-in-order-with-key","title":"Keeping list items in order with <code>key</code>","text":"<p>Notice that all the sandboxes above show an error in the console:</p> <p> <p>Warning: Each child in a list should have a unique \"key\" prop.</p> <p></p> <p>You need to give each array item a <code>key</code> -- a string or a number that uniquely identifies it among other items in that array:</p> <pre><code>&lt;li key={person.id}&gt;...&lt;/li&gt;\n</code></pre> <p> <p>JSX elements directly inside a <code>map()</code> call always need keys!</p> <p></p> <p>Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen <code>key</code> helps React infer what exactly has happened, and make the correct updates to the DOM tree.</p> <p>Rather than generating keys on the fly, you should include them in your data:</p> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function List() {\nconst listItems = people.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n));\nreturn &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0, // Used in JSX as a key\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1, // Used in JSX as a key\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2, // Used in JSX as a key\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3, // Used in JSX as a key\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4, // Used in JSX as a key\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p>"},{"location":"learn/rendering-lists/#displaying-several-dom-nodes-for-each-list-item","title":"Displaying several DOM nodes for each list item","text":"<p>What do you do when each item needs to render not one, but several DOM nodes?</p> <p>The short <code>&lt;&gt;...</code> Fragment syntax won't let you pass a key, so you need to either group them into a single <code>&lt;div&gt;</code>, or use the slightly longer and more explicit <code>&lt;Fragment&gt;</code> syntax:</p> <pre><code>import { Fragment } from \"react\";\n\n// ...\n\nconst listItems = people.map((person) =&gt; (\n&lt;Fragment key={person.id}&gt;\n&lt;h1&gt;{person.name}&lt;/h1&gt;\n&lt;p&gt;{person.bio}&lt;/p&gt;\n&lt;/Fragment&gt;\n));\n</code></pre> <p>Fragments disappear from the DOM, so this will produce a flat list of <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and so on.</p> <p></p>"},{"location":"learn/rendering-lists/#where-to-get-your-key","title":"Where to get your <code>key</code>","text":"<p>Different sources of data provide different sources of keys:</p> <ul> <li>Data from a database: If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.</li> <li>Locally generated data: If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, <code>crypto.randomUUID()</code> or a package like <code>uuid</code> when creating items.</li> </ul>"},{"location":"learn/rendering-lists/#rules-of-keys","title":"Rules of keys","text":"<ul> <li>Keys must be unique among siblings. However, it\u2019s okay to use the same keys for JSX nodes in different arrays.</li> <li>Keys must not change or that defeats their purpose! Don't generate them while rendering.</li> </ul>"},{"location":"learn/rendering-lists/#why-does-react-need-keys","title":"Why does React need keys?","text":"<p>Imagine that files on your desktop didn't have names. Instead, you'd refer to them by their order -- the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on.</p> <p>File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if the position changes due to reordering, the <code>key</code> lets React identify the item throughout its lifetime.</p> <p> <p>You might be tempted to use an item's index in the array as its key. In fact, that's what React will use if you don't specify a <code>key</code> at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.</p> <p>Similarly, do not generate keys on the fly, e.g. with <code>key={Math.random()}</code>. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.</p> <p>Note that your components won't receive <code>key</code> as a prop. It's only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: <code>&lt;Profile key={id} userId={id} /&gt;</code>.</p> <p></p> <p> <p>On this page you learned:</p> <ul> <li>How to move data out of components and into data structures like arrays and objects.</li> <li>How to generate sets of similar components with JavaScript's <code>map()</code>.</li> <li>How to create arrays of filtered items with JavaScript's <code>filter()</code>.</li> <li>Why and how to set <code>key</code> on each component in a collection so React can keep track of each of them even if their position or data changes.</li> </ul> <p></p> <p>"},{"location":"learn/rendering-lists/#splitting-a-list-in-two","title":"Splitting a list in two","text":"<p>This example shows a list of all people.</p> <p>Change it to show two separate lists one after another: Chemists and Everyone Else. Like previously, you can determine whether a person is a chemist by checking if <code>person.profession === 'chemist'</code>.</p> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function List() {\nconst listItems = people.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n));\nreturn (\n&lt;article&gt;\n&lt;h1&gt;Scientists&lt;/h1&gt;\n&lt;ul&gt;{listItems}&lt;/ul&gt;\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3,\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4,\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p> <p>You could use <code>filter()</code> twice, creating two separate arrays, and then <code>map</code> over both of them:</p> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nexport default function List() {\nconst chemists = people.filter((person) =&gt; person.profession === \"chemist\");\nconst everyoneElse = people.filter(\n(person) =&gt; person.profession !== \"chemist\"\n);\nreturn (\n&lt;article&gt;\n&lt;h1&gt;Scientists&lt;/h1&gt;\n&lt;h2&gt;Chemists&lt;/h2&gt;\n&lt;ul&gt;\n{chemists.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;h2&gt;Everyone Else&lt;/h2&gt;\n&lt;ul&gt;\n{everyoneElse.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3,\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4,\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p>In this solution, the <code>map</code> calls are placed directly inline into the parent <code>&lt;ul&gt;</code> elements, but you could introduce variables for them if you find that more readable.</p> <p>There is still a bit duplication between the rendered lists. You can go further and extract the repetitive parts into a <code>&lt;ListSection&gt;</code> component:</p> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nfunction ListSection({ title, people }) {\nreturn (\n&lt;&gt;\n&lt;h2&gt;{title}&lt;/h2&gt;\n&lt;ul&gt;\n{people.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nexport default function List() {\nconst chemists = people.filter((person) =&gt; person.profession === \"chemist\");\nconst everyoneElse = people.filter(\n(person) =&gt; person.profession !== \"chemist\"\n);\nreturn (\n&lt;article&gt;\n&lt;h1&gt;Scientists&lt;/h1&gt;\n&lt;ListSection title=\"Chemists\" people={chemists} /&gt;\n&lt;ListSection title=\"Everyone Else\" people={everyoneElse} /&gt;\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3,\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4,\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p>A very attentive reader might notice that with two <code>filter</code> calls, we check each person's profession twice. Checking a property is very fast, so in this example it's fine. If your logic was more expensive than that, you could replace the <code>filter</code> calls with a loop that manually constructs the arrays and checks each person once.</p> <p>In fact, if <code>people</code> never change, you could move this code out of your component. From React's perspective, all that matters is that you give it an array of JSX nodes in the end. It doesn't care how you produce that array:</p> <pre><code>import { people } from \"./data.js\";\nimport { getImageUrl } from \"./utils.js\";\n\nlet chemists = [];\nlet everyoneElse = [];\npeople.forEach((person) =&gt; {\nif (person.profession === \"chemist\") {\nchemists.push(person);\n} else {\neveryoneElse.push(person);\n}\n});\n\nfunction ListSection({ title, people }) {\nreturn (\n&lt;&gt;\n&lt;h2&gt;{title}&lt;/h2&gt;\n&lt;ul&gt;\n{people.map((person) =&gt; (\n&lt;li key={person.id}&gt;\n&lt;img src={getImageUrl(person)} alt={person.name} /&gt;\n&lt;p&gt;\n&lt;b&gt;{person.name}:&lt;/b&gt;\n{\" \" + person.profession + \" \"}\nknown for {person.accomplishment}\n&lt;/p&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nexport default function List() {\nreturn (\n&lt;article&gt;\n&lt;h1&gt;Scientists&lt;/h1&gt;\n&lt;ListSection title=\"Chemists\" people={chemists} /&gt;\n&lt;ListSection title=\"Everyone Else\" people={everyoneElse} /&gt;\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>export const people = [\n{\nid: 0,\nname: \"Creola Katherine Johnson\",\nprofession: \"mathematician\",\naccomplishment: \"spaceflight calculations\",\nimageId: \"MK3eW3A\",\n},\n{\nid: 1,\nname: \"Mario Jos\u00e9 Molina-Pasquel Henr\u00edquez\",\nprofession: \"chemist\",\naccomplishment: \"discovery of Arctic ozone hole\",\nimageId: \"mynHUSa\",\n},\n{\nid: 2,\nname: \"Mohammad Abdus Salam\",\nprofession: \"physicist\",\naccomplishment: \"electromagnetism theory\",\nimageId: \"bE7W1ji\",\n},\n{\nid: 3,\nname: \"Percy Lavon Julian\",\nprofession: \"chemist\",\naccomplishment:\n\"pioneering cortisone drugs, steroids and birth control pills\",\nimageId: \"IOjWm71\",\n},\n{\nid: 4,\nname: \"Subrahmanyan Chandrasekhar\",\nprofession: \"astrophysicist\",\naccomplishment: \"white dwarf star mass calculations\",\nimageId: \"lrWQx8l\",\n},\n];\n</code></pre> <pre><code>export function getImageUrl(person) {\nreturn \"https://i.imgur.com/\" + person.imageId + \"s.jpg\";\n}\n</code></pre> <pre><code>ul {\nlist-style-type: none;\npadding: 0px 10px;\n}\nli {\nmargin-bottom: 10px;\ndisplay: grid;\ngrid-template-columns: auto 1fr;\ngap: 20px;\nalign-items: center;\n}\nimg {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50%;\n}\n</code></pre> <p></p>"},{"location":"learn/rendering-lists/#nested-lists-in-one-component","title":"Nested lists in one component","text":"<p>Make a list of recipes from this array! For each recipe in the array, display its name as an <code>&lt;h2&gt;</code> and list its ingredients in a <code>&lt;ul&gt;</code>.</p> <p> <p>This will require nesting two different <code>map</code> calls.</p> <p></p> <pre><code>import { recipes } from \"./data.js\";\n\nexport default function RecipeList() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Recipes&lt;/h1&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export const recipes = [\n{\nid: \"greek-salad\",\nname: \"Greek Salad\",\ningredients: [\"tomatoes\", \"cucumber\", \"onion\", \"olives\", \"feta\"],\n},\n{\nid: \"hawaiian-pizza\",\nname: \"Hawaiian Pizza\",\ningredients: [\n\"pizza crust\",\n\"pizza sauce\",\n\"mozzarella\",\n\"ham\",\n\"pineapple\",\n],\n},\n{\nid: \"hummus\",\nname: \"Hummus\",\ningredients: [\n\"chickpeas\",\n\"olive oil\",\n\"garlic cloves\",\n\"lemon\",\n\"tahini\",\n],\n},\n];\n</code></pre> <p> <p>Here is one way you could go about it:</p> <pre><code>import { recipes } from \"./data.js\";\n\nexport default function RecipeList() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Recipes&lt;/h1&gt;\n{recipes.map((recipe) =&gt; (\n&lt;div key={recipe.id}&gt;\n&lt;h2&gt;{recipe.name}&lt;/h2&gt;\n&lt;ul&gt;\n{recipe.ingredients.map((ingredient) =&gt; (\n&lt;li key={ingredient}&gt;{ingredient}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n))}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export const recipes = [\n{\nid: \"greek-salad\",\nname: \"Greek Salad\",\ningredients: [\"tomatoes\", \"cucumber\", \"onion\", \"olives\", \"feta\"],\n},\n{\nid: \"hawaiian-pizza\",\nname: \"Hawaiian Pizza\",\ningredients: [\n\"pizza crust\",\n\"pizza sauce\",\n\"mozzarella\",\n\"ham\",\n\"pineapple\",\n],\n},\n{\nid: \"hummus\",\nname: \"Hummus\",\ningredients: [\n\"chickpeas\",\n\"olive oil\",\n\"garlic cloves\",\n\"lemon\",\n\"tahini\",\n],\n},\n];\n</code></pre> <p>Each of the <code>recipes</code> already includes an <code>id</code> field, so that's what the outer loop uses for its <code>key</code>. There is no ID you could use to loop over ingredients. However, it's reasonable to assume that the same ingredient won't be listed twice within the same recipe, so its name can serve as a <code>key</code>. Alternatively, you could change the data structure to add IDs, or use index as a <code>key</code> (with the caveat that you can't safely reorder ingredients).</p> <p></p>"},{"location":"learn/rendering-lists/#extracting-a-list-item-component","title":"Extracting a list item component","text":"<p>This <code>RecipeList</code> component contains two nested <code>map</code> calls. To simplify it, extract a <code>Recipe</code> component from it which will accept <code>id</code>, <code>name</code>, and <code>ingredients</code> props. Where do you place the outer <code>key</code> and why?</p> <pre><code>import { recipes } from \"./data.js\";\n\nexport default function RecipeList() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Recipes&lt;/h1&gt;\n{recipes.map((recipe) =&gt; (\n&lt;div key={recipe.id}&gt;\n&lt;h2&gt;{recipe.name}&lt;/h2&gt;\n&lt;ul&gt;\n{recipe.ingredients.map((ingredient) =&gt; (\n&lt;li key={ingredient}&gt;{ingredient}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n))}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export const recipes = [\n{\nid: \"greek-salad\",\nname: \"Greek Salad\",\ningredients: [\"tomatoes\", \"cucumber\", \"onion\", \"olives\", \"feta\"],\n},\n{\nid: \"hawaiian-pizza\",\nname: \"Hawaiian Pizza\",\ningredients: [\n\"pizza crust\",\n\"pizza sauce\",\n\"mozzarella\",\n\"ham\",\n\"pineapple\",\n],\n},\n{\nid: \"hummus\",\nname: \"Hummus\",\ningredients: [\n\"chickpeas\",\n\"olive oil\",\n\"garlic cloves\",\n\"lemon\",\n\"tahini\",\n],\n},\n];\n</code></pre> <p> <p>You can copy-paste the JSX from the outer <code>map</code> into a new <code>Recipe</code> component and return that JSX. Then you can change <code>recipe.name</code> to <code>name</code>, <code>recipe.id</code> to <code>id</code>, and so on, and pass them as props to the <code>Recipe</code>:</p> <pre><code>import { recipes } from \"./data.js\";\n\nfunction Recipe({ id, name, ingredients }) {\nreturn (\n&lt;div&gt;\n&lt;h2&gt;{name}&lt;/h2&gt;\n&lt;ul&gt;\n{ingredients.map((ingredient) =&gt; (\n&lt;li key={ingredient}&gt;{ingredient}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n);\n}\n\nexport default function RecipeList() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Recipes&lt;/h1&gt;\n{recipes.map((recipe) =&gt; (\n&lt;Recipe {...recipe} key={recipe.id} /&gt;\n))}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export const recipes = [\n{\nid: \"greek-salad\",\nname: \"Greek Salad\",\ningredients: [\"tomatoes\", \"cucumber\", \"onion\", \"olives\", \"feta\"],\n},\n{\nid: \"hawaiian-pizza\",\nname: \"Hawaiian Pizza\",\ningredients: [\n\"pizza crust\",\n\"pizza sauce\",\n\"mozzarella\",\n\"ham\",\n\"pineapple\",\n],\n},\n{\nid: \"hummus\",\nname: \"Hummus\",\ningredients: [\n\"chickpeas\",\n\"olive oil\",\n\"garlic cloves\",\n\"lemon\",\n\"tahini\",\n],\n},\n];\n</code></pre> <p>Here, <code>&lt;Recipe {...recipe} key={recipe.id} /&gt;</code> is a syntax shortcut saying \"pass all properties of the <code>recipe</code> object as props to the <code>Recipe</code> component\". You could also write each prop explicitly: <code>&lt;Recipe id={recipe.id} name={recipe.name} ingredients={recipe.ingredients} key={recipe.id} /&gt;</code>.</p> <p>Note that the <code>key</code> is specified on the <code>&lt;Recipe&gt;</code> itself rather than on the root <code>&lt;div&gt;</code> returned from <code>Recipe</code>. This is because this <code>key</code> is needed directly within the context of the surrounding array. Previously, you had an array of <code>&lt;div&gt;</code>s so each of them needed a <code>key</code>, but now you have an array of <code>&lt;Recipe&gt;</code>s. In other words, when you extract a component, don't forget to leave the <code>key</code> outside the JSX you copy and paste.</p> <p></p>"},{"location":"learn/rendering-lists/#list-with-a-separator","title":"List with a separator","text":"<p>This example renders a famous haiku by Katsushika Hokusai, with each line wrapped in a <code>&lt;p&gt;</code> tag. Your job is to insert an <code>&lt;hr /&gt;</code> separator between each paragraph. Your resulting structure should look like this:</p> <pre><code>&lt;article&gt;\n&lt;p&gt;I write, erase, rewrite&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;Erase again, and then&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;A poppy blooms.&lt;/p&gt;\n&lt;/article&gt;\n</code></pre> <p>A haiku only contains three lines, but your solution should work with any number of lines. Note that <code>&lt;hr /&gt;</code> elements only appear between the <code>&lt;p&gt;</code> elements, not in the beginning or the end!</p> <pre><code>const poem = {\nlines: [\n\"I write, erase, rewrite\",\n\"Erase again, and then\",\n\"A poppy blooms.\",\n],\n};\n\nexport default function Poem() {\nreturn (\n&lt;article&gt;\n{poem.lines.map((line, index) =&gt; (\n&lt;p key={index}&gt;{line}&lt;/p&gt;\n))}\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>body {\ntext-align: center;\n}\np {\nfont-family: Georgia, serif;\nfont-size: 20px;\nfont-style: italic;\n}\nhr {\nmargin: 0 120px 0 120px;\nborder: 1px dashed #45c3d8;\n}\n</code></pre> <p>(This is a rare case where index as a key is acceptable because a poem's lines will never reorder.)</p> <p> <p>You'll either need to convert <code>map</code> to a manual loop, or use a fragment.</p> <p></p> <p> <p>You can write a manual loop, inserting <code>&lt;hr /&gt;</code> and <code>&lt;p&gt;...&lt;/p&gt;</code> into the output array as you go:</p> <pre><code>const poem = {\nlines: [\n\"I write, erase, rewrite\",\n\"Erase again, and then\",\n\"A poppy blooms.\",\n],\n};\n\nexport default function Poem() {\nlet output = [];\n\n// Fill the output array\npoem.lines.forEach((line, i) =&gt; {\noutput.push(&lt;hr key={i + \"-separator\"} /&gt;);\noutput.push(&lt;p key={i + \"-text\"}&gt;{line}&lt;/p&gt;);\n});\n// Remove the first &lt;hr /&gt;\noutput.shift();\n\nreturn &lt;article&gt;{output}&lt;/article&gt;;\n}\n</code></pre> <pre><code>body {\ntext-align: center;\n}\np {\nfont-family: Georgia, serif;\nfont-size: 20px;\nfont-style: italic;\n}\nhr {\nmargin: 0 120px 0 120px;\nborder: 1px dashed #45c3d8;\n}\n</code></pre> <p>Using the original line index as a <code>key</code> doesn't work anymore because each separator and paragraph are now in the same array. However, you can give each of them a distinct key using a suffix, e.g. <code>key={i + '-text'}</code>.</p> <p>Alternatively, you could render a collection of fragments which contain <code>&lt;hr /&gt;</code> and <code>&lt;p&gt;...&lt;/p&gt;</code>. However, the <code>&lt;&gt;...</code> shorthand syntax doesn't support passing keys, so you'd have to write <code>&lt;Fragment&gt;</code> explicitly:</p> <pre><code>import { Fragment } from \"react\";\n\nconst poem = {\nlines: [\n\"I write, erase, rewrite\",\n\"Erase again, and then\",\n\"A poppy blooms.\",\n],\n};\n\nexport default function Poem() {\nreturn (\n&lt;article&gt;\n{poem.lines.map((line, i) =&gt; (\n&lt;Fragment key={i}&gt;\n{i &gt; 0 &amp;&amp; &lt;hr /&gt;}\n&lt;p&gt;{line}&lt;/p&gt;\n&lt;/Fragment&gt;\n))}\n&lt;/article&gt;\n);\n}\n</code></pre> <pre><code>body {\ntext-align: center;\n}\np {\nfont-family: Georgia, serif;\nfont-size: 20px;\nfont-style: italic;\n}\nhr {\nmargin: 0 120px 0 120px;\nborder: 1px dashed #45c3d8;\n}\n</code></pre> <p>Remember, fragments (often written as <code>&lt;&gt;</code>) let you group JSX nodes without adding extra <code>&lt;div&gt;</code>s!</p> <p></p> <p></p>"},{"location":"learn/responding-to-events/","title":"Responding to Events \ud83d\udea7","text":""},{"location":"learn/responding-to-events/#overview","title":"Overview","text":"<p>  React lets you add event handlers to your PSX. Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on.  </p> <p>You will learn</p> <ul> <li>Different ways to write an event handler</li> <li>How to pass event handling logic from a parent component</li> <li>How events propagate and how to stop them</li> </ul>"},{"location":"learn/responding-to-events/#adding-event-handlers","title":"Adding event handlers","text":"<p>To add an event handler, you will first define a function and then pass it as a prop to the appropriate PSX tag. For example, here is a button that doesn't do anything yet:</p> app.py Run <pre><code>@component\ndef button():\n    return html.button(\"I don't do anything\")\n</code></pre> <pre><code># TODO\n</code></pre> <p>You can make it show a message when a user clicks by following these three steps:</p> <ol> <li>Declare a function called <code>handle_click</code> inside your <code>def button():</code> component.</li> <li>Implement the logic inside that function (use <code>print</code> to show the message).</li> <li>Add <code>on_click=handle_click</code> to the <code>html.button</code> PSX.</li> </ol> app.pystyles.css Run <pre><code>from reactpy import component, html\n\n\n@component\ndef button():\n    def handle_click(event):\n        print(\"You clicked me!\")\n\n    return html.button({\"onClick\": handle_click}, \"Click me\")\n</code></pre> <pre><code>button {\nmargin-right: 10px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>You defined the <code>handleClick</code> function and then passed it as a prop to <code>&lt;button&gt;</code>. <code>handleClick</code> is an event handler. Event handler functions:</p> <ul> <li>Are usually defined inside your components.</li> <li>Have names that start with <code>handle</code>, followed by the name of the event.</li> </ul> <p>By convention, it is common to name event handlers as <code>handle</code> followed by the event name. You'll often see <code>on_click={handleClick}</code>, <code>onMouseEnter={handleMouseEnter}</code>, and so on.</p> <p>Alternatively, you can define an event handler inline in the JSX:</p> <pre><code>&lt;button on_click={function handleClick() {\nalert('You clicked me!');\n}}&gt;\n</code></pre> <p>Or, more concisely, using an arrow function:</p> <pre><code>&lt;button on_click={() =&gt; {\nalert('You clicked me!');\n}}&gt;\n</code></pre> <p>All of these styles are equivalent. Inline event handlers are convenient for short functions.</p> <p> <p>Functions passed to event handlers must be passed, not called. For example:</p> passing a function (correct) calling a function (incorrect) <code>&lt;button on_click={handleClick}&gt;</code> <code>&lt;button on_click={handleClick()}&gt;</code> <p>The difference is subtle. In the first example, the <code>handleClick</code> function is passed as an <code>on_click</code> event handler. This tells React to remember it and only call your function when the user clicks the button.</p> <p>In the second example, the <code>()</code> at the end of <code>handleClick()</code> fires the function immediately during rendering, without any clicks. This is because JavaScript inside the JSX <code>{</code> and <code>}</code> executes right away.</p> <p>When you write code inline, the same pitfall presents itself in a different way:</p> passing a function (correct) calling a function (incorrect) <code>&lt;button on_click={() =&gt; alert('...')}&gt;</code> <code>&lt;button on_click={alert('...')}&gt;</code> <p>Passing inline code like this won't fire on click\u2014it fires every time the component renders:</p> <pre><code>// This alert fires when the component renders, not when clicked!\n&lt;button on_click={alert('You clicked me!')}&gt;\n</code></pre> <p>If you want to define your event handler inline, wrap it in an anonymous function like so:</p> <pre><code>&lt;button on_click={() =&gt; alert('You clicked me!')}&gt;\n</code></pre> <p>Rather than executing the code inside with every render, this creates a function to be called later.</p> <p>In both cases, what you want to pass is a function:</p> <ul> <li><code>&lt;button on_click={handleClick}&gt;</code> passes the <code>handleClick</code> function.</li> <li><code>&lt;button on_click={() =&gt; alert('...')}&gt;</code> passes the <code>() =&gt; alert('...')</code> function.</li> </ul> <p>Read more about arrow functions.</p> <p></p>"},{"location":"learn/responding-to-events/#reading-props-in-event-handlers","title":"Reading props in event handlers","text":"<p>Because event handlers are declared inside of a component, they have access to the component's props. Here is a button that, when clicked, shows an alert with its <code>message</code> prop:</p> <pre><code>function AlertButton({ message, children }) {\nreturn &lt;button on_click={() =&gt; alert(message)}&gt;{children}&lt;/button&gt;;\n}\n\nexport default function Toolbar() {\nreturn (\n&lt;div&gt;\n&lt;AlertButton message=\"Playing!\"&gt;Play Movie&lt;/AlertButton&gt;\n&lt;AlertButton message=\"Uploading!\"&gt;Upload Image&lt;/AlertButton&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-right: 10px;\n}\n</code></pre> <p>This lets these two buttons show different messages. Try changing the messages passed to them.</p>"},{"location":"learn/responding-to-events/#passing-event-handlers-as-props","title":"Passing event handlers as props","text":"<p>Often you'll want the parent component to specify a child's event handler. Consider buttons: depending on where you're using a <code>Button</code> component, you might want to execute a different function\u2014perhaps one plays a movie and another uploads an image.</p> <p>To do this, pass a prop the component receives from its parent as the event handler like so:</p> <pre><code>function Button({ on_click, children }) {\nreturn &lt;button on_click={on_click}&gt;{children}&lt;/button&gt;;\n}\n\nfunction PlayButton({ movieName }) {\nfunction handlePlayClick() {\nalert(`Playing ${movieName}!`);\n}\n\nreturn &lt;Button on_click={handlePlayClick}&gt;Play \"{movieName}\"&lt;/Button&gt;;\n}\n\nfunction UploadButton() {\nreturn &lt;Button on_click={() =&gt; alert(\"Uploading!\")}&gt;Upload Image&lt;/Button&gt;;\n}\n\nexport default function Toolbar() {\nreturn (\n&lt;div&gt;\n&lt;PlayButton movieName=\"Kiki's Delivery Service\" /&gt;\n&lt;UploadButton /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-right: 10px;\n}\n</code></pre> <p>Here, the <code>Toolbar</code> component renders a <code>PlayButton</code> and an <code>UploadButton</code>:</p> <ul> <li><code>PlayButton</code> passes <code>handlePlayClick</code> as the <code>on_click</code> prop to the <code>Button</code> inside.</li> <li><code>UploadButton</code> passes <code>() =&gt; alert('Uploading!')</code> as the <code>on_click</code> prop to the <code>Button</code> inside.</li> </ul> <p>Finally, your <code>Button</code> component accepts a prop called <code>on_click</code>. It passes that prop directly to the built-in browser <code>&lt;button&gt;</code> with <code>on_click={on_click}</code>. This tells React to call the passed function on click.</p> <p>If you use a design system, it's common for components like buttons to contain styling but not specify behavior. Instead, components like <code>PlayButton</code> and <code>UploadButton</code> will pass event handlers down.</p>"},{"location":"learn/responding-to-events/#naming-event-handler-props","title":"Naming event handler props","text":"<p>Built-in components like <code>&lt;button&gt;</code> and <code>&lt;div&gt;</code> only support browser event names like <code>on_click</code>. However, when you're building your own components, you can name their event handler props any way that you like.</p> <p>By convention, event handler props should start with <code>on</code>, followed by a capital letter.</p> <p>For example, the <code>Button</code> component's <code>on_click</code> prop could have been called <code>onSmash</code>:</p> <pre><code>function Button({ onSmash, children }) {\nreturn &lt;button on_click={onSmash}&gt;{children}&lt;/button&gt;;\n}\n\nexport default function App() {\nreturn (\n&lt;div&gt;\n&lt;Button onSmash={() =&gt; alert(\"Playing!\")}&gt;Play Movie&lt;/Button&gt;\n&lt;Button onSmash={() =&gt; alert(\"Uploading!\")}&gt;Upload Image&lt;/Button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-right: 10px;\n}\n</code></pre> <p>In this example, <code>&lt;button on_click={onSmash}&gt;</code> shows that the browser <code>&lt;button&gt;</code> (lowercase) still needs a prop called <code>on_click</code>, but the prop name received by your custom <code>Button</code> component is up to you!</p> <p>When your component supports multiple interactions, you might name event handler props for app-specific concepts. For example, this <code>Toolbar</code> component receives <code>onPlayMovie</code> and <code>onUploadImage</code> event handlers:</p> <pre><code>export default function App() {\nreturn (\n&lt;Toolbar\nonPlayMovie={() =&gt; alert(\"Playing!\")}\nonUploadImage={() =&gt; alert(\"Uploading!\")}\n/&gt;\n);\n}\n\nfunction Toolbar({ onPlayMovie, onUploadImage }) {\nreturn (\n&lt;div&gt;\n&lt;Button on_click={onPlayMovie}&gt;Play Movie&lt;/Button&gt;\n&lt;Button on_click={onUploadImage}&gt;Upload Image&lt;/Button&gt;\n&lt;/div&gt;\n);\n}\n\nfunction Button({ on_click, children }) {\nreturn &lt;button on_click={on_click}&gt;{children}&lt;/button&gt;;\n}\n</code></pre> <pre><code>button {\nmargin-right: 10px;\n}\n</code></pre> <p>Notice how the <code>App</code> component does not need to know what <code>Toolbar</code> will do with <code>onPlayMovie</code> or <code>onUploadImage</code>. That's an implementation detail of the <code>Toolbar</code>. Here, <code>Toolbar</code> passes them down as <code>on_click</code> handlers to its <code>Button</code>s, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions like <code>onPlayMovie</code> gives you the flexibility to change how they're used later.</p> <p> <p>Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use <code>&lt;button on_click={handleClick}&gt;</code> instead of <code>&lt;div on_click={handleClick}&gt;</code>. Using a real browser <code>&lt;button&gt;</code> enables built-in browser behaviors like keyboard navigation. If you don't like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS. Learn more about writing accessible markup.</p> <p></p>"},{"location":"learn/responding-to-events/#event-propagation","title":"Event propagation","text":"<p>Event handlers will also catch events from any children your component might have. We say that an event \"bubbles\" or \"propagates\" up the tree: it starts with where the event happened, and then goes up the tree.</p> <p>This <code>&lt;div&gt;</code> contains two buttons. Both the <code>&lt;div&gt;</code> and each button have their own <code>on_click</code> handlers. Which handlers do you think will fire when you click a button?</p> <pre><code>export default function Toolbar() {\nreturn (\n&lt;div\nclassName=\"Toolbar\"\non_click={() =&gt; {\nalert(\"You clicked on the toolbar!\");\n}}\n&gt;\n&lt;button on_click={() =&gt; alert(\"Playing!\")}&gt;Play Movie&lt;/button&gt;\n&lt;button on_click={() =&gt; alert(\"Uploading!\")}&gt;Upload Image&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.Toolbar {\nbackground: #aaa;\npadding: 5px;\n}\nbutton {\nmargin: 5px;\n}\n</code></pre> <p>If you click on either button, its <code>on_click</code> will run first, followed by the parent <code>&lt;div&gt;</code>'s <code>on_click</code>. So two messages will appear. If you click the toolbar itself, only the parent <code>&lt;div&gt;</code>'s <code>on_click</code> will run.</p> <p> <p>All events propagate in React except <code>onScroll</code>, which only works on the JSX tag you attach it to.</p> <p></p>"},{"location":"learn/responding-to-events/#stopping-propagation","title":"Stopping propagation","text":"<p>Event handlers receive an event object as their only argument. By convention, it's usually called <code>e</code>, which stands for \"event\". You can use this object to read information about the event.</p> <p>That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to call <code>e.stopPropagation()</code> like this <code>Button</code> component does:</p> <pre><code>function Button({ on_click, children }) {\nreturn (\n&lt;button\non_click={(e) =&gt; {\ne.stopPropagation();\non_click();\n}}\n&gt;\n{children}\n&lt;/button&gt;\n);\n}\n\nexport default function Toolbar() {\nreturn (\n&lt;div\nclassName=\"Toolbar\"\non_click={() =&gt; {\nalert(\"You clicked on the toolbar!\");\n}}\n&gt;\n&lt;Button on_click={() =&gt; alert(\"Playing!\")}&gt;Play Movie&lt;/Button&gt;\n&lt;Button on_click={() =&gt; alert(\"Uploading!\")}&gt;Upload Image&lt;/Button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>.Toolbar {\nbackground: #aaa;\npadding: 5px;\n}\nbutton {\nmargin: 5px;\n}\n</code></pre> <p>When you click on a button:</p> <ol> <li>React calls the <code>on_click</code> handler passed to <code>&lt;button&gt;</code>.</li> <li>That handler, defined in <code>Button</code>, does the following:<ul> <li>Calls <code>e.stopPropagation()</code>, preventing the event from bubbling further.</li> <li>Calls the <code>on_click</code> function, which is a prop passed from the <code>Toolbar</code> component.</li> </ul> </li> <li>That function, defined in the <code>Toolbar</code> component, displays the button's own alert.</li> <li>Since the propagation was stopped, the parent <code>&lt;div&gt;</code>'s <code>on_click</code> handler does not run.</li> </ol> <p>As a result of <code>e.stopPropagation()</code>, clicking on the buttons now only shows a single alert (from the <code>&lt;button&gt;</code>) rather than the two of them (from the <code>&lt;button&gt;</code> and the parent toolbar <code>&lt;div&gt;</code>). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI.</p> <p>"},{"location":"learn/responding-to-events/#capture-phase-events","title":"Capture phase events","text":"<p>In rare cases, you might need to catch all events on child elements, even if they stopped propagation. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by adding <code>Capture</code> at the end of the event name:</p> <pre><code>&lt;div\non_clickCapture={() =&gt; {\n/* this runs first */\n}}\n&gt;\n&lt;button on_click={(e) =&gt; e.stopPropagation()} /&gt;\n&lt;button on_click={(e) =&gt; e.stopPropagation()} /&gt;\n&lt;/div&gt;\n</code></pre> <p>Each event propagates in three phases:</p> <ol> <li>It travels down, calling all <code>on_clickCapture</code> handlers.</li> <li>It runs the clicked element's <code>on_click</code> handler.</li> <li>It travels upwards, calling all <code>on_click</code> handlers.</li> </ol> <p>Capture events are useful for code like routers or analytics, but you probably won't use them in app code.</p> <p></p>"},{"location":"learn/responding-to-events/#passing-handlers-as-alternative-to-propagation","title":"Passing handlers as alternative to propagation","text":"<p>Notice how this click handler runs a line of code and then calls the <code>on_click</code> prop passed by the parent:</p> <pre><code>function Button({ on_click, children }) {\nreturn (\n&lt;button\non_click={(e) =&gt; {\ne.stopPropagation();\non_click();\n}}\n&gt;\n{children}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>You could add more code to this handler before calling the parent <code>on_click</code> event handler, too. This pattern provides an alternative to propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it's not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event.</p> <p>If you rely on propagation and it's difficult to trace which handlers execute and why, try this approach instead.</p>"},{"location":"learn/responding-to-events/#preventing-default-behavior","title":"Preventing default behavior","text":"<p>Some browser events have default behavior associated with them. For example, a <code>&lt;form&gt;</code> submit event, which happens when a button inside of it is clicked, will reload the whole page by default:</p> <pre><code>export default function Signup() {\nreturn (\n&lt;form onSubmit={() =&gt; alert(\"Submitting!\")}&gt;\n&lt;input /&gt;\n&lt;button&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-left: 5px;\n}\n</code></pre> <p>You can call <code>e.preventDefault()</code> on the event object to stop this from happening:</p> <pre><code>export default function Signup() {\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nalert(\"Submitting!\");\n}}\n&gt;\n&lt;input /&gt;\n&lt;button&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-left: 5px;\n}\n</code></pre> <p>Don't confuse <code>e.stopPropagation()</code> and <code>e.preventDefault()</code>. They are both useful, but are unrelated:</p> <ul> <li><code>e.stopPropagation()</code> stops the event handlers attached to the tags above from firing.</li> <li><code>e.preventDefault()</code>  prevents the default browser behavior for the few events that have it.</li> </ul>"},{"location":"learn/responding-to-events/#can-event-handlers-have-side-effects","title":"Can event handlers have side effects?","text":"<p>Absolutely! Event handlers are the best place for side effects.</p> <p>Unlike rendering functions, event handlers don't need to be pure, so it's a great place to change something\u2014for example, change an input's value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by using state, a component's memory. You will learn all about it on the next page.</p> <p> <ul> <li>You can handle events by passing a function as a prop to an element like <code>&lt;button&gt;</code>.</li> <li>Event handlers must be passed, not called! <code>on_click={handleClick}</code>, not <code>on_click={handleClick()}</code>.</li> <li>You can define an event handler function separately or inline.</li> <li>Event handlers are defined inside a component, so they can access props.</li> <li>You can declare an event handler in a parent and pass it as a prop to a child.</li> <li>You can define your own event handler props with application-specific names.</li> <li>Events propagate upwards. Call <code>e.stopPropagation()</code> on the first argument to prevent that.</li> <li>Events may have unwanted default browser behavior. Call <code>e.preventDefault()</code> to prevent that.</li> <li>Explicitly calling an event handler prop from a child handler is a good alternative to propagation.</li> </ul> <p></p> <p>"},{"location":"learn/responding-to-events/#fix-an-event-handler","title":"Fix an event handler","text":"<p>Clicking this button is supposed to switch the page background between white and black. However, nothing happens when you click it. Fix the problem. (Don't worry about the logic inside <code>handleClick</code>\u2014that part is fine.)</p> <pre><code>export default function LightSwitch() {\nfunction handleClick() {\nlet bodyStyle = document.body.style;\nif (bodyStyle.backgroundColor === \"black\") {\nbodyStyle.backgroundColor = \"white\";\n} else {\nbodyStyle.backgroundColor = \"black\";\n}\n}\n\nreturn &lt;button on_click={handleClick()}&gt;Toggle the lights&lt;/button&gt;;\n}\n</code></pre> <p> <p>The problem is that <code>&lt;button on_click={handleClick()}&gt;</code> calls the <code>handleClick</code> function while rendering instead of passing it. Removing the <code>()</code> call so that it's <code>&lt;button on_click={handleClick}&gt;</code> fixes the issue:</p> <pre><code>export default function LightSwitch() {\nfunction handleClick() {\nlet bodyStyle = document.body.style;\nif (bodyStyle.backgroundColor === \"black\") {\nbodyStyle.backgroundColor = \"white\";\n} else {\nbodyStyle.backgroundColor = \"black\";\n}\n}\n\nreturn &lt;button on_click={handleClick}&gt;Toggle the lights&lt;/button&gt;;\n}\n</code></pre> <p>Alternatively, you could wrap the call into another function, like <code>&lt;button on_click={() =&gt; handleClick()}&gt;</code>:</p> <pre><code>export default function LightSwitch() {\nfunction handleClick() {\nlet bodyStyle = document.body.style;\nif (bodyStyle.backgroundColor === \"black\") {\nbodyStyle.backgroundColor = \"white\";\n} else {\nbodyStyle.backgroundColor = \"black\";\n}\n}\n\nreturn &lt;button on_click={() =&gt; handleClick()}&gt;Toggle the lights&lt;/button&gt;;\n}\n</code></pre> <p></p>"},{"location":"learn/responding-to-events/#wire-up-the-events","title":"Wire up the events","text":"<p>This <code>ColorSwitch</code> component renders a button. It's supposed to change the page color. Wire it up to the <code>onChangeColor</code> event handler prop it receives from the parent so that clicking the button changes the color.</p> <p>After you do this, notice that clicking the button also increments the page click counter. Your colleague who wrote the parent component insists that <code>onChangeColor</code> does not increment any counters. What else might be happening? Fix it so that clicking the button only changes the color, and does not increment the counter.</p> <pre><code>export default function ColorSwitch({ onChangeColor }) {\nreturn &lt;button&gt;Change color&lt;/button&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport ColorSwitch from \"./ColorSwitch.js\";\n\nexport default function App() {\nconst [clicks, setClicks] = useState(0);\n\nfunction handleClickOutside() {\nsetClicks((c) =&gt; c + 1);\n}\n\nfunction getRandomLightColor() {\nlet r = 150 + Math.round(100 * Math.random());\nlet g = 150 + Math.round(100 * Math.random());\nlet b = 150 + Math.round(100 * Math.random());\nreturn `rgb(${r}, ${g}, ${b})`;\n}\n\nfunction handleChangeColor() {\nlet bodyStyle = document.body.style;\nbodyStyle.backgroundColor = getRandomLightColor();\n}\n\nreturn (\n&lt;div\nstyle={{ width: \"100%\", height: \"100%\" }}\non_click={handleClickOutside}\n&gt;\n&lt;ColorSwitch onChangeColor={handleChangeColor} /&gt;\n&lt;br /&gt;\n&lt;br /&gt;\n&lt;h2&gt;Clicks on the page: {clicks}&lt;/h2&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p> <p>First, you need to add the event handler, like <code>&lt;button on_click={onChangeColor}&gt;</code>.</p> <p>However, this introduces the problem of the incrementing counter. If <code>onChangeColor</code> does not do this, as your colleague insists, then the problem is that this event propagates up, and some handler above does it. To solve this problem, you need to stop the propagation. But don't forget that you should still call <code>onChangeColor</code>.</p> <pre><code>export default function ColorSwitch({ onChangeColor }) {\nreturn (\n&lt;button\non_click={(e) =&gt; {\ne.stopPropagation();\nonChangeColor();\n}}\n&gt;\nChange color\n&lt;/button&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport ColorSwitch from \"./ColorSwitch.js\";\n\nexport default function App() {\nconst [clicks, setClicks] = useState(0);\n\nfunction handleClickOutside() {\nsetClicks((c) =&gt; c + 1);\n}\n\nfunction getRandomLightColor() {\nlet r = 150 + Math.round(100 * Math.random());\nlet g = 150 + Math.round(100 * Math.random());\nlet b = 150 + Math.round(100 * Math.random());\nreturn `rgb(${r}, ${g}, ${b})`;\n}\n\nfunction handleChangeColor() {\nlet bodyStyle = document.body.style;\nbodyStyle.backgroundColor = getRandomLightColor();\n}\n\nreturn (\n&lt;div\nstyle={{ width: \"100%\", height: \"100%\" }}\non_click={handleClickOutside}\n&gt;\n&lt;ColorSwitch onChangeColor={handleChangeColor} /&gt;\n&lt;br /&gt;\n&lt;br /&gt;\n&lt;h2&gt;Clicks on the page: {clicks}&lt;/h2&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/","title":"Reusing Logic with Custom Hooks \ud83d\udea7","text":""},{"location":"learn/reusing-logic-with-custom-hooks/#overview","title":"Overview","text":"<p>  React comes with several built-in Hooks like <code>useState</code>, <code>useContext</code>, and <code>useEffect</code>. Sometimes, you'll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application's needs.  </p> <p>You will learn</p> <ul> <li>What custom Hooks are, and how to write your own</li> <li>How to reuse logic between components</li> <li>How to name and structure your custom Hooks</li> <li>When and why to extract custom Hooks</li> </ul>"},{"location":"learn/reusing-logic-with-custom-hooks/#custom-hooks-sharing-logic-between-components","title":"Custom Hooks: Sharing logic between components","text":"<p>Imagine you're developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you'll need two things in your component:</p> <ol> <li>A piece of state that tracks whether the network is online.</li> <li>An Effect that subscribes to the global <code>online</code> and <code>offline</code> events, and updates that state.</li> </ol> <p>This will keep your component synchronized with the network status. You might start with something like this:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function StatusBar() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction handleOnline() {\nsetIsOnline(true);\n}\nfunction handleOffline() {\nsetIsOnline(false);\n}\nwindow.addEventListener(\"online\", handleOnline);\nwindow.addEventListener(\"offline\", handleOffline);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", handleOnline);\nwindow.removeEventListener(\"offline\", handleOffline);\n};\n}, []);\n\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n</code></pre> <p>Try turning your network on and off, and notice how this <code>StatusBar</code> updates in response to your actions.</p> <p>Now imagine you also want to use the same logic in a different component. You want to implement a Save button that will become disabled and show \"Reconnecting...\" instead of \"Save\" while the network is off.</p> <p>To start, you can copy and paste the <code>isOnline</code> state and the Effect into <code>SaveButton</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function SaveButton() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction handleOnline() {\nsetIsOnline(true);\n}\nfunction handleOffline() {\nsetIsOnline(false);\n}\nwindow.addEventListener(\"online\", handleOnline);\nwindow.addEventListener(\"offline\", handleOffline);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", handleOnline);\nwindow.removeEventListener(\"offline\", handleOffline);\n};\n}, []);\n\nfunction handleSaveClick() {\nconsole.log(\"\u2705 Progress saved\");\n}\n\nreturn (\n&lt;button disabled={!isOnline} on_click={handleSaveClick}&gt;\n{isOnline ? \"Save progress\" : \"Reconnecting...\"}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>Verify that, if you turn off the network, the button will change its appearance.</p> <p>These two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have different visual appearance, you want to reuse the logic between them.</p>"},{"location":"learn/reusing-logic-with-custom-hooks/#extracting-your-own-custom-hook-from-a-component","title":"Extracting your own custom Hook from a component","text":"<p>Imagine for a moment that, similar to <code>useState</code> and <code>useEffect</code>, there was a built-in <code>useOnlineStatus</code> Hook. Then both of these components could be simplified and you could remove the duplication between them:</p> <pre><code>function StatusBar() {\nconst isOnline = useOnlineStatus();\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n\nfunction handleSaveClick() {\nconsole.log(\"\u2705 Progress saved\");\n}\n\nreturn (\n&lt;button disabled={!isOnline} on_click={handleSaveClick}&gt;\n{isOnline ? \"Save progress\" : \"Reconnecting...\"}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>Although there is no such built-in Hook, you can write it yourself. Declare a function called <code>useOnlineStatus</code> and move all the duplicated code into it from the components you wrote earlier:</p> <pre><code>function useOnlineStatus() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction handleOnline() {\nsetIsOnline(true);\n}\nfunction handleOffline() {\nsetIsOnline(false);\n}\nwindow.addEventListener(\"online\", handleOnline);\nwindow.addEventListener(\"offline\", handleOffline);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", handleOnline);\nwindow.removeEventListener(\"offline\", handleOffline);\n};\n}, []);\nreturn isOnline;\n}\n</code></pre> <p>At the end of the function, return <code>isOnline</code>. This lets your components read that value:</p> <pre><code>import { useOnlineStatus } from \"./useOnlineStatus.js\";\n\nfunction StatusBar() {\nconst isOnline = useOnlineStatus();\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n\nfunction handleSaveClick() {\nconsole.log(\"\u2705 Progress saved\");\n}\n\nreturn (\n&lt;button disabled={!isOnline} on_click={handleSaveClick}&gt;\n{isOnline ? \"Save progress\" : \"Reconnecting...\"}\n&lt;/button&gt;\n);\n}\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;SaveButton /&gt;\n&lt;StatusBar /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useOnlineStatus() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction handleOnline() {\nsetIsOnline(true);\n}\nfunction handleOffline() {\nsetIsOnline(false);\n}\nwindow.addEventListener(\"online\", handleOnline);\nwindow.addEventListener(\"offline\", handleOffline);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", handleOnline);\nwindow.removeEventListener(\"offline\", handleOffline);\n};\n}, []);\nreturn isOnline;\n}\n</code></pre> <p>Verify that switching the network on and off updates both components.</p> <p>Now your components don't have as much repetitive logic. More importantly, the code inside them describes what they want to do (use the online status!) rather than how to do it (by subscribing to the browser events).</p> <p>When you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation.</p>"},{"location":"learn/reusing-logic-with-custom-hooks/#hook-names-always-start-with-use","title":"Hook names always start with <code>use</code>","text":"<p>React applications are built from components. Components are built from Hooks, whether built-in or custom. You'll likely often use custom Hooks created by others, but occasionally you might write one yourself!</p> <p>You must follow these naming conventions:</p> <ol> <li>React component names must start with a capital letter, like <code>StatusBar</code> and <code>SaveButton</code>. React components also need to return something that React knows how to display, like a piece of JSX.</li> <li>Hook names must start with <code>use</code> followed by a capital letter, like <code>useState</code> (built-in) or <code>useOnlineStatus</code> (custom, like earlier on the page). Hooks may return arbitrary values.</li> </ol> <p>This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might \"hide\". For example, if you see a <code>getColor()</code> function call inside your component, you can be sure that it can't possibly contain React state inside because its name doesn't start with <code>use</code>. However, a function call like <code>useOnlineStatus()</code> will most likely contain calls to other Hooks inside!</p> <p> <p>If your linter is configured for React, it will enforce this naming convention. Scroll up to the sandbox above and rename <code>useOnlineStatus</code> to <code>getOnlineStatus</code>. Notice that the linter won't allow you to call <code>useState</code> or <code>useEffect</code> inside of it anymore. Only Hooks and components can call other Hooks!</p> <p></p> <p>"},{"location":"learn/reusing-logic-with-custom-hooks/#should-all-functions-called-during-rendering-start-with-the-use-prefix","title":"Should all functions called during rendering start with the use prefix?","text":"<p>No. Functions that don't call Hooks don't need to be Hooks.</p> <p>If your function doesn't call any Hooks, avoid the <code>use</code> prefix. Instead, write it as a regular function without the <code>use</code> prefix. For example, <code>useSorted</code> below doesn't call Hooks, so call it <code>getSorted</code> instead:</p> <pre><code>// \ud83d\udd34 Avoid: A Hook that doesn't use Hooks\nfunction useSorted(items) {\nreturn items.slice().sort();\n}\n\n// \u2705 Good: A regular function that doesn't use Hooks\nfunction getSorted(items) {\nreturn items.slice().sort();\n}\n</code></pre> <p>This ensures that your code can call this regular function anywhere, including conditions:</p> <pre><code>function List({ items, shouldSort }) {\nlet displayedItems = items;\nif (shouldSort) {\n// \u2705 It's ok to call getSorted() conditionally because it's not a Hook\ndisplayedItems = getSorted(items);\n}\n// ...\n}\n</code></pre> <p>You should give <code>use</code> prefix to a function (and thus make it a Hook) if it uses at least one Hook inside of it:</p> <pre><code>// \u2705 Good: A Hook that uses other Hooks\nfunction useAuth() {\nreturn useContext(Auth);\n}\n</code></pre> <p>Technically, this isn't enforced by React. In principle, you could make a Hook that doesn't call other Hooks. This is often confusing and limiting so it's best to avoid that pattern. However, there may be rare cases where it is helpful. For example, maybe your function doesn't use any Hooks right now, but you plan to add some Hook calls to it in the future. Then it makes sense to name it with the <code>use</code> prefix:</p> <pre><code>// \u2705 Good: A Hook that will likely use some other Hooks later\nfunction useAuth() {\n// TODO: Replace with this line when authentication is implemented:\n// return useContext(Auth);\nreturn TEST_USER;\n}\n</code></pre> <p>Then components won't be able to call it conditionally. This will become important when you actually add Hook calls inside. If you don't plan to use Hooks inside it (now or later), don't make it a Hook.</p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#custom-hooks-let-you-share-stateful-logic-not-state-itself","title":"Custom Hooks let you share stateful logic, not state itself","text":"<p>In the earlier example, when you turned the network on and off, both components updated together. However, it's wrong to think that a single <code>isOnline</code> state variable is shared between them. Look at this code:</p> <pre><code>function StatusBar() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n</code></pre> <p>It works the same way as before you extracted the duplication:</p> <pre><code>function StatusBar() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\n// ...\n}, []);\n// ...\n}\n\nfunction SaveButton() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\n// ...\n}, []);\n// ...\n}\n</code></pre> <p>These are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on).</p> <p>To better illustrate this, we'll need a different example. Consider this <code>Form</code> component:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [firstName, setFirstName] = useState(\"Mary\");\nconst [lastName, setLastName] = useState(\"Poppins\");\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input value={firstName} onChange={handleFirstNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input value={lastName} onChange={handleLastNameChange} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\n&lt;b&gt;\nGood morning, {firstName} {lastName}.\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 10px;\n}\n</code></pre> <p>There's some repetitive logic for each form field:</p> <ol> <li>There's a piece of state (<code>firstName</code> and <code>lastName</code>).</li> <li>There's a change handler (<code>handleFirstNameChange</code> and <code>handleLastNameChange</code>).</li> <li>There's a piece of JSX that specifies the <code>value</code> and <code>onChange</code> attributes for that input.</li> </ol> <p>You can extract the repetitive logic into this <code>useFormInput</code> custom Hook:</p> <pre><code>import { useFormInput } from \"./useFormInput.js\";\n\nexport default function Form() {\nconst firstNameProps = useFormInput(\"Mary\");\nconst lastNameProps = useFormInput(\"Poppins\");\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input {...firstNameProps} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input {...lastNameProps} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\n&lt;b&gt;\nGood morning, {firstNameProps.value} {lastNameProps.value}.\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport function useFormInput(initialValue) {\nconst [value, setValue] = useState(initialValue);\n\nfunction handleChange(e) {\nsetValue(e.target.value);\n}\n\nconst inputProps = {\nvalue: value,\nonChange: handleChange,\n};\n\nreturn inputProps;\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 10px;\n}\n</code></pre> <p>Notice that it only declares one state variable called <code>value</code>.</p> <p>However, the <code>Form</code> component calls <code>useFormInput</code> two times:</p> <pre><code>function Form() {\nconst firstNameProps = useFormInput('Mary');\nconst lastNameProps = useFormInput('Poppins');\n// ...\n</code></pre> <p>This is why it works like declaring two separate state variables!</p> <p>Custom Hooks let you share stateful logic but not state itself. Each call to a Hook is completely independent from every other call to the same Hook. This is why the two sandboxes above are completely equivalent. If you'd like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical.</p> <p>When you need to share the state itself between multiple components, lift it up and pass it down instead.</p>"},{"location":"learn/reusing-logic-with-custom-hooks/#passing-reactive-values-between-hooks","title":"Passing reactive values between Hooks","text":"<p>The code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooks need to be pure. Think of custom Hooks' code as part of your component's body!</p> <p>Because custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nexport default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.on(\"message\", (msg) =&gt; {\nshowNotification(\"New message: \" + msg);\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c Disconnected from \"' +\nroomId +\n'\" room at ' +\nserverUrl +\n\"\"\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme = \"dark\") {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>When you change <code>serverUrl</code> or <code>roomId</code>, the Effect \"reacts\" to your changes and re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect's dependencies.</p> <p>Now move the Effect's code into a custom Hook:</p> <pre><code>export function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nshowNotification(\"New message: \" + msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <p>This lets your <code>ChatRoom</code> component call your custom Hook without worrying about how it works inside:</p> <pre><code>export default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>This looks much simpler! (But it does the same thing.)</p> <p>Notice that the logic still responds to prop and state changes. Try editing the server URL or the selected room:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useChatRoom } from \"./useChatRoom.js\";\n\nexport default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nexport function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nshowNotification(\"New message: \" + msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c Disconnected from \"' +\nroomId +\n'\" room at ' +\nserverUrl +\n\"\"\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme = \"dark\") {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Notice how you're taking the return value of one Hook:</p> <pre><code>export default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl\n});\n// ...\n</code></pre> <p>and pass it as an input to another Hook:</p> <pre><code>export default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl\n});\n// ...\n</code></pre> <p>Every time your <code>ChatRoom</code> component re-renders, it passes the latest <code>roomId</code> and <code>serverUrl</code> to your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It's as if the output of <code>useState</code> \"feeds into\" the input of the <code>useChatRoom</code>.)</p>"},{"location":"learn/reusing-logic-with-custom-hooks/#passing-event-handlers-to-custom-hooks","title":"Passing event handlers to custom Hooks","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>As you start using <code>useChatRoom</code> in more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:</p> <pre><code>export function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nshowNotification(\"New message: \" + msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <p>Let's say you want to move this logic back to your component:</p> <pre><code>export default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\nonReceiveMessage(msg) {\nshowNotification('New message: ' + msg);\n}\n});\n// ...\n</code></pre> <p>To make this work, change your custom Hook to take <code>onReceiveMessage</code> as one of its named options:</p> <pre><code>export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nonReceiveMessage(msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl, onReceiveMessage]); // \u2705 All dependencies declared\n}\n</code></pre> <p>This will work, but there's one more improvement you can do when your custom Hook accepts event handlers.</p> <p>Adding a dependency on <code>onReceiveMessage</code> is not ideal because it will cause the chat to re-connect every time the component re-renders. Wrap this event handler into an Effect Event to remove it from the dependencies:</p> <pre><code>import { useEffect, useEffectEvent } from \"react\";\n// ...\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\nconst onMessage = useEffectEvent(onReceiveMessage);\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nonMessage(msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]); // \u2705 All dependencies declared\n}\n</code></pre> <p>Now the chat won't re-connect every time that the <code>ChatRoom</code> component re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:</p> <pre><code>import { useState } from \"react\";\nimport ChatRoom from \"./ChatRoom.js\";\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useChatRoom } from \"./useChatRoom.js\";\nimport { showNotification } from \"./notifications.js\";\n\nexport default function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\nonReceiveMessage(msg) {\nshowNotification(\"New message: \" + msg);\n},\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\nconst onMessage = useEffectEvent(onReceiveMessage);\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nconnection.on(\"message\", (msg) =&gt; {\nonMessage(msg);\n});\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nif (typeof serverUrl !== \"string\") {\nthrow Error(\n\"Expected serverUrl to be a string. Received: \" + serverUrl\n);\n}\nif (typeof roomId !== \"string\") {\nthrow Error(\"Expected roomId to be a string. Received: \" + roomId);\n}\nlet intervalId;\nlet messageCallback;\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\nclearInterval(intervalId);\nintervalId = setInterval(() =&gt; {\nif (messageCallback) {\nif (Math.random() &gt; 0.5) {\nmessageCallback(\"hey\");\n} else {\nmessageCallback(\"lol\");\n}\n}\n}, 3000);\n},\ndisconnect() {\nclearInterval(intervalId);\nmessageCallback = null;\nconsole.log(\n'\u274c Disconnected from \"' +\nroomId +\n'\" room at ' +\nserverUrl +\n\"\"\n);\n},\non(event, callback) {\nif (messageCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"message\") {\nthrow Error('Only \"message\" event is supported.');\n}\nmessageCallback = callback;\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme = \"dark\") {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Notice how you no longer need to know how <code>useChatRoom</code> works in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That's the power of custom Hooks.</p>"},{"location":"learn/reusing-logic-with-custom-hooks/#when-to-use-custom-hooks","title":"When to use custom Hooks","text":"<p>You don't need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting a <code>useFormInput</code> Hook to wrap a single <code>useState</code> call like earlier is probably unnecessary.</p> <p>However, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook. You shouldn't need Effects very often, so if you're writing one, it means that you need to \"step outside React\" to synchronize with some external system or to do something that React doesn't have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it.</p> <p>For example, consider a <code>ShippingForm</code> component that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:</p> <pre><code>function ShippingForm({ country }) {\nconst [cities, setCities] = useState(null);\n// This Effect fetches cities for a country\nuseEffect(() =&gt; {\nlet ignore = false;\nfetch(`/api/cities?country=${country}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetCities(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [country]);\n\nconst [city, setCity] = useState(null);\nconst [areas, setAreas] = useState(null);\n// This Effect fetches areas for the selected city\nuseEffect(() =&gt; {\nif (city) {\nlet ignore = false;\nfetch(`/api/areas?city=${city}`)\n.then(response =&gt; response.json())\n.then(json =&gt; {\nif (!ignore) {\nsetAreas(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}\n}, [city]);\n\n// ...\n</code></pre> <p>Although this code is quite repetitive, it's correct to keep these Effects separate from each other. They synchronize two different things, so you shouldn't merge them into one Effect. Instead, you can simplify the <code>ShippingForm</code> component above by extracting the common logic between them into your own <code>useData</code> Hook:</p> <pre><code>function useData(url) {\nconst [data, setData] = useState(null);\nuseEffect(() =&gt; {\nif (url) {\nlet ignore = false;\nfetch(url)\n.then((response) =&gt; response.json())\n.then((json) =&gt; {\nif (!ignore) {\nsetData(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}\n}, [url]);\nreturn data;\n}\n</code></pre> <p>Now you can replace both Effects in the <code>ShippingForm</code> components with calls to <code>useData</code>:</p> <pre><code>function ShippingForm({ country }) {\nconst cities = useData(`/api/cities?country=${country}`);\nconst [city, setCity] = useState(null);\nconst areas = useData(city ? `/api/areas?city=${city}` : null);\n// ...\n</code></pre> <p>Extracting a custom Hook makes the data flow explicit. You feed the <code>url</code> in and you get the <code>data</code> out. By \"hiding\" your Effect inside <code>useData</code>, you also prevent someone working on the <code>ShippingForm</code> component from adding unnecessary dependencies to it. With time, most of your app's Effects will be in custom Hooks.</p> <p>"},{"location":"learn/reusing-logic-with-custom-hooks/#keep-your-custom-hooks-focused-on-concrete-high-level-use-cases","title":"Keep your custom Hooks focused on concrete high-level use cases","text":"<p>Start by choosing your custom Hook's name. If you struggle to pick a clear name, it might mean that your Effect is too coupled to the rest of your component's logic, and is not yet ready to be extracted.</p> <p>Ideally, your custom Hook's name should be clear enough that even a person who doesn't write code often could have a good guess about what your custom Hook does, what it takes, and what it returns:</p> <ul> <li>\u2705 <code>useData(url)</code></li> <li>\u2705 <code>useImpressionLog(eventName, extraData)</code></li> <li>\u2705 <code>useChatRoom(options)</code></li> </ul> <p>When you synchronize with an external system, your custom Hook name may be more technical and use jargon specific to that system. It's good as long as it would be clear to a person familiar with that system:</p> <ul> <li>\u2705 <code>useMediaQuery(query)</code></li> <li>\u2705 <code>useSocket(url)</code></li> <li>\u2705 <code>useIntersectionObserver(ref, options)</code></li> </ul> <p>Keep custom Hooks focused on concrete high-level use cases. Avoid creating and using custom \"lifecycle\" Hooks that act as alternatives and convenience wrappers for the <code>useEffect</code> API itself:</p> <ul> <li>\ud83d\udd34 <code>useMount(fn)</code></li> <li>\ud83d\udd34 <code>useEffectOnce(fn)</code></li> <li>\ud83d\udd34 <code>useUpdateEffect(fn)</code></li> </ul> <p>For example, this <code>useMount</code> Hook tries to ensure some code only runs \"on mount\":</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\n// \ud83d\udd34 Avoid: using custom \"lifecycle\" Hooks\nuseMount(() =&gt; {\nconst connection = createConnection({ roomId, serverUrl });\nconnection.connect();\n\npost(\"/analytics/event\", { eventName: \"visit_chat\" });\n});\n// ...\n}\n\n// \ud83d\udd34 Avoid: creating custom \"lifecycle\" Hooks\nfunction useMount(fn) {\nuseEffect(() =&gt; {\nfn();\n}, []); // \ud83d\udd34 React Hook useEffect has a missing dependency: 'fn'\n}\n</code></pre> <p>Custom \"lifecycle\" Hooks like <code>useMount</code> don't fit well into the React paradigm. For example, this code example has a mistake (it doesn't \"react\" to <code>roomId</code> or <code>serverUrl</code> changes), but the linter won't warn you about it because the linter only checks direct <code>useEffect</code> calls. It won't know about your Hook.</p> <p>If you're writing an Effect, start by using the React API directly:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\n// \u2705 Good: two raw Effects separated by purpose\n\nuseEffect(() =&gt; {\nconst connection = createConnection({ serverUrl, roomId });\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [serverUrl, roomId]);\n\nuseEffect(() =&gt; {\npost(\"/analytics/event\", { eventName: \"visit_chat\", roomId });\n}, [roomId]);\n\n// ...\n}\n</code></pre> <p>Then, you can (but don't have to) extract custom Hooks for different high-level use cases:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\n// \u2705 Great: custom Hooks named after their purpose\nuseChatRoom({ serverUrl, roomId });\nuseImpressionLog(\"visit_chat\", { roomId });\n// ...\n}\n</code></pre> <p>A good custom Hook makes the calling code more declarative by constraining what it does. For example, <code>useChatRoom(options)</code> can only connect to the chat room, while <code>useImpressionLog(eventName, extraData)</code> can only send an impression log to the analytics. If your custom Hook API doesn't constrain the use cases and is very abstract, in the long run it's likely to introduce more problems than it solves.</p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#custom-hooks-help-you-migrate-to-better-patterns","title":"Custom Hooks help you migrate to better patterns","text":"<p>Effects are an \"escape hatch\": you use them when you need to \"step outside React\" and when there is no better built-in solution for your use case. With time, the React team's goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available.</p> <p>Let's return to this example:</p> <pre><code>import { useOnlineStatus } from \"./useOnlineStatus.js\";\n\nfunction StatusBar() {\nconst isOnline = useOnlineStatus();\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n\nfunction handleSaveClick() {\nconsole.log(\"\u2705 Progress saved\");\n}\n\nreturn (\n&lt;button disabled={!isOnline} on_click={handleSaveClick}&gt;\n{isOnline ? \"Save progress\" : \"Reconnecting...\"}\n&lt;/button&gt;\n);\n}\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;SaveButton /&gt;\n&lt;StatusBar /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useOnlineStatus() {\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction handleOnline() {\nsetIsOnline(true);\n}\nfunction handleOffline() {\nsetIsOnline(false);\n}\nwindow.addEventListener(\"online\", handleOnline);\nwindow.addEventListener(\"offline\", handleOffline);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", handleOnline);\nwindow.removeEventListener(\"offline\", handleOffline);\n};\n}, []);\nreturn isOnline;\n}\n</code></pre> <p>In the above example, <code>useOnlineStatus</code> is implemented with a pair of <code>useState</code> and <code>useEffect</code>. However, this isn't the best possible solution. There is a number of edge cases it doesn't consider. For example, it assumes that when the component mounts, <code>isOnline</code> is already <code>true</code>, but this may be wrong if the network already went offline. You can use the browser <code>navigator.onLine</code> API to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved.</p> <p>Luckily, React 18 includes a dedicated API called <code>useSyncExternalStore</code> which takes care of all of these problems for you. Here is how your <code>useOnlineStatus</code> Hook, rewritten to take advantage of this new API:</p> <pre><code>import { useOnlineStatus } from \"./useOnlineStatus.js\";\n\nfunction StatusBar() {\nconst isOnline = useOnlineStatus();\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n\nfunction handleSaveClick() {\nconsole.log(\"\u2705 Progress saved\");\n}\n\nreturn (\n&lt;button disabled={!isOnline} on_click={handleSaveClick}&gt;\n{isOnline ? \"Save progress\" : \"Reconnecting...\"}\n&lt;/button&gt;\n);\n}\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;SaveButton /&gt;\n&lt;StatusBar /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useSyncExternalStore } from \"react\";\n\nfunction subscribe(callback) {\nwindow.addEventListener(\"online\", callback);\nwindow.addEventListener(\"offline\", callback);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", callback);\nwindow.removeEventListener(\"offline\", callback);\n};\n}\n\nexport function useOnlineStatus() {\nreturn useSyncExternalStore(\nsubscribe,\n() =&gt; navigator.onLine, // How to get the value on the client\n() =&gt; true // How to get the value on the server\n);\n}\n</code></pre> <p>Notice how you didn't need to change any of the components to make this migration:</p> <pre><code>function StatusBar() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n\nfunction SaveButton() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n</code></pre> <p>This is another reason for why wrapping Effects in custom Hooks is often beneficial:</p> <ol> <li>You make the data flow to and from your Effects very explicit.</li> <li>You let your components focus on the intent rather than on the exact implementation of your Effects.</li> <li>When React adds new features, you can remove those Effects without changing any of your components.</li> </ol> <p>Similar to a design system, you might find it helpful to start extracting common idioms from your app's components into custom Hooks. This will keep your components' code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community.</p> <p>"},{"location":"learn/reusing-logic-with-custom-hooks/#will-react-provide-any-built-in-solution-for-data-fetching","title":"Will React provide any built-in solution for data fetching?","text":"<p>We're still working out the details, but we expect that in the future, you'll write data fetching like this:</p> <pre><code>import { use } from 'react'; // Not available yet!\n\nfunction ShippingForm({ country }) {\nconst cities = use(fetch(`/api/cities?country=${country}`));\nconst [city, setCity] = useState(null);\nconst areas = city ? use(fetch(`/api/areas?city=${city}`)) : null;\n// ...\n</code></pre> <p>If you use custom Hooks like <code>useData</code> above in your app, it will require fewer changes to migrate to the eventually recommended approach than if you write raw Effects in every component manually. However, the old approach will still work fine, so if you feel happy writing raw Effects, you can continue to do that.</p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#there-is-more-than-one-way-to-do-it","title":"There is more than one way to do it","text":"<p>Let's say you want to implement a fade-in animation from scratch using the browser <code>requestAnimationFrame</code> API. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node you hold in a ref until it reaches <code>1</code>. Your code might start like this:</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst duration = 1000;\nconst node = ref.current;\n\nlet startTime = performance.now();\nlet frameId = null;\n\nfunction onFrame(now) {\nconst timePassed = now - startTime;\nconst progress = Math.min(timePassed / duration, 1);\nonProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nframeId = requestAnimationFrame(onFrame);\n}\n}\n\nfunction onProgress(progress) {\nnode.style.opacity = progress;\n}\n\nfunction start() {\nonProgress(0);\nstartTime = performance.now();\nframeId = requestAnimationFrame(onFrame);\n}\n\nfunction stop() {\ncancelAnimationFrame(frameId);\nstartTime = null;\nframeId = null;\n}\n\nstart();\nreturn () =&gt; stop();\n}, []);\n\nreturn (\n&lt;h1 className=\"welcome\" ref={ref}&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n.welcome {\nopacity: 0;\ncolor: white;\npadding: 50px;\ntext-align: center;\nfont-size: 50px;\nbackground-image: radial-gradient(\ncircle,\nrgba(63, 94, 251, 1) 0%,\nrgba(252, 70, 107, 1) 100%\n);\n}\n</code></pre> <p>To make the component more readable, you might extract the logic into a <code>useFadeIn</code> custom Hook:</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { useFadeIn } from \"./useFadeIn.js\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseFadeIn(ref, 1000);\n\nreturn (\n&lt;h1 className=\"welcome\" ref={ref}&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\n\nexport function useFadeIn(ref, duration) {\nuseEffect(() =&gt; {\nconst node = ref.current;\n\nlet startTime = performance.now();\nlet frameId = null;\n\nfunction onFrame(now) {\nconst timePassed = now - startTime;\nconst progress = Math.min(timePassed / duration, 1);\nonProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nframeId = requestAnimationFrame(onFrame);\n}\n}\n\nfunction onProgress(progress) {\nnode.style.opacity = progress;\n}\n\nfunction start() {\nonProgress(0);\nstartTime = performance.now();\nframeId = requestAnimationFrame(onFrame);\n}\n\nfunction stop() {\ncancelAnimationFrame(frameId);\nstartTime = null;\nframeId = null;\n}\n\nstart();\nreturn () =&gt; stop();\n}, [ref, duration]);\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n.welcome {\nopacity: 0;\ncolor: white;\npadding: 50px;\ntext-align: center;\nfont-size: 50px;\nbackground-image: radial-gradient(\ncircle,\nrgba(63, 94, 251, 1) 0%,\nrgba(252, 70, 107, 1) 100%\n);\n}\n</code></pre> <p>You could keep the <code>useFadeIn</code> code as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out of <code>useFadeIn</code> into a custom <code>useAnimationLoop</code> Hook:</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { useFadeIn } from \"./useFadeIn.js\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseFadeIn(ref, 1000);\n\nreturn (\n&lt;h1 className=\"welcome\" ref={ref}&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport function useFadeIn(ref, duration) {\nconst [isRunning, setIsRunning] = useState(true);\n\nuseAnimationLoop(isRunning, (timePassed) =&gt; {\nconst progress = Math.min(timePassed / duration, 1);\nref.current.style.opacity = progress;\nif (progress === 1) {\nsetIsRunning(false);\n}\n});\n}\n\nfunction useAnimationLoop(isRunning, drawFrame) {\nconst onFrame = useEffectEvent(drawFrame);\n\nuseEffect(() =&gt; {\nif (!isRunning) {\nreturn;\n}\n\nconst startTime = performance.now();\nlet frameId = null;\n\nfunction tick(now) {\nconst timePassed = now - startTime;\nonFrame(timePassed);\nframeId = requestAnimationFrame(tick);\n}\n\ntick();\nreturn () =&gt; cancelAnimationFrame(frameId);\n}, [isRunning]);\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n.welcome {\nopacity: 0;\ncolor: white;\npadding: 50px;\ntext-align: center;\nfont-size: 50px;\nbackground-image: radial-gradient(\ncircle,\nrgba(63, 94, 251, 1) 0%,\nrgba(252, 70, 107, 1) 100%\n);\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p>However, you didn't have to do that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScript class:</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { useFadeIn } from \"./useFadeIn.js\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseFadeIn(ref, 1000);\n\nreturn (\n&lt;h1 className=\"welcome\" ref={ref}&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { FadeInAnimation } from \"./animation.js\";\n\nexport function useFadeIn(ref, duration) {\nuseEffect(() =&gt; {\nconst animation = new FadeInAnimation(ref.current);\nanimation.start(duration);\nreturn () =&gt; {\nanimation.stop();\n};\n}, [ref, duration]);\n}\n</code></pre> <pre><code>export class FadeInAnimation {\nconstructor(node) {\nthis.node = node;\n}\nstart(duration) {\nthis.duration = duration;\nthis.onProgress(0);\nthis.startTime = performance.now();\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\nonFrame() {\nconst timePassed = performance.now() - this.startTime;\nconst progress = Math.min(timePassed / this.duration, 1);\nthis.onProgress(progress);\nif (progress === 1) {\nthis.stop();\n} else {\n// We still have more frames to paint\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonProgress(progress) {\nthis.node.style.opacity = progress;\n}\nstop() {\ncancelAnimationFrame(this.frameId);\nthis.startTime = null;\nthis.frameId = null;\nthis.duration = 0;\n}\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n.welcome {\nopacity: 0;\ncolor: white;\npadding: 50px;\ntext-align: center;\nfont-size: 50px;\nbackground-image: radial-gradient(\ncircle,\nrgba(63, 94, 251, 1) 0%,\nrgba(252, 70, 107, 1) 100%\n);\n}\n</code></pre> <p>Effects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hooks completely like in the sandbox above. Then, the code you extracted becomes the \"external system\". This lets your Effects stay simple because they only need to send messages to the system you've moved outside React.</p> <p>The examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plain CSS Animation:</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport \"./welcome.css\";\n\nfunction Welcome() {\nreturn &lt;h1 className=\"welcome\"&gt;Welcome&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n</code></pre> <pre><code>.welcome {\ncolor: white;\npadding: 50px;\ntext-align: center;\nfont-size: 50px;\nbackground-image: radial-gradient(\ncircle,\nrgba(63, 94, 251, 1) 0%,\nrgba(252, 70, 107, 1) 100%\n);\n\nanimation: fadeIn 1000ms;\n}\n\n@keyframes fadeIn {\n0% {\nopacity: 0;\n}\n100% {\nopacity: 1;\n}\n}\n</code></pre> <p>Sometimes, you don't even need a Hook!</p> <p> <ul> <li>Custom Hooks let you share logic between components.</li> <li>Custom Hooks must be named starting with <code>use</code> followed by a capital letter.</li> <li>Custom Hooks only share stateful logic, not state itself.</li> <li>You can pass reactive values from one Hook to another, and they stay up-to-date.</li> <li>All Hooks re-run every time your component re-renders.</li> <li>The code of your custom Hooks should be pure, like your component's code.</li> <li>Wrap event handlers received by custom Hooks into Effect Events.</li> <li>Don't create custom Hooks like <code>useMount</code>. Keep their purpose specific.</li> <li>It's up to you how and where to choose the boundaries of your code.</li> </ul> <p></p> <p>"},{"location":"learn/reusing-logic-with-custom-hooks/#extract-a-usecounter-hook","title":"Extract a <code>useCounter</code> Hook","text":"<p>This component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook called <code>useCounter</code>. Your goal is to make the <code>Counter</code> component implementation look exactly like this:</p> <pre><code>export default function Counter() {\nconst count = useCounter();\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <p>You'll need to write your custom Hook in <code>useCounter.js</code> and import it into the <code>Counter.js</code> file.</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>// Write your custom Hook in this file!\n</code></pre> <p> <p>Your code should look like this:</p> <pre><code>import { useCounter } from \"./useCounter.js\";\n\nexport default function Counter() {\nconst count = useCounter();\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useCounter() {\nconst [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn count;\n}\n</code></pre> <p>Notice that <code>App.js</code> doesn't need to import <code>useState</code> or <code>useEffect</code> anymore.</p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#make-the-counter-delay-configurable","title":"Make the counter delay configurable","text":"<p>In this example, there is a <code>delay</code> state variable controlled by a slider, but its value is not used. Pass the <code>delay</code> value to your custom <code>useCounter</code> Hook, and change the <code>useCounter</code> Hook to use the passed <code>delay</code> instead of hardcoding <code>1000</code> ms.</p> <pre><code>import { useState } from \"react\";\nimport { useCounter } from \"./useCounter.js\";\n\nexport default function Counter() {\nconst [delay, setDelay] = useState(1000);\nconst count = useCounter();\nreturn (\n&lt;&gt;\n&lt;label&gt;\nTick duration: {delay} ms\n&lt;br /&gt;\n&lt;input\ntype=\"range\"\nvalue={delay}\nmin=\"10\"\nmax=\"2000\"\nonChange={(e) =&gt; setDelay(Number(e.target.value))}\n/&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;h1&gt;Ticks: {count}&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useCounter() {\nconst [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, 1000);\nreturn () =&gt; clearInterval(id);\n}, []);\nreturn count;\n}\n</code></pre> <p> <p>Pass the <code>delay</code> to your Hook with <code>useCounter(delay)</code>. Then, inside the Hook, use <code>delay</code> instead of the hardcoded <code>1000</code> value. You'll need to add <code>delay</code> to your Effect's dependencies. This ensures that a change in <code>delay</code> will reset the interval.</p> <pre><code>import { useState } from \"react\";\nimport { useCounter } from \"./useCounter.js\";\n\nexport default function Counter() {\nconst [delay, setDelay] = useState(1000);\nconst count = useCounter(delay);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nTick duration: {delay} ms\n&lt;br /&gt;\n&lt;input\ntype=\"range\"\nvalue={delay}\nmin=\"10\"\nmax=\"2000\"\nonChange={(e) =&gt; setDelay(Number(e.target.value))}\n/&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;h1&gt;Ticks: {count}&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn () =&gt; clearInterval(id);\n}, [delay]);\nreturn count;\n}\n</code></pre> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#extract-useinterval-out-of-usecounter","title":"Extract <code>useInterval</code> out of <code>useCounter</code>","text":"<p>Currently, your <code>useCounter</code> Hook does two things. It sets up an interval, and it also increments a state variable on every interval tick. Split out the logic that sets up the interval into a separate Hook called <code>useInterval</code>. It should take two arguments: the <code>onTick</code> callback, and the <code>delay</code>. After this change, your <code>useCounter</code> implementation should look like this:</p> <pre><code>export function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn count;\n}\n</code></pre> <p>Write <code>useInterval</code> in the <code>useInterval.js</code> file and import it into the <code>useCounter.js</code> file.</p> <pre><code>import { useState } from \"react\";\nimport { useCounter } from \"./useCounter.js\";\n\nexport default function Counter() {\nconst count = useCounter(1000);\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn () =&gt; clearInterval(id);\n}, [delay]);\nreturn count;\n}\n</code></pre> <pre><code>// Write your Hook here!\n</code></pre> <p> <p>The logic inside <code>useInterval</code> should set up and clear the interval. It doesn't need to do anything else.</p> <pre><code>import { useCounter } from \"./useCounter.js\";\n\nexport default function Counter() {\nconst count = useCounter(1000);\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useInterval } from \"./useInterval.js\";\n\nexport function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn count;\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\n\nexport function useInterval(onTick, delay) {\nuseEffect(() =&gt; {\nconst id = setInterval(onTick, delay);\nreturn () =&gt; clearInterval(id);\n}, [onTick, delay]);\n}\n</code></pre> <p>Note that there is a bit of a problem with this solution, which you'll solve in the next challenge.</p> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#fix-a-resetting-interval","title":"Fix a resetting interval","text":"<p>In this example, there are two separate intervals.</p> <p>The <code>App</code> component calls <code>useCounter</code>, which calls <code>useInterval</code> to update the counter every second. But the <code>App</code> component also calls <code>useInterval</code> to randomly update the page background color every two seconds.</p> <p>For some reason, the callback that updates the page background never runs. Add some logs inside <code>useInterval</code>:</p> <pre><code>useEffect(() =&gt; {\nconsole.log(\"\u2705 Setting up an interval with delay \", delay);\nconst id = setInterval(onTick, delay);\nreturn () =&gt; {\nconsole.log(\"\u274c Clearing an interval with delay \", delay);\nclearInterval(id);\n};\n}, [onTick, delay]);\n</code></pre> <p>Do the logs match what you expect to happen? If some of your Effects seem to re-synchronize unnecessarily, can you guess which dependency is causing that to happen? Is there some way to remove that dependency from your Effect?</p> <p>After you fix the issue, you should expect the page background to update every two seconds.</p> <p> <p>It looks like your <code>useInterval</code> Hook accepts an event listener as an argument. Can you think of some way to wrap that event listener so that it doesn't need to be a dependency of your Effect?</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useCounter } from \"./useCounter.js\";\nimport { useInterval } from \"./useInterval.js\";\n\nexport default function Counter() {\nconst count = useCounter(1000);\n\nuseInterval(() =&gt; {\nconst randomColor = `hsla(${Math.random() * 360}, 100%, 50%, 0.2)`;\ndocument.body.style.backgroundColor = randomColor;\n}, 2000);\n\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useInterval } from \"./useInterval.js\";\n\nexport function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn count;\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport function useInterval(onTick, delay) {\nuseEffect(() =&gt; {\nconst id = setInterval(onTick, delay);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [onTick, delay]);\n}\n</code></pre> <p> <p>Inside <code>useInterval</code>, wrap the tick callback into an Effect Event, as you did earlier on this page.</p> <p>This will allow you to omit <code>onTick</code> from dependencies of your Effect. The Effect won't re-synchronize on every re-render of the component, so the page background color change interval won't get reset every second before it has a chance to fire.</p> <p>With this change, both intervals work as expected and don't interfere with each other:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useCounter } from \"./useCounter.js\";\nimport { useInterval } from \"./useInterval.js\";\n\nexport default function Counter() {\nconst count = useCounter(1000);\n\nuseInterval(() =&gt; {\nconst randomColor = `hsla(${Math.random() * 360}, 100%, 50%, 0.2)`;\ndocument.body.style.backgroundColor = randomColor;\n}, 2000);\n\nreturn &lt;h1&gt;Seconds passed: {count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useInterval } from \"./useInterval.js\";\n\nexport function useCounter(delay) {\nconst [count, setCount] = useState(0);\nuseInterval(() =&gt; {\nsetCount((c) =&gt; c + 1);\n}, delay);\nreturn count;\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport function useInterval(callback, delay) {\nconst onTick = useEffectEvent(callback);\nuseEffect(() =&gt; {\nconst id = setInterval(onTick, delay);\nreturn () =&gt; clearInterval(id);\n}, [delay]);\n}\n</code></pre> <p></p>"},{"location":"learn/reusing-logic-with-custom-hooks/#implement-a-staggering-movement","title":"Implement a staggering movement","text":"<p>In this example, the <code>usePointerPosition()</code> Hook tracks the current pointer position. Try moving your cursor or your finger over the preview area and see the red dot follow your movement. Its position is saved in the <code>pos1</code> variable.</p> <p>In fact, there are five (!) different red dots being rendered. You don't see them because currently they all appear at the same position. This is what you need to fix. What you want to implement instead is a \"staggered\" movement: each dot should \"follow\" the previous dot's path. For example, if you quickly move your cursor, the first dot should follow it immediately, the second dot should follow the first dot with a small delay, the third dot should follow the second dot, and so on.</p> <p>You need to implement the <code>useDelayedValue</code> custom Hook. Its current implementation returns the <code>value</code> provided to it. Instead, you want to return the value back from <code>delay</code> milliseconds ago. You might need some state and an Effect to do this.</p> <p>After you implement <code>useDelayedValue</code>, you should see the dots move following one another.</p> <p> <p>You'll need to store the <code>delayedValue</code> as a state variable inside your custom Hook. When the <code>value</code> changes, you'll want to run an Effect. This Effect should update <code>delayedValue</code> after the <code>delay</code>. You might find it helpful to call <code>setTimeout</code>.</p> <p>Does this Effect need cleanup? Why or why not?</p> <p></p> <pre><code>import { usePointerPosition } from \"./usePointerPosition.js\";\n\nfunction useDelayedValue(value, delay) {\n// TODO: Implement this Hook\nreturn value;\n}\n\nexport default function Canvas() {\nconst pos1 = usePointerPosition();\nconst pos2 = useDelayedValue(pos1, 100);\nconst pos3 = useDelayedValue(pos2, 200);\nconst pos4 = useDelayedValue(pos3, 100);\nconst pos5 = useDelayedValue(pos3, 50);\nreturn (\n&lt;&gt;\n&lt;Dot position={pos1} opacity={1} /&gt;\n&lt;Dot position={pos2} opacity={0.8} /&gt;\n&lt;Dot position={pos3} opacity={0.6} /&gt;\n&lt;Dot position={pos4} opacity={0.4} /&gt;\n&lt;Dot position={pos5} opacity={0.2} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction Dot({ position, opacity }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function usePointerPosition() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}, []);\nreturn position;\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre> <p> <p>Here is a working version. You keep the <code>delayedValue</code> as a state variable. When <code>value</code> updates, your Effect schedules a timeout to update the <code>delayedValue</code>. This is why the <code>delayedValue</code> always \"lags behind\" the actual <code>value</code>.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { usePointerPosition } from \"./usePointerPosition.js\";\n\nfunction useDelayedValue(value, delay) {\nconst [delayedValue, setDelayedValue] = useState(value);\n\nuseEffect(() =&gt; {\nsetTimeout(() =&gt; {\nsetDelayedValue(value);\n}, delay);\n}, [value, delay]);\n\nreturn delayedValue;\n}\n\nexport default function Canvas() {\nconst pos1 = usePointerPosition();\nconst pos2 = useDelayedValue(pos1, 100);\nconst pos3 = useDelayedValue(pos2, 200);\nconst pos4 = useDelayedValue(pos3, 100);\nconst pos5 = useDelayedValue(pos3, 50);\nreturn (\n&lt;&gt;\n&lt;Dot position={pos1} opacity={1} /&gt;\n&lt;Dot position={pos2} opacity={0.8} /&gt;\n&lt;Dot position={pos3} opacity={0.6} /&gt;\n&lt;Dot position={pos4} opacity={0.4} /&gt;\n&lt;Dot position={pos5} opacity={0.2} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction Dot({ position, opacity }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function usePointerPosition() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n}, []);\nreturn position;\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre> <p>Note that this Effect does not need cleanup. If you called <code>clearTimeout</code> in the cleanup function, then each time the <code>value</code> changes, it would reset the already scheduled timeout. To keep the movement continuous, you want all the timeouts to fire.</p> <p></p> <p></p>"},{"location":"learn/scaling-up-with-reducer-and-context/","title":"Scaling Up with Reducer and Context \ud83d\udea7","text":""},{"location":"learn/scaling-up-with-reducer-and-context/#overview","title":"Overview","text":"<p>  Reducers let you consolidate a component's state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.  </p> <p>You will learn</p> <ul> <li>How to combine a reducer with context</li> <li>How to avoid passing state and dispatch through props</li> <li>How to keep context and state logic in a separate file</li> </ul>"},{"location":"learn/scaling-up-with-reducer-and-context/#combining-a-reducer-with-context","title":"Combining a reducer with context","text":"<p>In this example from the introduction to reducers, the state is managed by a reducer. The reducer function contains all of the state update logic and is declared at the bottom of this file:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>A reducer helps keep the event handlers short and concise. However, as your app grows, you might run into another difficulty. Currently, the <code>tasks</code> state and the <code>dispatch</code> function are only available in the top-level <code>TaskApp</code> component. To let other components read the list of tasks or change it, you have to explicitly pass down the current state and the event handlers that change it as props.</p> <p>For example, <code>TaskApp</code> passes a list of tasks and the event handlers to <code>TaskList</code>:</p> <pre><code>&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n</code></pre> <p>And <code>TaskList</code> passes the event handlers to <code>Task</code>:</p> <pre><code>&lt;Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} /&gt;\n</code></pre> <p>In a small example like this, this works well, but if you have tens or hundreds of components in the middle, passing down all state and functions can be quite frustrating!</p> <p>This is why, as an alternative to passing them through props, you might want to put both the <code>tasks</code> state and the <code>dispatch</code> function into context. This way, any component below <code>TaskApp</code> in the tree can read the tasks and dispatch actions without the repetitive \"prop drilling\".</p> <p>Here is how you can combine a reducer with context:</p> <ol> <li>Create the context.</li> <li>Put state and dispatch into context.</li> <li>Use context anywhere in the tree.</li> </ol>"},{"location":"learn/scaling-up-with-reducer-and-context/#step-1-create-the-context","title":"Step 1: Create the context","text":"<p>The <code>useReducer</code> Hook returns the current <code>tasks</code> and the <code>dispatch</code> function that lets you update them:</p> <pre><code>const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n</code></pre> <p>To pass them down the tree, you will create two separate contexts:</p> <ul> <li><code>TasksContext</code> provides the current list of tasks.</li> <li><code>TasksDispatchContext</code> provides the function that lets components dispatch actions.</li> </ul> <p>Export them from a separate file so that you can later import them from other files:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const TasksContext = createContext(null);\nexport const TasksDispatchContext = createContext(null);\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>Here, you're passing <code>null</code> as the default value to both contexts. The actual values will be provided by the <code>TaskApp</code> component.</p>"},{"location":"learn/scaling-up-with-reducer-and-context/#step-2-put-state-and-dispatch-into-context","title":"Step 2: Put state and dispatch into context","text":"<p>Now you can import both contexts in your <code>TaskApp</code> component. Take the <code>tasks</code> and <code>dispatch</code> returned by <code>useReducer()</code> and provide them to the entire tree below:</p> <pre><code>import { TasksContext, TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n// ...\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n...\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n</code></pre> <p>For now, you pass the information both via props and in context:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport { TasksContext, TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const TasksContext = createContext(null);\nexport const TasksDispatchContext = createContext(null);\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button on_click={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>In the next step, you will remove prop passing.</p>"},{"location":"learn/scaling-up-with-reducer-and-context/#step-3-use-context-anywhere-in-the-tree","title":"Step 3: Use context anywhere in the tree","text":"<p>Now you don't need to pass the list of tasks or the event handlers down the tree:</p> <pre><code>&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask /&gt;\n&lt;TaskList /&gt;\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n</code></pre> <p>Instead, any component that needs the task list can read it from the <code>TaskContext</code>:</p> <pre><code>export default function TaskList() {\nconst tasks = useContext(TasksContext);\n// ...\n</code></pre> <p>To update the task list, any component can read the <code>dispatch</code> function from context and call it:</p> <pre><code>export default function AddTask() {\nconst [text, setText] = useState('');\nconst dispatch = useContext(TasksDispatchContext);\n// ...\nreturn (\n// ...\n&lt;button on_click={() =&gt; {\nsetText('');\ndispatch({\ntype: 'added',\nid: nextId++,\ntext: text,\n});\n}}&gt;Add&lt;/button&gt;\n// ...\n</code></pre> <p>The <code>TaskApp</code> component does not pass any event handlers down, and the <code>TaskList</code> does not pass any event handlers to the <code>Task</code> component either. Each component reads the context that it needs:</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport { TasksContext, TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask /&gt;\n&lt;TaskList /&gt;\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const TasksContext = createContext(null);\nexport const TasksDispatchContext = createContext(null);\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function AddTask() {\nconst [text, setText] = useState(\"\");\nconst dispatch = useContext(TasksDispatchContext);\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { TasksContext, TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function TaskList() {\nconst tasks = useContext(TasksContext);\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task task={task} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task }) {\nconst [isEditing, setIsEditing] = useState(false);\nconst dispatch = useContext(TasksDispatchContext);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ntext: e.target.value,\n},\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ndone: e.target.checked,\n},\n});\n}}\n/&gt;\n{taskContent}\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"deleted\",\nid: task.id,\n});\n}}\n&gt;\nDelete\n&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>The state still \"lives\" in the top-level <code>TaskApp</code> component, managed with <code>useReducer</code>. But its <code>tasks</code> and <code>dispatch</code> are now available to every component below in the tree by importing and using these contexts.</p>"},{"location":"learn/scaling-up-with-reducer-and-context/#moving-all-wiring-into-a-single-file","title":"Moving all wiring into a single file","text":"<p>You don't have to do this, but you could further declutter the components by moving both reducer and context into a single file. Currently, <code>TasksContext.js</code> contains only two context declarations:</p> <pre><code>import { createContext } from \"react\";\n\nexport const TasksContext = createContext(null);\nexport const TasksDispatchContext = createContext(null);\n</code></pre> <p>This file is about to get crowded! You'll move the reducer into that same file. Then you'll declare a new <code>TasksProvider</code> component in the same file. This component will tie all the pieces together:</p> <ol> <li>It will manage the state with a reducer.</li> <li>It will provide both contexts to components below.</li> <li>It will take <code>children</code> as a prop so you can pass JSX to it.</li> </ol> <pre><code>export function TasksProvider({ children }) {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n{children}\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n</code></pre> <p>This removes all the complexity and wiring from your <code>TaskApp</code> component:</p> <pre><code>import AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport { TasksProvider } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nreturn (\n&lt;TasksProvider&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask /&gt;\n&lt;TaskList /&gt;\n&lt;/TasksProvider&gt;\n);\n}\n</code></pre> <pre><code>import { createContext, useReducer } from \"react\";\n\nexport const TasksContext = createContext(null);\nexport const TasksDispatchContext = createContext(null);\n\nexport function TasksProvider({ children }) {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n{children}\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function AddTask() {\nconst [text, setText] = useState(\"\");\nconst dispatch = useContext(TasksDispatchContext);\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { TasksContext, TasksDispatchContext } from \"./TasksContext.js\";\n\nexport default function TaskList() {\nconst tasks = useContext(TasksContext);\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task task={task} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task }) {\nconst [isEditing, setIsEditing] = useState(false);\nconst dispatch = useContext(TasksDispatchContext);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ntext: e.target.value,\n},\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ndone: e.target.checked,\n},\n});\n}}\n/&gt;\n{taskContent}\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"deleted\",\nid: task.id,\n});\n}}\n&gt;\nDelete\n&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>You can also export functions that use the context from <code>TasksContext.js</code>:</p> <pre><code>export function useTasks() {\nreturn useContext(TasksContext);\n}\n\nexport function useTasksDispatch() {\nreturn useContext(TasksDispatchContext);\n}\n</code></pre> <p>When a component needs to read context, it can do it through these functions:</p> <pre><code>const tasks = useTasks();\nconst dispatch = useTasksDispatch();\n</code></pre> <p>This doesn't change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions. Now all of the context and reducer wiring is in <code>TasksContext.js</code>. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data:</p> <pre><code>import AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport { TasksProvider } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nreturn (\n&lt;TasksProvider&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask /&gt;\n&lt;TaskList /&gt;\n&lt;/TasksProvider&gt;\n);\n}\n</code></pre> <pre><code>import { createContext, useContext, useReducer } from \"react\";\n\nconst TasksContext = createContext(null);\n\nconst TasksDispatchContext = createContext(null);\n\nexport function TasksProvider({ children }) {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n{children}\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n\nexport function useTasks() {\nreturn useContext(TasksContext);\n}\n\nexport function useTasksDispatch() {\nreturn useContext(TasksDispatchContext);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useTasksDispatch } from \"./TasksContext.js\";\n\nexport default function AddTask() {\nconst [text, setText] = useState(\"\");\nconst dispatch = useTasksDispatch();\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetText(\"\");\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { useTasks, useTasksDispatch } from \"./TasksContext.js\";\n\nexport default function TaskList() {\nconst tasks = useTasks();\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task task={task} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task }) {\nconst [isEditing, setIsEditing] = useState(false);\nconst dispatch = useTasksDispatch();\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ntext: e.target.value,\n},\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ndone: e.target.checked,\n},\n});\n}}\n/&gt;\n{taskContent}\n&lt;button\non_click={() =&gt; {\ndispatch({\ntype: \"deleted\",\nid: task.id,\n});\n}}\n&gt;\nDelete\n&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>You can think of <code>TasksProvider</code> as a part of the screen that knows how to deal with tasks, <code>useTasks</code> as a way to read them, and <code>useTasksDispatch</code> as a way to update them from any component below in the tree.</p> <p> <p>Functions like <code>useTasks</code> and <code>useTasksDispatch</code> are called Custom Hooks. Your function is considered a custom Hook if its name starts with <code>use</code>. This lets you use other Hooks, like <code>useContext</code>, inside it.</p> <p></p> <p>As your app grows, you may have many context-reducer pairs like this. This is a powerful way to scale your app and lift state up without too much work whenever you want to access the data deep in the tree.</p> <p> <ul> <li>You can combine reducer with context to let any component read and update state above it.</li> <li>To provide state and the dispatch function to components below:<ol> <li>Create two contexts (for state and for dispatch functions).</li> <li>Provide both contexts from the component that uses the reducer.</li> <li>Use either context from components that need to read them.</li> </ol> </li> <li>You can further declutter the components by moving all wiring into one file.<ul> <li>You can export a component like <code>TasksProvider</code> that provides context.</li> <li>You can also export custom Hooks like <code>useTasks</code> and <code>useTasksDispatch</code> to read it.</li> </ul> </li> <li>You can have many context-reducer pairs like this in your app.</li> </ul> <p></p>"},{"location":"learn/separating-events-from-effects/","title":"Separating Events from Effects \ud83d\udea7","text":""},{"location":"learn/separating-events-from-effects/#overview","title":"Overview","text":"<p>  Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.  </p> <p>You will learn</p> <ul> <li>How to choose between an event handler and an Effect</li> <li>Why Effects are reactive, and event handlers are not</li> <li>What to do when you want a part of your Effect's code to not be reactive</li> <li>What Effect Events are, and how to extract them from your Effects</li> <li>How to read the latest props and state from Effects using Effect Events</li> </ul>"},{"location":"learn/separating-events-from-effects/#choosing-between-event-handlers-and-effects","title":"Choosing between event handlers and Effects","text":"<p>First, let's recap the difference between event handlers and Effects.</p> <p>Imagine you're implementing a chat room component. Your requirements look like this:</p> <ol> <li>Your component should automatically connect to the selected chat room.</li> <li>When you click the \"Send\" button, it should send a message to the chat.</li> </ol> <p>Let's say you've already implemented the code for them, but you're not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, consider why the code needs to run.</p>"},{"location":"learn/separating-events-from-effects/#event-handlers-run-in-response-to-specific-interactions","title":"Event handlers run in response to specific interactions","text":"<p>From the user's perspective, sending a message should happen because the particular \"Send\" button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n// ...\nfunction handleSendClick() {\nsendMessage(message);\n}\n// ...\nreturn (\n&lt;&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button on_click={handleSendClick}&gt;Send&lt;/button&gt;;\n&lt;/&gt;\n);\n}\n</code></pre> <p>With an event handler, you can be sure that <code>sendMessage(message)</code> will only run if the user presses the button.</p>"},{"location":"learn/separating-events-from-effects/#effects-run-whenever-synchronization-is-needed","title":"Effects run whenever synchronization is needed","text":"<p>Recall that you also need to keep the component connected to the chat room. Where does that code go?</p> <p>The reason to run this code is not some particular interaction. It doesn't matter why or how the user navigated to the chat room screen. Now that they're looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you would still need to connect. This is why it's an Effect:</p> <pre><code>function ChatRoom({ roomId }) {\n// ...\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]);\n// ...\n}\n</code></pre> <p>With this code, you can be sure that there is always an active connection to the currently selected chat server, regardless of the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component will remain synchronized with the currently selected room, and will re-connect whenever it's necessary.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nfunction handleSendClick() {\nsendMessage(message);\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button on_click={handleSendClick}&gt;Send&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function sendMessage(message) {\nconsole.log(\"\ud83d\udd35 You sent: \" + message);\n}\n\nexport function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input,\nselect {\nmargin-right: 20px;\n}\n</code></pre>"},{"location":"learn/separating-events-from-effects/#reactive-values-and-reactive-logic","title":"Reactive values and reactive logic","text":"<p>Intuitively, you could say that event handlers are always triggered \"manually\", for example by clicking a button. Effects, on the other hand, are \"automatic\": they run and re-run as often as it's needed to stay synchronized.</p> <p>There is a more precise way to think about this.</p> <p>Props, state, and variables declared inside your component's body are called reactive values. In this example, <code>serverUrl</code> is not a reactive value, but <code>roomId</code> and <code>message</code> are. They participate in the rendering data flow:</p> <pre><code>const serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\n// ...\n}\n</code></pre> <p>Reactive values like these can change due to a re-render. For example, the user may edit the <code>message</code> or choose a different <code>roomId</code> in a dropdown. Event handlers and Effects respond to changes differently:</p> <ul> <li>Logic inside event handlers is not reactive. It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without \"reacting\" to their changes.</li> <li>Logic inside Effects is reactive. If your Effect reads a reactive value, you have to specify it as a dependency. Then, if a re-render causes that value to change, React will re-run your Effect's logic with the new value.</li> </ul> <p>Let's revisit the previous example to illustrate this difference.</p>"},{"location":"learn/separating-events-from-effects/#logic-inside-event-handlers-is-not-reactive","title":"Logic inside event handlers is not reactive","text":"<p>Take a look at this line of code. Should this logic be reactive or not?</p> <pre><code>// ...\nsendMessage(message);\n// ...\n</code></pre> <p>From the user's perspective, a change to the <code>message</code> does not mean that they want to send a message. It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because the reactive value has changed. That's why it belongs in the event handler:</p> <pre><code>function handleSendClick() {\nsendMessage(message);\n}\n</code></pre> <p>Event handlers aren't reactive, so <code>sendMessage(message)</code> will only run when the user clicks the Send button.</p>"},{"location":"learn/separating-events-from-effects/#logic-inside-effects-is-reactive","title":"Logic inside Effects is reactive","text":"<p>Now let's return to these lines:</p> <pre><code>// ...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\n// ...\n</code></pre> <p>From the user's perspective, a change to the <code>roomId</code> does mean that they want to connect to a different room. In other words, the logic for connecting to the room should be reactive. You want these lines of code to \"keep up\" with the reactive value, and to run again if that value is different. That's why it belongs in an Effect:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId]);\n</code></pre> <p>Effects are reactive, so <code>createConnection(serverUrl, roomId)</code> and <code>connection.connect()</code> will run for every distinct value of <code>roomId</code>. Your Effect keeps the chat connection synchronized to the currently selected room.</p>"},{"location":"learn/separating-events-from-effects/#extracting-non-reactive-logic-out-of-effects","title":"Extracting non-reactive logic out of Effects","text":"<p>Things get more tricky when you want to mix reactive logic with non-reactive logic.</p> <p>For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:</p> <pre><code>function ChatRoom({ roomId, theme }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on('connected', () =&gt; {\nshowNotification('Connected!', theme);\n});\nconnection.connect();\n// ...\n</code></pre> <p>However, <code>theme</code> is a reactive value (it can change as a result of re-rendering), and every reactive value read by an Effect must be declared as its dependency. Now you have to specify <code>theme</code> as a dependency of your Effect:</p> <pre><code>function ChatRoom({ roomId, theme }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on('connected', () =&gt; {\nshowNotification('Connected!', theme);\n});\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect()\n};\n}, [roomId, theme]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>Play with this example and see if you can spot the problem with this user experience:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId, theme }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on(\"connected\", () =&gt; {\nshowNotification(\"Connected!\", theme);\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, theme]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} theme={isDark ? \"dark\" : \"light\"} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nlet connectedCallback;\nlet timeout;\nreturn {\nconnect() {\ntimeout = setTimeout(() =&gt; {\nif (connectedCallback) {\nconnectedCallback();\n}\n}, 100);\n},\non(event, callback) {\nif (connectedCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"connected\") {\nthrow Error('Only \"connected\" event is supported.');\n}\nconnectedCallback = callback;\n},\ndisconnect() {\nclearTimeout(timeout);\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p>When the <code>roomId</code> changes, the chat re-connects as you would expect. But since <code>theme</code> is also a dependency, the chat also re-connects every time you switch between the dark and the light theme. That's not great!</p> <p>In other words, you don't want this line to be reactive, even though it is inside an Effect (which is reactive):</p> <pre><code>// ...\nshowNotification(\"Connected!\", theme);\n// ...\n</code></pre> <p>You need a way to separate this non-reactive logic from the reactive Effect around it.</p>"},{"location":"learn/separating-events-from-effects/#declaring-an-effect-event","title":"Declaring an Effect Event","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>Use a special Hook called <code>useEffectEvent</code> to extract this non-reactive logic out of your Effect:</p> <pre><code>import { useEffect, useEffectEvent } from 'react';\n\nfunction ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent(() =&gt; {\nshowNotification('Connected!', theme);\n});\n// ...\n</code></pre> <p>Here, <code>onConnected</code> is called an Effect Event. It's a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always \"sees\" the latest values of your props and state.</p> <p>Now you can call the <code>onConnected</code> Effect Event from inside your Effect:</p> <pre><code>function ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent(() =&gt; {\nshowNotification('Connected!', theme);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on('connected', () =&gt; {\nonConnected();\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n</code></pre> <p>This solves the problem. Note that you had to remove <code>onConnected</code> from the list of your Effect's dependencies. Effect Events are not reactive and must be omitted from dependencies.</p> <p>Verify that the new behavior works as you would expect:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent(() =&gt; {\nshowNotification(\"Connected!\", theme);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on(\"connected\", () =&gt; {\nonConnected();\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} theme={isDark ? \"dark\" : \"light\"} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nlet connectedCallback;\nlet timeout;\nreturn {\nconnect() {\ntimeout = setTimeout(() =&gt; {\nif (connectedCallback) {\nconnectedCallback();\n}\n}, 100);\n},\non(event, callback) {\nif (connectedCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"connected\") {\nthrow Error('Only \"connected\" event is supported.');\n}\nconnectedCallback = callback;\n},\ndisconnect() {\nclearTimeout(timeout);\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p>You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you \"break the chain\" between the reactivity of Effects and code that should not be reactive.</p>"},{"location":"learn/separating-events-from-effects/#reading-latest-props-and-state-with-effect-events","title":"Reading latest props and state with Effect Events","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.</p> <p>For example, say you have an Effect to log the page visits:</p> <pre><code>function Page() {\nuseEffect(() =&gt; {\nlogVisit();\n}, []);\n// ...\n}\n</code></pre> <p>Later, you add multiple routes to your site. Now your <code>Page</code> component receives a <code>url</code> prop with the current path. You want to pass the <code>url</code> as a part of your <code>logVisit</code> call, but the dependency linter complains:</p> <pre><code>function Page({ url }) {\nuseEffect(() =&gt; {\nlogVisit(url);\n}, []); // \ud83d\udd34 React Hook useEffect has a missing dependency: 'url'\n// ...\n}\n</code></pre> <p>Think about what you want the code to do. You want to log a separate visit for different URLs since each URL represents a different page. In other words, this <code>logVisit</code> call should be reactive with respect to the <code>url</code>. This is why, in this case, it makes sense to follow the dependency linter, and add <code>url</code> as a dependency:</p> <pre><code>function Page({ url }) {\nuseEffect(() =&gt; {\nlogVisit(url);\n}, [url]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Now let's say you want to include the number of items in the shopping cart together with every page visit:</p> <pre><code>function Page({ url }) {\nconst { items } = useContext(ShoppingCartContext);\nconst numberOfItems = items.length;\n\nuseEffect(() =&gt; {\nlogVisit(url, numberOfItems);\n}, [url]); // \ud83d\udd34 React Hook useEffect has a missing dependency: 'numberOfItems'\n// ...\n}\n</code></pre> <p>You used <code>numberOfItems</code> inside the Effect, so the linter asks you to add it as a dependency. However, you don't want the <code>logVisit</code> call to be reactive with respect to <code>numberOfItems</code>. If the user puts something into the shopping cart, and the <code>numberOfItems</code> changes, this does not mean that the user visited the page again. In other words, visiting the page is, in some sense, an \"event\". It happens at a precise moment in time.</p> <p>Split the code in two parts:</p> <pre><code>function Page({ url }) {\nconst { items } = useContext(ShoppingCartContext);\nconst numberOfItems = items.length;\n\nconst onVisit = useEffectEvent((visitedUrl) =&gt; {\nlogVisit(visitedUrl, numberOfItems);\n});\n\nuseEffect(() =&gt; {\nonVisit(url);\n}, [url]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Here, <code>onVisit</code> is an Effect Event. The code inside it isn't reactive. This is why you can use <code>numberOfItems</code> (or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.</p> <p>On the other hand, the Effect itself remains reactive. Code inside the Effect uses the <code>url</code> prop, so the Effect will re-run after every re-render with a different <code>url</code>. This, in turn, will call the <code>onVisit</code> Effect Event.</p> <p>As a result, you will call <code>logVisit</code> for every change to the <code>url</code>, and always read the latest <code>numberOfItems</code>. However, if <code>numberOfItems</code> changes on its own, this will not cause any of the code to re-run.</p> <p> <p>You might be wondering if you could call <code>onVisit()</code> with no arguments, and read the <code>url</code> inside it:</p> <pre><code>const onVisit = useEffectEvent(() =&gt; {\nlogVisit(url, numberOfItems);\n});\n\nuseEffect(() =&gt; {\nonVisit();\n}, [url]);\n</code></pre> <p>This would work, but it's better to pass this <code>url</code> to the Effect Event explicitly. By passing <code>url</code> as an argument to your Effect Event, you are saying that visiting a page with a different <code>url</code> constitutes a separate \"event\" from the user's perspective. The <code>visitedUrl</code> is a part of the \"event\" that happened:</p> <pre><code>const onVisit = useEffectEvent((visitedUrl) =&gt; {\nlogVisit(visitedUrl, numberOfItems);\n});\n\nuseEffect(() =&gt; {\nonVisit(url);\n}, [url]);\n</code></pre> <p>Since your Effect Event explicitly \"asks\" for the <code>visitedUrl</code>, now you can't accidentally remove <code>url</code> from the Effect's dependencies. If you remove the <code>url</code> dependency (causing distinct page visits to be counted as one), the linter will warn you about it. You want <code>onVisit</code> to be reactive with regards to the <code>url</code>, so instead of reading the <code>url</code> inside (where it wouldn't be reactive), you pass it from your Effect.</p> <p>This becomes especially important if there is some asynchronous logic inside the Effect:</p> <pre><code>const onVisit = useEffectEvent((visitedUrl) =&gt; {\nlogVisit(visitedUrl, numberOfItems);\n});\n\nuseEffect(() =&gt; {\nsetTimeout(() =&gt; {\nonVisit(url);\n}, 5000); // Delay logging visits\n}, [url]);\n</code></pre> <p>Here, <code>url</code> inside <code>onVisit</code> corresponds to the latest <code>url</code> (which could have already changed), but <code>visitedUrl</code> corresponds to the <code>url</code> that originally caused this Effect (and this <code>onVisit</code> call) to run.</p> <p></p> <p>"},{"location":"learn/separating-events-from-effects/#is-it-okay-to-suppress-the-dependency-linter-instead","title":"Is it okay to suppress the dependency linter instead?","text":"<p>In the existing codebases, you may sometimes see the lint rule suppressed like this:</p> <pre><code>function Page({ url }) {\nconst { items } = useContext(ShoppingCartContext);\nconst numberOfItems = items.length;\n\nuseEffect(() =&gt; {\nlogVisit(url, numberOfItems);\n// \ud83d\udd34 Avoid suppressing the linter like this:\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, [url]);\n// ...\n}\n</code></pre> <p>After <code>useEffectEvent</code> becomes a stable part of React, we recommend never suppressing the linter.</p> <p>The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to \"react\" to a new reactive dependency you've introduced to your code. In the earlier example, you added <code>url</code> to the dependencies because React reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs.</p> <p>Here is an example of a confusing bug caused by suppressing the linter. In this example, the <code>handleMove</code> function is supposed to read the current <code>canMove</code> state variable value in order to decide whether the dot should follow the cursor. However, <code>canMove</code> is always <code>true</code> inside <code>handleMove</code>.</p> <p>Can you see why?</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nfunction handleMove(e) {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n}\n\nuseEffect(() =&gt; {\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", handleMove);\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>The problem with this code is in suppressing the dependency linter. If you remove the suppression, you'll see that this Effect should depend on the <code>handleMove</code> function. This makes sense: <code>handleMove</code> is declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!</p> <p>The author of the original code has \"lied\" to React by saying that the Effect does not depend (<code>[]</code>) on any reactive values. This is why React did not re-synchronize the Effect after <code>canMove</code> has changed (and <code>handleMove</code> with it). Because React did not re-synchronize the Effect, the <code>handleMove</code> attached as a listener is the <code>handleMove</code> function created during the initial render. During the initial render, <code>canMove</code> was <code>true</code>, which is why <code>handleMove</code> from the initial render will forever see that value.</p> <p>If you never suppress the linter, you will never see problems with stale values.</p> <p>With <code>useEffectEvent</code>, there is no need to \"lie\" to the linter, and the code works as you would expect:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nconst [canMove, setCanMove] = useState(true);\n\nconst onMove = useEffectEvent((e) =&gt; {\nif (canMove) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\n});\n\nuseEffect(() =&gt; {\nwindow.addEventListener(\"pointermove\", onMove);\nreturn () =&gt; window.removeEventListener(\"pointermove\", onMove);\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={canMove}\nonChange={(e) =&gt; setCanMove(e.target.checked)}\n/&gt;\nThe dot is allowed to move\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 200px;\n}\n</code></pre> <p>This doesn't mean that <code>useEffectEvent</code> is always the correct solution. You should only apply it to the lines of code that you don't want to be reactive. In the above sandbox, you didn't want the Effect's code to be reactive with regards to <code>canMove</code>. That's why it made sense to extract an Effect Event.</p> <p>Read Removing Effect Dependencies for other correct alternatives to suppressing the linter.</p> <p></p>"},{"location":"learn/separating-events-from-effects/#limitations-of-effect-events","title":"Limitations of Effect Events","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>Effect Events are very limited in how you can use them:</p> <ul> <li>Only call them from inside Effects.</li> <li>Never pass them to other components or Hooks.</li> </ul> <p>For example, don't declare and pass an Effect Event like this:</p> <pre><code>function Timer() {\nconst [count, setCount] = useState(0);\n\nconst onTick = useEffectEvent(() =&gt; {\nsetCount(count + 1);\n});\n\nuseTimer(onTick, 1000); // \ud83d\udd34 Avoid: Passing Effect Events\n\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n\nfunction useTimer(callback, delay) {\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\ncallback();\n}, delay);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [delay, callback]); // Need to specify \"callback\" in dependencies\n}\n</code></pre> <p>Instead, always declare Effect Events directly next to the Effects that use them:</p> <pre><code>function Timer() {\nconst [count, setCount] = useState(0);\nuseTimer(() =&gt; {\nsetCount(count + 1);\n}, 1000);\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n\nfunction useTimer(callback, delay) {\nconst onTick = useEffectEvent(() =&gt; {\ncallback();\n});\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nonTick(); // \u2705 Good: Only called locally inside an Effect\n}, delay);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [delay]); // No need to specify \"onTick\" (an Effect Event) as a dependency\n}\n</code></pre> <p>Effect Events are non-reactive \"pieces\" of your Effect code. They should be next to the Effect using them.</p> <p> <ul> <li>Event handlers run in response to specific interactions.</li> <li>Effects run whenever synchronization is needed.</li> <li>Logic inside event handlers is not reactive.</li> <li>Logic inside Effects is reactive.</li> <li>You can move non-reactive logic from Effects into Effect Events.</li> <li>Only call Effect Events from inside Effects.</li> <li>Don't pass Effect Events to other components or Hooks.</li> </ul> <p></p> <p>"},{"location":"learn/separating-events-from-effects/#fix-a-variable-that-doesnt-update","title":"Fix a variable that doesn't update","text":"<p>This <code>Timer</code> component keeps a <code>count</code> state variable which increases every second. The value by which it's increasing is stored in the <code>increment</code> state variable. You can control the <code>increment</code> variable with the plus and minus buttons.</p> <p>However, no matter how many times you click the plus button, the counter is still incremented by one every second. What's wrong with this code? Why is <code>increment</code> always equal to <code>1</code> inside the Effect's code? Find the mistake and fix it.</p> <p> <p>To fix this code, it's enough to follow the rules.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + increment);\n}, 1000);\nreturn () =&gt; {\nclearInterval(id);\n};\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nEvery second, increment by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p> <p>As usual, when you're looking for bugs in Effects, start by searching for linter suppressions.</p> <p>If you remove the suppression comment, React will tell you that this Effect's code depends on <code>increment</code>, but you \"lied\" to React by claiming that this Effect does not depend on any reactive values (<code>[]</code>). Add <code>increment</code> to the dependency array:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + increment);\n}, 1000);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [increment]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nEvery second, increment by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p>Now, when <code>increment</code> changes, React will re-synchronize your Effect, which will restart the interval.</p> <p></p>"},{"location":"learn/separating-events-from-effects/#fix-a-freezing-counter","title":"Fix a freezing counter","text":"<p>This <code>Timer</code> component keeps a <code>count</code> state variable which increases every second. The value by which it's increasing is stored in the <code>increment</code> state variable, which you can control it with the plus and minus buttons. For example, try pressing the plus button nine times, and notice that the <code>count</code> now increases each second by ten rather than by one.</p> <p>There is a small issue with this user interface. You might notice that if you keep pressing the plus or minus buttons faster than once per second, the timer itself seems to pause. It only resumes after a second passes since the last time you've pressed either button. Find why this is happening, and fix the issue so that the timer ticks on every second without interruptions.</p> <p> <p>It seems like the Effect which sets up the timer \"reacts\" to the <code>increment</code> value. Does the line that uses the current <code>increment</code> value in order to call <code>setCount</code> really need to be reactive?</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nsetCount((c) =&gt; c + increment);\n}, 1000);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [increment]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nEvery second, increment by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p> <p>The issue is that the code inside the Effect uses the <code>increment</code> state variable. Since it's a dependency of your Effect, every change to <code>increment</code> causes the Effect to re-synchronize, which causes the interval to clear. If you keep clearing the interval every time before it has a chance to fire, it will appear as if the timer has stalled.</p> <p>To solve the issue, extract an <code>onTick</code> Effect Event from the Effect:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\n\nconst onTick = useEffectEvent(() =&gt; {\nsetCount((c) =&gt; c + increment);\n});\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nonTick();\n}, 1000);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nEvery second, increment by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p>Since <code>onTick</code> is an Effect Event, the code inside it isn't reactive. The change to <code>increment</code> does not trigger any Effects.</p> <p></p>"},{"location":"learn/separating-events-from-effects/#fix-a-non-adjustable-delay","title":"Fix a non-adjustable delay","text":"<p>In this example, you can customize the interval delay. It's stored in a <code>delay</code> state variable which is updated by two buttons. However, even if you press the \"plus 100 ms\" button until the <code>delay</code> is 1000 milliseconds (that is, a second), you'll notice that the timer still increments very fast (every 100 ms). It's as if your changes to the <code>delay</code> are ignored. Find and fix the bug.</p> <p> <p>Code inside Effect Events is not reactive. Are there cases in which you would want the <code>setInterval</code> call to re-run?</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\nconst [delay, setDelay] = useState(100);\n\nconst onTick = useEffectEvent(() =&gt; {\nsetCount((c) =&gt; c + increment);\n});\n\nconst onMount = useEffectEvent(() =&gt; {\nreturn setInterval(() =&gt; {\nonTick();\n}, delay);\n});\n\nuseEffect(() =&gt; {\nconst id = onMount();\nreturn () =&gt; {\nclearInterval(id);\n};\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nIncrement by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;p&gt;\nIncrement delay:\n&lt;button\ndisabled={delay === 100}\non_click={() =&gt; {\nsetDelay((d) =&gt; d - 100);\n}}\n&gt;\n\u2013100 ms\n&lt;/button&gt;\n&lt;b&gt;{delay} ms&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetDelay((d) =&gt; d + 100);\n}}\n&gt;\n+100 ms\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p> <p>The problem with the above example is that it extracted an Effect Event called <code>onMount</code> without considering what the code should actually be doing. You should only extract Effect Events for a specific reason: when you want to make a part of your code non-reactive. However, the <code>setInterval</code> call should be reactive with respect to the <code>delay</code> state variable. If the <code>delay</code> changes, you want to set up the interval from scratch! To fix this code, pull all the reactive code back inside the Effect:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\n\nexport default function Timer() {\nconst [count, setCount] = useState(0);\nconst [increment, setIncrement] = useState(1);\nconst [delay, setDelay] = useState(100);\n\nconst onTick = useEffectEvent(() =&gt; {\nsetCount((c) =&gt; c + increment);\n});\n\nuseEffect(() =&gt; {\nconst id = setInterval(() =&gt; {\nonTick();\n}, delay);\nreturn () =&gt; {\nclearInterval(id);\n};\n}, [delay]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;\nCounter: {count}\n&lt;button on_click={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;p&gt;\nIncrement by:\n&lt;button\ndisabled={increment === 0}\non_click={() =&gt; {\nsetIncrement((i) =&gt; i - 1);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;b&gt;{increment}&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetIncrement((i) =&gt; i + 1);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;p&gt;\nIncrement delay:\n&lt;button\ndisabled={delay === 100}\non_click={() =&gt; {\nsetDelay((d) =&gt; d - 100);\n}}\n&gt;\n\u2013100 ms\n&lt;/button&gt;\n&lt;b&gt;{delay} ms&lt;/b&gt;\n&lt;button\non_click={() =&gt; {\nsetDelay((d) =&gt; d + 100);\n}}\n&gt;\n+100 ms\n&lt;/button&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 10px;\n}\n</code></pre> <p>In general, you should be suspicious of functions like <code>onMount</code> that focus on the timing rather than the purpose of a piece of code. It may feel \"more descriptive\" at first but it obscures your intent. As a rule of thumb, Effect Events should correspond to something that happens from the user's perspective. For example, <code>onMessage</code>, <code>onTick</code>, <code>onVisit</code>, or <code>onConnected</code> are good Effect Event names. Code inside them would likely not need to be reactive. On the other hand, <code>onMount</code>, <code>onUpdate</code>, <code>onUnmount</code>, or <code>onAfterRender</code> are so generic that it's easy to accidentally put code that should be reactive into them. This is why you should name your Effect Events after what the user thinks has happened, not when some code happened to run.</p> <p></p>"},{"location":"learn/separating-events-from-effects/#fix-a-delayed-notification","title":"Fix a delayed notification","text":"<p>When you join a chat room, this component shows a notification. However, it doesn't show the notification immediately. Instead, the notification is artificially delayed by two seconds so that the user has a chance to look around the UI.</p> <p>This almost works, but there is a bug. Try changing the dropdown from \"general\" to \"travel\" and then to \"music\" very quickly. If you do it fast enough, you will see two notifications (as expected!) but they will both say \"Welcome to music\".</p> <p>Fix it so that when you switch from \"general\" to \"travel\" and then to \"music\" very quickly, you see two notifications, the first one being \"Welcome to travel\" and the second one being \"Welcome to music\". (For an additional challenge, assuming you've already made the notifications show the correct rooms, change the code so that only the latter notification is displayed.)</p> <p> <p>Your Effect knows which room it connected to. Is there any information that you might want to pass to your Effect Event?</p> <p></p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent(() =&gt; {\nshowNotification(\"Welcome to \" + roomId, theme);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on(\"connected\", () =&gt; {\nsetTimeout(() =&gt; {\nonConnected();\n}, 2000);\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} theme={isDark ? \"dark\" : \"light\"} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nlet connectedCallback;\nlet timeout;\nreturn {\nconnect() {\ntimeout = setTimeout(() =&gt; {\nif (connectedCallback) {\nconnectedCallback();\n}\n}, 100);\n},\non(event, callback) {\nif (connectedCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"connected\") {\nthrow Error('Only \"connected\" event is supported.');\n}\nconnectedCallback = callback;\n},\ndisconnect() {\nclearTimeout(timeout);\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p> <p>Inside your Effect Event, <code>roomId</code> is the value at the time Effect Event was called.</p> <p>Your Effect Event is called with a two second delay. If you're quickly switching from the travel to the music room, by the time the travel room's notification shows, <code>roomId</code> is already <code>\"music\"</code>. This is why both notifications say \"Welcome to music\".</p> <p>To fix the issue, instead of reading the latest <code>roomId</code> inside the Effect Event, make it a parameter of your Effect Event, like <code>connectedRoomId</code> below. Then pass <code>roomId</code> from your Effect by calling <code>onConnected(roomId)</code>:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent((connectedRoomId) =&gt; {\nshowNotification(\"Welcome to \" + connectedRoomId, theme);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.on(\"connected\", () =&gt; {\nsetTimeout(() =&gt; {\nonConnected(roomId);\n}, 2000);\n});\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} theme={isDark ? \"dark\" : \"light\"} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nlet connectedCallback;\nlet timeout;\nreturn {\nconnect() {\ntimeout = setTimeout(() =&gt; {\nif (connectedCallback) {\nconnectedCallback();\n}\n}, 100);\n},\non(event, callback) {\nif (connectedCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"connected\") {\nthrow Error('Only \"connected\" event is supported.');\n}\nconnectedCallback = callback;\n},\ndisconnect() {\nclearTimeout(timeout);\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p>The Effect that had <code>roomId</code> set to <code>\"travel\"</code> (so it connected to the <code>\"travel\"</code> room) will show the notification for <code>\"travel\"</code>. The Effect that had <code>roomId</code> set to <code>\"music\"</code> (so it connected to the <code>\"music\"</code> room) will show the notification for <code>\"music\"</code>. In other words, <code>connectedRoomId</code> comes from your Effect (which is reactive), while <code>theme</code> always uses the latest value.</p> <p>To solve the additional challenge, save the notification timeout ID and clear it in the cleanup function of your Effect:</p> <pre><code>{\n\"dependencies\": {\n\"react\": \"experimental\",\n\"react-dom\": \"experimental\",\n\"react-scripts\": \"latest\",\n\"toastify-js\": \"1.12.0\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\nimport { experimental_useEffectEvent as useEffectEvent } from \"react\";\nimport { createConnection, sendMessage } from \"./chat.js\";\nimport { showNotification } from \"./notifications.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId, theme }) {\nconst onConnected = useEffectEvent((connectedRoomId) =&gt; {\nshowNotification(\"Welcome to \" + connectedRoomId, theme);\n});\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nlet notificationTimeoutId;\nconnection.on(\"connected\", () =&gt; {\nnotificationTimeoutId = setTimeout(() =&gt; {\nonConnected(roomId);\n}, 2000);\n});\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\nif (notificationTimeoutId !== undefined) {\nclearTimeout(notificationTimeoutId);\n}\n};\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;;\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nUse dark theme\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} theme={isDark ? \"dark\" : \"light\"} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nlet connectedCallback;\nlet timeout;\nreturn {\nconnect() {\ntimeout = setTimeout(() =&gt; {\nif (connectedCallback) {\nconnectedCallback();\n}\n}, 100);\n},\non(event, callback) {\nif (connectedCallback) {\nthrow Error(\"Cannot add the handler twice.\");\n}\nif (event !== \"connected\") {\nthrow Error('Only \"connected\" event is supported.');\n}\nconnectedCallback = callback;\n},\ndisconnect() {\nclearTimeout(timeout);\n},\n};\n}\n</code></pre> <pre><code>import Toastify from \"toastify-js\";\nimport \"toastify-js/src/toastify.css\";\n\nexport function showNotification(message, theme) {\nToastify({\ntext: message,\nduration: 2000,\ngravity: \"top\",\nposition: \"right\",\nstyle: {\nbackground: theme === \"dark\" ? \"black\" : \"white\",\ncolor: theme === \"dark\" ? \"white\" : \"black\",\n},\n}).showToast();\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p>This ensures that already scheduled (but not yet displayed) notifications get cancelled when you change rooms.</p> <p></p> <p></p>"},{"location":"learn/sharing-state-between-components/","title":"Sharing State Between Components \ud83d\udea7","text":""},{"location":"learn/sharing-state-between-components/#overview","title":"Overview","text":"<p>  Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and it's one of the most common things you will do writing React code.  </p> <p>You will learn</p> <ul> <li>How to share state between components by lifting it up</li> <li>What are controlled and uncontrolled components</li> </ul>"},{"location":"learn/sharing-state-between-components/#lifting-state-up-by-example","title":"Lifting state up by example","text":"<p>In this example, a parent <code>Accordion</code> component renders two separate <code>Panel</code>s:</p> <ul> <li><code>Accordion</code><ul> <li><code>Panel</code></li> <li><code>Panel</code></li> </ul> </li> </ul> <p>Each <code>Panel</code> component has a boolean <code>isActive</code> state that determines whether its content is visible.</p> <p>Press the Show button for both panels:</p> <pre><code>import { useState } from \"react\";\n\nfunction Panel({ title, children }) {\nconst [isActive, setIsActive] = useState(false);\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;h3&gt;{title}&lt;/h3&gt;\n{isActive ? (\n&lt;p&gt;{children}&lt;/p&gt;\n) : (\n&lt;button on_click={() =&gt; setIsActive(true)}&gt;Show&lt;/button&gt;\n)}\n&lt;/section&gt;\n);\n}\n\nexport default function Accordion() {\nreturn (\n&lt;&gt;\n&lt;h2&gt;Almaty, Kazakhstan&lt;/h2&gt;\n&lt;Panel title=\"About\"&gt;\nWith a population of about 2 million, Almaty is Kazakhstan's\nlargest city. From 1929 to 1997, it was its capital city.\n&lt;/Panel&gt;\n&lt;Panel title=\"Etymology\"&gt;\nThe name comes from &lt;span lang=\"kk-KZ\"&gt;\u0430\u043b\u043c\u0430&lt;/span&gt;, the Kazakh\nword for \"apple\" and is often translated as \"full of apples\". In\nfact, the region surrounding Almaty is thought to be the\nancestral home of the apple, and the wild{\" \"}\n&lt;i lang=\"la\"&gt;Malus sieversii&lt;/i&gt; is considered a likely\ncandidate for the ancestor of the modern domestic apple.\n&lt;/Panel&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>h3,\np {\nmargin: 5px 0px;\n}\n.panel {\npadding: 10px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Notice how pressing one panel's button does not affect the other panel--they are independent.</p> <p>But now let's say you want to change it so that only one panel is expanded at any given time. With that design, expanding the second panel should collapse the first one. How would you do that?</p> <p>To coordinate these two panels, you need to \"lift their state up\" to a parent component in three steps:</p> <ol> <li>Remove state from the child components.</li> <li>Pass hardcoded data from the common parent.</li> <li>Add state to the common parent and pass it down together with the event handlers.</li> </ol> <p>This will allow the <code>Accordion</code> component to coordinate both <code>Panel</code>s and only expand one at a time.</p>"},{"location":"learn/sharing-state-between-components/#step-1-remove-state-from-the-child-components","title":"Step 1: Remove state from the child components","text":"<p>You will give control of the <code>Panel</code>'s <code>isActive</code> to its parent component. This means that the parent component will pass <code>isActive</code> to <code>Panel</code> as a prop instead. Start by removing this line from the <code>Panel</code> component:</p> <pre><code>const [isActive, setIsActive] = useState(false);\n</code></pre> <p>And instead, add <code>isActive</code> to the <code>Panel</code>'s list of props:</p> <pre><code>function Panel({ title, children, isActive }) {\n</code></pre> <p>Now the <code>Panel</code>'s parent component can control <code>isActive</code> by passing it down as a prop. Conversely, the <code>Panel</code> component now has no control over the value of <code>isActive</code>--it's now up to the parent component!</p>"},{"location":"learn/sharing-state-between-components/#step-2-pass-hardcoded-data-from-the-common-parent","title":"Step 2: Pass hardcoded data from the common parent","text":"<p>To lift state up, you must locate the closest common parent component of both of the child components that you want to coordinate:</p> <ul> <li><code>Accordion</code> (closest common parent)<ul> <li><code>Panel</code></li> <li><code>Panel</code></li> </ul> </li> </ul> <p>In this example, it's the <code>Accordion</code> component. Since it's above both panels and can control their props, it will become the \"source of truth\" for which panel is currently active. Make the <code>Accordion</code> component pass a hardcoded value of <code>isActive</code> (for example, <code>true</code>) to both panels:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Accordion() {\nreturn (\n&lt;&gt;\n&lt;h2&gt;Almaty, Kazakhstan&lt;/h2&gt;\n&lt;Panel title=\"About\" isActive={true}&gt;\nWith a population of about 2 million, Almaty is Kazakhstan's\nlargest city. From 1929 to 1997, it was its capital city.\n&lt;/Panel&gt;\n&lt;Panel title=\"Etymology\" isActive={true}&gt;\nThe name comes from &lt;span lang=\"kk-KZ\"&gt;\u0430\u043b\u043c\u0430&lt;/span&gt;, the Kazakh\nword for \"apple\" and is often translated as \"full of apples\". In\nfact, the region surrounding Almaty is thought to be the\nancestral home of the apple, and the wild{\" \"}\n&lt;i lang=\"la\"&gt;Malus sieversii&lt;/i&gt; is considered a likely\ncandidate for the ancestor of the modern domestic apple.\n&lt;/Panel&gt;\n&lt;/&gt;\n);\n}\n\nfunction Panel({ title, children, isActive }) {\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;h3&gt;{title}&lt;/h3&gt;\n{isActive ? (\n&lt;p&gt;{children}&lt;/p&gt;\n) : (\n&lt;button on_click={() =&gt; setIsActive(true)}&gt;Show&lt;/button&gt;\n)}\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>h3,\np {\nmargin: 5px 0px;\n}\n.panel {\npadding: 10px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>Try editing the hardcoded <code>isActive</code> values in the <code>Accordion</code> component and see the result on the screen.</p>"},{"location":"learn/sharing-state-between-components/#step-3-add-state-to-the-common-parent","title":"Step 3: Add state to the common parent","text":"<p>Lifting state up often changes the nature of what you're storing as state.</p> <p>In this case, only one panel should be active at a time. This means that the <code>Accordion</code> common parent component needs to keep track of which panel is the active one. Instead of a <code>boolean</code> value, it could use a number as the index of the active <code>Panel</code> for the state variable:</p> <pre><code>const [activeIndex, setActiveIndex] = useState(0);\n</code></pre> <p>When the <code>activeIndex</code> is <code>0</code>, the first panel is active, and when it's <code>1</code>, it's the second one.</p> <p>Clicking the \"Show\" button in either <code>Panel</code> needs to change the active index in <code>Accordion</code>. A <code>Panel</code> can't set the <code>activeIndex</code> state directly because it's defined inside the <code>Accordion</code>. The <code>Accordion</code> component needs to explicitly allow the <code>Panel</code> component to change its state by passing an event handler down as a prop:</p> <pre><code>&lt;&gt;\n&lt;Panel isActive={activeIndex === 0} onShow={() =&gt; setActiveIndex(0)}&gt;\n...\n&lt;/Panel&gt;\n&lt;Panel isActive={activeIndex === 1} onShow={() =&gt; setActiveIndex(1)}&gt;\n...\n&lt;/Panel&gt;\n&lt;/&gt;\n</code></pre> <p>The <code>&lt;button&gt;</code> inside the <code>Panel</code> will now use the <code>onShow</code> prop as its click event handler:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Accordion() {\nconst [activeIndex, setActiveIndex] = useState(0);\nreturn (\n&lt;&gt;\n&lt;h2&gt;Almaty, Kazakhstan&lt;/h2&gt;\n&lt;Panel\ntitle=\"About\"\nisActive={activeIndex === 0}\nonShow={() =&gt; setActiveIndex(0)}\n&gt;\nWith a population of about 2 million, Almaty is Kazakhstan's\nlargest city. From 1929 to 1997, it was its capital city.\n&lt;/Panel&gt;\n&lt;Panel\ntitle=\"Etymology\"\nisActive={activeIndex === 1}\nonShow={() =&gt; setActiveIndex(1)}\n&gt;\nThe name comes from &lt;span lang=\"kk-KZ\"&gt;\u0430\u043b\u043c\u0430&lt;/span&gt;, the Kazakh\nword for \"apple\" and is often translated as \"full of apples\". In\nfact, the region surrounding Almaty is thought to be the\nancestral home of the apple, and the wild{\" \"}\n&lt;i lang=\"la\"&gt;Malus sieversii&lt;/i&gt; is considered a likely\ncandidate for the ancestor of the modern domestic apple.\n&lt;/Panel&gt;\n&lt;/&gt;\n);\n}\n\nfunction Panel({ title, children, isActive, onShow }) {\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;h3&gt;{title}&lt;/h3&gt;\n{isActive ? (\n&lt;p&gt;{children}&lt;/p&gt;\n) : (\n&lt;button on_click={onShow}&gt;Show&lt;/button&gt;\n)}\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>h3,\np {\nmargin: 5px 0px;\n}\n.panel {\npadding: 10px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p>This completes lifting state up! Moving state into the common parent component allowed you to coordinate the two panels. Using the active index instead of two \"is shown\" flags ensured that only one panel is active at a given time. And passing down the event handler to the child allowed the child to change the parent's state.</p> <p>"},{"location":"learn/sharing-state-between-components/#controlled-and-uncontrolled-components","title":"Controlled and uncontrolled components","text":"<p>It is common to call a component with some local state \"uncontrolled\". For example, the original <code>Panel</code> component with an <code>isActive</code> state variable is uncontrolled because its parent cannot influence whether the panel is active or not.</p> <p>In contrast, you might say a component is \"controlled\" when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The final <code>Panel</code> component with the <code>isActive</code> prop is controlled by the <code>Accordion</code> component.</p> <p>Uncontrolled components are easier to use within their parents because they require less configuration. But they're less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props.</p> <p>In practice, \"controlled\" and \"uncontrolled\" aren't strict technical terms--each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.</p> <p>When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later.</p> <p></p>"},{"location":"learn/sharing-state-between-components/#a-single-source-of-truth-for-each-state","title":"A single source of truth for each state","text":"<p>In a React application, many components will have their own state. Some state may \"live\" close to the leaf components (components at the bottom of the tree) like inputs. Other state may \"live\" closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!</p> <p>For each unique piece of state, you will choose the component that \"owns\" it. This principle is also known as having a \"single source of truth\". It doesn't mean that all state lives in one place--but that for each piece of state, there is a specific component that holds that piece of information. Instead of duplicating shared state between components, lift it up to their common shared parent, and pass it down to the children that need it.</p> <p>Your app will change as you work on it. It is common that you will move state down or back up while you're still figuring out where each piece of the state \"lives\". This is all part of the process!</p> <p>To see what this feels like in practice with a few more components, read Thinking in React.</p> <p> <ul> <li>When you want to coordinate two components, move their state to their common parent.</li> <li>Then pass the information down through props from their common parent.</li> <li>Finally, pass the event handlers down so that the children can change the parent's state.</li> <li>It's useful to consider components as \"controlled\" (driven by props) or \"uncontrolled\" (driven by state).</li> </ul> <p></p> <p>"},{"location":"learn/sharing-state-between-components/#synced-inputs","title":"Synced inputs","text":"<p>These two inputs are independent. Make them stay in sync: editing one input should update the other input with the same text, and vice versa.</p> <p> <p>You'll need to lift their state up into the parent component.</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function SyncedInputs() {\nreturn (\n&lt;&gt;\n&lt;Input label=\"First input\" /&gt;\n&lt;Input label=\"Second input\" /&gt;\n&lt;/&gt;\n);\n}\n\nfunction Input({ label }) {\nconst [text, setText] = useState(\"\");\n\nfunction handleChange(e) {\nsetText(e.target.value);\n}\n\nreturn (\n&lt;label&gt;\n{label} &lt;input value={text} onChange={handleChange} /&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>input {\nmargin: 5px;\n}\nlabel {\ndisplay: block;\n}\n</code></pre> <p> <p>Move the <code>text</code> state variable into the parent component along with the <code>handleChange</code> handler. Then pass them down as props to both of the <code>Input</code> components. This will keep them in sync.</p> <pre><code>import { useState } from \"react\";\n\nexport default function SyncedInputs() {\nconst [text, setText] = useState(\"\");\n\nfunction handleChange(e) {\nsetText(e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;Input label=\"First input\" value={text} onChange={handleChange} /&gt;\n&lt;Input label=\"Second input\" value={text} onChange={handleChange} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction Input({ label, value, onChange }) {\nreturn (\n&lt;label&gt;\n{label} &lt;input value={value} onChange={onChange} /&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>input {\nmargin: 5px;\n}\nlabel {\ndisplay: block;\n}\n</code></pre> <p></p>"},{"location":"learn/sharing-state-between-components/#filtering-a-list","title":"Filtering a list","text":"<p>In this example, the <code>SearchBar</code> has its own <code>query</code> state that controls the text input. Its parent <code>FilterableList</code> component displays a <code>List</code> of items, but it doesn't take the search query into account.</p> <p>Use the <code>filterItems(foods, query)</code> function to filter the list according to the search query. To test your changes, verify that typing \"s\" into the input filters down the list to \"Sushi\", \"Shish kebab\", and \"Dim sum\".</p> <p>Note that <code>filterItems</code> is already implemented and imported so you don't need to write it yourself!</p> <p> <p>You will want to remove the <code>query</code> state and the <code>handleChange</code> handler from the <code>SearchBar</code>, and move them to the <code>FilterableList</code>. Then pass them down to <code>SearchBar</code> as <code>query</code> and <code>onChange</code> props.</p> <p></p> <pre><code>import { useState } from \"react\";\nimport { foods, filterItems } from \"./data.js\";\n\nexport default function FilterableList() {\nreturn (\n&lt;&gt;\n&lt;SearchBar /&gt;\n&lt;hr /&gt;\n&lt;List items={foods} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction SearchBar() {\nconst [query, setQuery] = useState(\"\");\n\nfunction handleChange(e) {\nsetQuery(e.target.value);\n}\n\nreturn (\n&lt;label&gt;\nSearch: &lt;input value={query} onChange={handleChange} /&gt;\n&lt;/label&gt;\n);\n}\n\nfunction List({ items }) {\nreturn (\n&lt;table&gt;\n&lt;tbody&gt;\n{items.map((food) =&gt; (\n&lt;tr key={food.id}&gt;\n&lt;td&gt;{food.name}&lt;/td&gt;\n&lt;td&gt;{food.description}&lt;/td&gt;\n&lt;/tr&gt;\n))}\n&lt;/tbody&gt;\n&lt;/table&gt;\n);\n}\n</code></pre> <pre><code>export function filterItems(items, query) {\nquery = query.toLowerCase();\nreturn items.filter((item) =&gt;\nitem.name\n.split(\" \")\n.some((word) =&gt; word.toLowerCase().startsWith(query))\n);\n}\n\nexport const foods = [\n{\nid: 0,\nname: \"Sushi\",\ndescription:\n\"Sushi is a traditional Japanese dish of prepared vinegared rice\",\n},\n{\nid: 1,\nname: \"Dal\",\ndescription:\n\"The most common way of preparing dal is in the form of a soup to which onions, tomatoes and various spices may be added\",\n},\n{\nid: 2,\nname: \"Pierogi\",\ndescription:\n\"Pierogi are filled dumplings made by wrapping unleavened dough around a savoury or sweet filling and cooking in boiling water\",\n},\n{\nid: 3,\nname: \"Shish kebab\",\ndescription:\n\"Shish kebab is a popular meal of skewered and grilled cubes of meat.\",\n},\n{\nid: 4,\nname: \"Dim sum\",\ndescription:\n\"Dim sum is a large range of small dishes that Cantonese people traditionally enjoy in restaurants for breakfast and lunch\",\n},\n];\n</code></pre> <p> <p>Lift the <code>query</code> state up into the <code>FilterableList</code> component. Call <code>filterItems(foods, query)</code> to get the filtered list and pass it down to the <code>List</code>. Now changing the query input is reflected in the list:</p> <pre><code>import { useState } from \"react\";\nimport { foods, filterItems } from \"./data.js\";\n\nexport default function FilterableList() {\nconst [query, setQuery] = useState(\"\");\nconst results = filterItems(foods, query);\n\nfunction handleChange(e) {\nsetQuery(e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;SearchBar query={query} onChange={handleChange} /&gt;\n&lt;hr /&gt;\n&lt;List items={results} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction SearchBar({ query, onChange }) {\nreturn (\n&lt;label&gt;\nSearch: &lt;input value={query} onChange={onChange} /&gt;\n&lt;/label&gt;\n);\n}\n\nfunction List({ items }) {\nreturn (\n&lt;table&gt;\n&lt;tbody&gt;\n{items.map((food) =&gt; (\n&lt;tr key={food.id}&gt;\n&lt;td&gt;{food.name}&lt;/td&gt;\n&lt;td&gt;{food.description}&lt;/td&gt;\n&lt;/tr&gt;\n))}\n&lt;/tbody&gt;\n&lt;/table&gt;\n);\n}\n</code></pre> <pre><code>export function filterItems(items, query) {\nquery = query.toLowerCase();\nreturn items.filter((item) =&gt;\nitem.name\n.split(\" \")\n.some((word) =&gt; word.toLowerCase().startsWith(query))\n);\n}\n\nexport const foods = [\n{\nid: 0,\nname: \"Sushi\",\ndescription:\n\"Sushi is a traditional Japanese dish of prepared vinegared rice\",\n},\n{\nid: 1,\nname: \"Dal\",\ndescription:\n\"The most common way of preparing dal is in the form of a soup to which onions, tomatoes and various spices may be added\",\n},\n{\nid: 2,\nname: \"Pierogi\",\ndescription:\n\"Pierogi are filled dumplings made by wrapping unleavened dough around a savoury or sweet filling and cooking in boiling water\",\n},\n{\nid: 3,\nname: \"Shish kebab\",\ndescription:\n\"Shish kebab is a popular meal of skewered and grilled cubes of meat.\",\n},\n{\nid: 4,\nname: \"Dim sum\",\ndescription:\n\"Dim sum is a large range of small dishes that Cantonese people traditionally enjoy in restaurants for breakfast and lunch\",\n},\n];\n</code></pre> <p></p> <p></p>"},{"location":"learn/state-a-components-memory/","title":"State: A Component's Memory \ud83d\udea7","text":""},{"location":"learn/state-a-components-memory/#overview","title":"Overview","text":"<p>  Components often need to change what's on the screen as a result of an interaction. Typing into the form should update the input field, clicking \"next\" on an image carousel should change which image is displayed, clicking \"buy\" should put a product in the shopping cart. Components need to \"remember\" things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state.  </p> <p>You will learn</p> <ul> <li>How to add a state variable with the <code>useState</code> Hook</li> <li>What pair of values the <code>useState</code> Hook returns</li> <li>How to add more than one state variable</li> <li>Why state is called local</li> </ul>"},{"location":"learn/state-a-components-memory/#when-a-regular-variable-isnt-enough","title":"When a regular variable isn\u2019t enough","text":"<p>Here's a component that renders a sculpture image. Clicking the \"Next\" button should show the next sculpture by changing the <code>index</code> to <code>1</code>, then <code>2</code>, and so on. However, this won't work (you can try it!):</p> <pre><code>import { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nlet index = 0;\n\nfunction handleClick() {\nindex = index + 1;\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Next&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;p&gt;{sculpture.description}&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>h2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\nbutton {\ndisplay: block;\nmargin-top: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p>The <code>handleClick</code> event handler is updating a local variable, <code>index</code>. But two things prevent that change from being visible:</p> <ol> <li>Local variables don't persist between renders. When React renders this component a second time, it renders it from scratch\u2014it doesn't consider any changes to the local variables.</li> <li>Changes to local variables won't trigger renders. React doesn't realize it needs to render the component again with the new data.</li> </ol> <p>To update a component with new data, two things need to happen:</p> <ol> <li>Retain the data between renders.</li> <li>Trigger React to render the component with new data (re-rendering).</li> </ol> <p>The <code>useState</code> Hook provides those two things:</p> <ol> <li>A state variable to retain the data between renders.</li> <li>A state setter function to update the variable and trigger React to render the component again.</li> </ol>"},{"location":"learn/state-a-components-memory/#adding-a-state-variable","title":"Adding a state variable","text":"<p>To add a state variable, import <code>useState</code> from React at the top of the file:</p> <pre><code>import { useState } from \"react\";\n</code></pre> <p>Then, replace this line:</p> <pre><code>let index = 0;\n</code></pre> <p>with</p> <pre><code>const [index, setIndex] = useState(0);\n</code></pre> <p><code>index</code> is a state variable and <code>setIndex</code> is the setter function.</p> <p>The <code>[</code> and <code>]</code> syntax here is called array destructuring and it lets you read values from an array. The array returned by <code>useState</code> always has exactly two items.</p> <p>This is how they work together in <code>handleClick</code>:</p> <pre><code>function handleClick() {\nsetIndex(index + 1);\n}\n</code></pre> <p>Now clicking the \"Next\" button switches the current sculpture:</p> <pre><code>import { useState } from \"react\";\nimport { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\n\nfunction handleClick() {\nsetIndex(index + 1);\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Next&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;p&gt;{sculpture.description}&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>h2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\nbutton {\ndisplay: block;\nmargin-top: 10px;\nmargin-bottom: 10px;\n}\n</code></pre>"},{"location":"learn/state-a-components-memory/#meet-your-first-hook","title":"Meet your first Hook","text":"<p>In React, <code>useState</code>, as well as any other function starting with \"<code>use</code>\", is called a Hook.</p> <p>Hooks are special functions that are only available while React is rendering (which we'll get into in more detail on the next page). They let you \"hook into\" different React features.</p> <p>State is just one of those features, but you will meet the other Hooks later.</p> <p> <p>Hooks\u2014functions starting with <code>use</code>\u2014can only be called at the top level of your components or your own Hooks. You can't call Hooks inside conditions, loops, or other nested functions. Hooks are functions, but it's helpful to think of them as unconditional declarations about your component's needs. You \"use\" React features at the top of your component similar to how you \"import\" modules at the top of your file.</p> <p></p>"},{"location":"learn/state-a-components-memory/#anatomy-of-usestate","title":"Anatomy of <code>useState</code>","text":"<p>When you call <code>useState</code>, you are telling React that you want this component to remember something:</p> <pre><code>const [index, setIndex] = useState(0);\n</code></pre> <p>In this case, you want React to remember <code>index</code>.</p> <p> <p>The convention is to name this pair like <code>const [something, setSomething]</code>. You could name it anything you like, but conventions make things easier to understand across projects.</p> <p></p> <p>The only argument to <code>useState</code> is the initial value of your state variable. In this example, the <code>index</code>'s initial value is set to <code>0</code> with <code>useState(0)</code>.</p> <p>Every time your component renders, <code>useState</code> gives you an array containing two values:</p> <ol> <li>The state variable (<code>index</code>) with the value you stored.</li> <li>The state setter function (<code>setIndex</code>) which can update the state variable and trigger React to render the component again.</li> </ol> <p>Here's how that happens in action:</p> <pre><code>const [index, setIndex] = useState(0);\n</code></pre> <ol> <li>Your component renders the first time. Because you passed <code>0</code> to <code>useState</code> as the initial value for <code>index</code>, it will return <code>[0, setIndex]</code>. React remembers <code>0</code> is the latest state value.</li> <li>You update the state. When a user clicks the button, it calls <code>setIndex(index + 1)</code>. <code>index</code> is <code>0</code>, so it's <code>setIndex(1)</code>. This tells React to remember <code>index</code> is <code>1</code> now and triggers another render.</li> <li>Your component's second render. React still sees <code>useState(0)</code>, but because React remembers that you set <code>index</code> to <code>1</code>, it returns <code>[1, setIndex]</code> instead.</li> <li>And so on!</li> </ol>"},{"location":"learn/state-a-components-memory/#giving-a-component-multiple-state-variables","title":"Giving a component multiple state variables","text":"<p>You can have as many state variables of as many types as you like in one component. This component has two state variables, a number <code>index</code> and a boolean <code>showMore</code> that's toggled when you click \"Show details\":</p> <pre><code>import { useState } from \"react\";\nimport { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst [showMore, setShowMore] = useState(false);\n\nfunction handleNextClick() {\nsetIndex(index + 1);\n}\n\nfunction handleMoreClick() {\nsetShowMore(!showMore);\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleNextClick}&gt;Next&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;button on_click={handleMoreClick}&gt;\n{showMore ? \"Hide\" : \"Show\"} details\n&lt;/button&gt;\n{showMore &amp;&amp; &lt;p&gt;{sculpture.description}&lt;/p&gt;}\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>h2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\nbutton {\ndisplay: block;\nmargin-top: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p>It is a good idea to have multiple state variables if their state is unrelated, like <code>index</code> and <code>showMore</code> in this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it's more convenient to have a single state variable that holds an object than state variable per field. Read Choosing the State Structure for more tips.</p> <p>"},{"location":"learn/state-a-components-memory/#how-does-react-know-which-state-to-return","title":"How does React know which state to return?","text":"<p>You might have noticed that the <code>useState</code> call does not receive any information about which state variable it refers to. There is no \"identifier\" that is passed to <code>useState</code>, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no.</p> <p>Instead, to enable their concise syntax, Hooks rely on a stable call order on every render of the same component. This works well in practice because if you follow the rule above (\"only call Hooks at the top level\"), Hooks will always be called in the same order. Additionally, a linter plugin catches most mistakes.</p> <p>Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to <code>0</code> before rendering. Each time you call <code>useState</code>, React gives you the next state pair and increments the index. You can read more about this mechanism in React Hooks: Not Magic, Just Arrays.</p> <p>This example doesn't use React but it gives you an idea of how <code>useState</code> works internally:</p> <pre><code>let componentHooks = [];\nlet currentHookIndex = 0;\n\n// How useState works inside React (simplified).\nfunction useState(initialState) {\nlet pair = componentHooks[currentHookIndex];\nif (pair) {\n// This is not the first render,\n// so the state pair already exists.\n// Return it and prepare for next Hook call.\ncurrentHookIndex++;\nreturn pair;\n}\n\n// This is the first time we're rendering,\n// so create a state pair and store it.\npair = [initialState, setState];\n\nfunction setState(nextState) {\n// When the user requests a state change,\n// put the new value into the pair.\npair[0] = nextState;\nupdateDOM();\n}\n\n// Store the pair for future renders\n// and prepare for the next Hook call.\ncomponentHooks[currentHookIndex] = pair;\ncurrentHookIndex++;\nreturn pair;\n}\n\nfunction Gallery() {\n// Each useState() call will get the next pair.\nconst [index, setIndex] = useState(0);\nconst [showMore, setShowMore] = useState(false);\n\nfunction handleNextClick() {\nsetIndex(index + 1);\n}\n\nfunction handleMoreClick() {\nsetShowMore(!showMore);\n}\n\nlet sculpture = sculptureList[index];\n// This example doesn't use React, so\n// return an output object instead of JSX.\nreturn {\nonNextClick: handleNextClick,\nonMoreClick: handleMoreClick,\nheader: `${sculpture.name} by ${sculpture.artist}`,\ncounter: `${index + 1} of ${sculptureList.length}`,\nmore: `${showMore ? \"Hide\" : \"Show\"} details`,\ndescription: showMore ? sculpture.description : null,\nimageSrc: sculpture.url,\nimageAlt: sculpture.alt,\n};\n}\n\nfunction updateDOM() {\n// Reset the current Hook index\n// before rendering the component.\ncurrentHookIndex = 0;\nlet output = Gallery();\n\n// Update the DOM to match the output.\n// This is the part React does for you.\nnextButton.onclick = output.onNextClick;\nheader.textContent = output.header;\nmoreButton.onclick = output.onMoreClick;\nmoreButton.textContent = output.more;\nimage.src = output.imageSrc;\nimage.alt = output.imageAlt;\nif (output.description !== null) {\ndescription.textContent = output.description;\ndescription.style.display = \"\";\n} else {\ndescription.style.display = \"none\";\n}\n}\n\nlet nextButton = document.getElementById(\"nextButton\");\nlet header = document.getElementById(\"header\");\nlet moreButton = document.getElementById(\"moreButton\");\nlet description = document.getElementById(\"description\");\nlet image = document.getElementById(\"image\");\nlet sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n\n// Make UI match the initial state.\nupdateDOM();\n</code></pre> <pre><code>&lt;button id=\"nextButton\"&gt;Next&lt;/button&gt;\n&lt;h3 id=\"header\"&gt;&lt;/h3&gt;\n&lt;button id=\"moreButton\"&gt;&lt;/button&gt;\n&lt;p id=\"description\"&gt;&lt;/p&gt;\n&lt;img id=\"image\" /&gt;\n\n&lt;style&gt;\n* {\nbox-sizing: border-box;\n}\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\nbutton {\ndisplay: block;\nmargin-bottom: 10px;\n}\n&lt;/style&gt;\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n</code></pre> <p>You don't have to understand it to use React, but you might find this a helpful mental model.</p> <p></p>"},{"location":"learn/state-a-components-memory/#state-is-isolated-and-private","title":"State is isolated and private","text":"<p>State is local to a component instance on the screen. In other words, if you render the same component twice, each copy will have completely isolated state! Changing one of them will not affect the other.</p> <p>In this example, the <code>Gallery</code> component from earlier is rendered twice with no changes to its logic. Try clicking the buttons inside each of the galleries. Notice that their state is independent:</p> <pre><code>import Gallery from \"./Gallery.js\";\n\nexport default function Page() {\nreturn (\n&lt;div className=\"Page\"&gt;\n&lt;Gallery /&gt;\n&lt;Gallery /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst [showMore, setShowMore] = useState(false);\n\nfunction handleNextClick() {\nsetIndex(index + 1);\n}\n\nfunction handleMoreClick() {\nsetShowMore(!showMore);\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;section&gt;\n&lt;button on_click={handleNextClick}&gt;Next&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;button on_click={handleMoreClick}&gt;\n{showMore ? \"Hide\" : \"Show\"} details\n&lt;/button&gt;\n{showMore &amp;&amp; &lt;p&gt;{sculpture.description}&lt;/p&gt;}\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n.Page &gt; * {\nfloat: left;\nwidth: 50%;\npadding: 10px;\n}\nh2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\nbutton {\ndisplay: block;\nmargin-top: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p>This is what makes state different from regular variables that you might declare at the top of your module. State is not tied to a particular function call or a place in the code, but it's \"local\" to the specific place on the screen. You rendered two <code>&lt;Gallery /&gt;</code> components, so their state is stored separately.</p> <p>Also notice how the <code>Page</code> component doesn't \"know\" anything about the <code>Gallery</code> state or even whether it has any. Unlike props, state is fully private to the component declaring it. The parent component can't change it. This lets you add state to any component or remove it without impacting the rest of the components.</p> <p>What if you wanted both galleries to keep their states in sync? The right way to do it in React is to remove state from child components and add it to their closest shared parent. The next few pages will focus on organizing state of a single component, but we will return to this topic in Sharing State Between Components.</p> <p> <ul> <li>Use a state variable when a component needs to \"remember\" some information between renders.</li> <li>State variables are declared by calling the <code>useState</code> Hook.</li> <li>Hooks are special functions that start with <code>use</code>. They let you \"hook into\" React features like state.</li> <li>Hooks might remind you of imports: they need to be called unconditionally. Calling Hooks, including <code>useState</code>, is only valid at the top level of a component or another Hook.</li> <li>The <code>useState</code> Hook returns a pair of values: the current state and the function to update it.</li> <li>You can have more than one state variable. Internally, React matches them up by their order.</li> <li>State is private to the component. If you render it in two places, each copy gets its own state.</li> </ul> <p></p> <p>"},{"location":"learn/state-a-components-memory/#complete-the-gallery","title":"Complete the gallery","text":"<p>When you press \"Next\" on the last sculpture, the code crashes. Fix the logic to prevent the crash. You may do this by adding extra logic to event handler or by disabling the button when the action is not possible.</p> <p>After fixing the crash, add a \"Previous\" button that shows the previous sculpture. It shouldn't crash on the first sculpture.</p> <pre><code>import { useState } from \"react\";\nimport { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst [showMore, setShowMore] = useState(false);\n\nfunction handleNextClick() {\nsetIndex(index + 1);\n}\n\nfunction handleMoreClick() {\nsetShowMore(!showMore);\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handleNextClick}&gt;Next&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;button on_click={handleMoreClick}&gt;\n{showMore ? \"Hide\" : \"Show\"} details\n&lt;/button&gt;\n{showMore &amp;&amp; &lt;p&gt;{sculpture.description}&lt;/p&gt;}\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n.Page &gt; * {\nfloat: left;\nwidth: 50%;\npadding: 10px;\n}\nh2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\n</code></pre> <p> <p>This adds a guarding condition inside both event handlers and disables the buttons when needed:</p> <pre><code>import { useState } from \"react\";\nimport { sculptureList } from \"./data.js\";\n\nexport default function Gallery() {\nconst [index, setIndex] = useState(0);\nconst [showMore, setShowMore] = useState(false);\n\nlet hasPrev = index &gt; 0;\nlet hasNext = index &lt; sculptureList.length - 1;\n\nfunction handlePrevClick() {\nif (hasPrev) {\nsetIndex(index - 1);\n}\n}\n\nfunction handleNextClick() {\nif (hasNext) {\nsetIndex(index + 1);\n}\n}\n\nfunction handleMoreClick() {\nsetShowMore(!showMore);\n}\n\nlet sculpture = sculptureList[index];\nreturn (\n&lt;&gt;\n&lt;button on_click={handlePrevClick} disabled={!hasPrev}&gt;\nPrevious\n&lt;/button&gt;\n&lt;button on_click={handleNextClick} disabled={!hasNext}&gt;\nNext\n&lt;/button&gt;\n&lt;h2&gt;\n&lt;i&gt;{sculpture.name} &lt;/i&gt;\nby {sculpture.artist}\n&lt;/h2&gt;\n&lt;h3&gt;\n({index + 1} of {sculptureList.length})\n&lt;/h3&gt;\n&lt;button on_click={handleMoreClick}&gt;\n{showMore ? \"Hide\" : \"Show\"} details\n&lt;/button&gt;\n{showMore &amp;&amp; &lt;p&gt;{sculpture.description}&lt;/p&gt;}\n&lt;img src={sculpture.url} alt={sculpture.alt} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export const sculptureList = [\n{\nname: \"Homenaje a la Neurocirug\u00eda\",\nartist: \"Marta Colvin Andrade\",\ndescription:\n\"Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.\",\nurl: \"https://i.imgur.com/Mx7dA2Y.jpg\",\nalt: \"A bronze statue of two crossed hands delicately holding a human brain in their fingertips.\",\n},\n{\nname: \"Floralis Gen\u00e9rica\",\nartist: \"Eduardo Catalano\",\ndescription:\n\"This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.\",\nurl: \"https://i.imgur.com/ZF6s192m.jpg\",\nalt: \"A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.\",\n},\n{\nname: \"Eternal Presence\",\nartist: \"John Woodrow Wilson\",\ndescription:\n'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',\nurl: \"https://i.imgur.com/aTtVpES.jpg\",\nalt: \"The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.\",\n},\n{\nname: \"Moai\",\nartist: \"Unknown Artist\",\ndescription:\n\"Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.\",\nurl: \"https://i.imgur.com/RCwLEoQm.jpg\",\nalt: \"Three monumental stone busts with the heads that are disproportionately large with somber faces.\",\n},\n{\nname: \"Blue Nana\",\nartist: \"Niki de Saint Phalle\",\ndescription:\n\"The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.\",\nurl: \"https://i.imgur.com/Sd1AgUOm.jpg\",\nalt: \"A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.\",\n},\n{\nname: \"Ultimate Form\",\nartist: \"Barbara Hepworth\",\ndescription:\n\"This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.\",\nurl: \"https://i.imgur.com/2heNQDcm.jpg\",\nalt: \"A tall sculpture made of three elements stacked on each other reminding of a human figure.\",\n},\n{\nname: \"Cavaliere\",\nartist: \"Lamidi Olonade Fakeye\",\ndescription:\n\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",\nurl: \"https://i.imgur.com/wIdGuZwm.png\",\nalt: \"An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.\",\n},\n{\nname: \"Big Bellies\",\nartist: \"Alina Szapocznikow\",\ndescription:\n\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",\nurl: \"https://i.imgur.com/AlHTAdDm.jpg\",\nalt: \"The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.\",\n},\n{\nname: \"Terracotta Army\",\nartist: \"Unknown Artist\",\ndescription:\n\"The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.\",\nurl: \"https://i.imgur.com/HMFmH6m.jpg\",\nalt: \"12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.\",\n},\n{\nname: \"Lunar Landscape\",\nartist: \"Louise Nevelson\",\ndescription:\n\"Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism\u2019s geometric abstraction of space and form.\",\nurl: \"https://i.imgur.com/rN7hY6om.jpg\",\nalt: \"A black matte sculpture where the individual elements are initially indistinguishable.\",\n},\n{\nname: \"Aureole\",\nartist: \"Ranjani Shettar\",\ndescription:\n'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',\nurl: \"https://i.imgur.com/okTpbHhm.jpg\",\nalt: \"A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.\",\n},\n{\nname: \"Hippos\",\nartist: \"Taipei Zoo\",\ndescription:\n\"The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.\",\nurl: \"https://i.imgur.com/6o5Vuyu.jpg\",\nalt: \"A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.\",\n},\n];\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 10px;\n}\n.Page &gt; * {\nfloat: left;\nwidth: 50%;\npadding: 10px;\n}\nh2 {\nmargin-top: 10px;\nmargin-bottom: 0;\n}\nh3 {\nmargin-top: 5px;\nfont-weight: normal;\nfont-size: 100%;\n}\nimg {\nwidth: 120px;\nheight: 120px;\n}\n</code></pre> <p>Notice how <code>hasPrev</code> and <code>hasNext</code> are used both for the returned JSX and inside the event handlers! This handy pattern works because event handler functions \"close over\" any variables declared while rendering.</p> <p></p>"},{"location":"learn/state-a-components-memory/#fix-stuck-form-inputs","title":"Fix stuck form inputs","text":"<p>When you type into the input fields, nothing appears. It's like the input values are \"stuck\" with empty strings. The <code>value</code> of the first <code>&lt;input&gt;</code> is set to always match the <code>firstName</code> variable, and the <code>value</code> for the second <code>&lt;input&gt;</code> is set to always match the <code>lastName</code> variable. This is correct. Both inputs have <code>onChange</code> event handlers, which try to update the variables based on the latest user input (<code>e.target.value</code>). However, the variables don't seem to \"remember\" their values between re-renders. Fix this by using state variables instead.</p> <pre><code>export default function Form() {\nlet firstName = \"\";\nlet lastName = \"\";\n\nfunction handleFirstNameChange(e) {\nfirstName = e.target.value;\n}\n\nfunction handleLastNameChange(e) {\nlastName = e.target.value;\n}\n\nfunction handleReset() {\nfirstName = \"\";\nlastName = \"\";\n}\n\nreturn (\n&lt;form onSubmit={(e) =&gt; e.preventDefault()}&gt;\n&lt;input\nplaceholder=\"First name\"\nvalue={firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;input\nplaceholder=\"Last name\"\nvalue={lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;h1&gt;\nHi, {firstName} {lastName}\n&lt;/h1&gt;\n&lt;button on_click={handleReset}&gt;Reset&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nmargin-top: 10px;\n}\n</code></pre> <p> <p>First, import <code>useState</code> from React. Then replace <code>firstName</code> and <code>lastName</code> with state variables declared by calling <code>useState</code>. Finally, replace every <code>firstName = ...</code> assignment with <code>setFirstName(...)</code>, and do the same for <code>lastName</code>. Don't forget to update <code>handleReset</code> too so that the reset button works.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\n\nfunction handleFirstNameChange(e) {\nsetFirstName(e.target.value);\n}\n\nfunction handleLastNameChange(e) {\nsetLastName(e.target.value);\n}\n\nfunction handleReset() {\nsetFirstName(\"\");\nsetLastName(\"\");\n}\n\nreturn (\n&lt;form onSubmit={(e) =&gt; e.preventDefault()}&gt;\n&lt;input\nplaceholder=\"First name\"\nvalue={firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;input\nplaceholder=\"Last name\"\nvalue={lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;h1&gt;\nHi, {firstName} {lastName}\n&lt;/h1&gt;\n&lt;button on_click={handleReset}&gt;Reset&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nmargin-top: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/state-a-components-memory/#fix-a-crash","title":"Fix a crash","text":"<p>Here is a small form that is supposed to let the user leave some feedback. When the feedback is submitted, it's supposed to display a thank-you message. However, it crashes with an error message saying \"Rendered fewer hooks than expected\". Can you spot the mistake and fix it?</p> <p> <p>Are there any limitations on where Hooks may be called? Does this component break any rules? Check if there are any comments disabling the linter checks--this is where the bugs often hide!</p> <p></p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [isSent, setIsSent] = useState(false);\nif (isSent) {\nreturn &lt;h1&gt;Thank you!&lt;/h1&gt;;\n} else {\n// eslint-disable-next-line\nconst [message, setMessage] = useState(\"\");\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nalert(`Sending: \"${message}\"`);\nsetIsSent(true);\n}}\n&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n}\n</code></pre> <p> <p>Hooks can only be called at the top level of the component function. Here, the first <code>isSent</code> definition follows this rule, but the <code>message</code> definition is nested in a condition.</p> <p>Move it out of the condition to fix the issue:</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [isSent, setIsSent] = useState(false);\nconst [message, setMessage] = useState(\"\");\n\nif (isSent) {\nreturn &lt;h1&gt;Thank you!&lt;/h1&gt;;\n} else {\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nalert(`Sending: \"${message}\"`);\nsetIsSent(true);\n}}\n&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n}\n</code></pre> <p>Remember, Hooks must be called unconditionally and always in the same order!</p> <p>You could also remove the unnecessary <code>else</code> branch to reduce the nesting. However, it's still important that all calls to Hooks happen before the first <code>return</code>.</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [isSent, setIsSent] = useState(false);\nconst [message, setMessage] = useState(\"\");\n\nif (isSent) {\nreturn &lt;h1&gt;Thank you!&lt;/h1&gt;;\n}\n\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nalert(`Sending: \"${message}\"`);\nsetIsSent(true);\n}}\n&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;br /&gt;\n&lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <p>Try moving the second <code>useState</code> call after the <code>if</code> condition and notice how this breaks it again.</p> <p>If your linter is configured for React, you should see a lint error when you make a mistake like this. If you don't see an error when you try the faulty code locally, you need to set up linting for your project.</p> <p></p>"},{"location":"learn/state-a-components-memory/#remove-unnecessary-state","title":"Remove unnecessary state","text":"<p>When the button is clicked, this example should ask for the user's name and then display an alert greeting them. You tried to use state to keep the name, but for some reason it always shows \"Hello, !\".</p> <p>To fix this code, remove the unnecessary state variable. (We will discuss about why this didn't work later.)</p> <p>Can you explain why this state variable was unnecessary?</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nconst [name, setName] = useState(\"\");\n\nfunction handleClick() {\nsetName(prompt(\"What is your name?\"));\nalert(`Hello, ${name}!`);\n}\n\nreturn &lt;button on_click={handleClick}&gt;Greet&lt;/button&gt;;\n}\n</code></pre> <p> <p>Here is a fixed version that uses a regular <code>name</code> variable declared in the function that needs it:</p> <pre><code>import { useState } from \"react\";\n\nexport default function FeedbackForm() {\nfunction handleClick() {\nconst name = prompt(\"What is your name?\");\nalert(`Hello, ${name}!`);\n}\n\nreturn &lt;button on_click={handleClick}&gt;Greet&lt;/button&gt;;\n}\n</code></pre> <p>A state variable is only necessary to keep information between re-renders of a component. Within a single event handler, a regular variable will do fine. Don't introduce state variables when a regular variable works well.</p> <p></p> <p></p>"},{"location":"learn/state-as-a-snapshot/","title":"State as a Snapshot \ud83d\udea7","text":""},{"location":"learn/state-as-a-snapshot/#overview","title":"Overview","text":"<p>  State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.  </p> <p>You will learn</p> <ul> <li>How setting state triggers re-renders</li> <li>When and how state updates</li> <li>Why state does not update immediately after you set it</li> <li>How event handlers access a \"snapshot\" of the state</li> </ul>"},{"location":"learn/state-as-a-snapshot/#setting-state-triggers-renders","title":"Setting state triggers renders","text":"<p>You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.</p> <p>In this example, when you press \"send\", <code>setIsSent(true)</code> tells React to re-render the UI:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [isSent, setIsSent] = useState(false);\nconst [message, setMessage] = useState(\"Hi!\");\nif (isSent) {\nreturn &lt;h1&gt;Your message is on its way!&lt;/h1&gt;;\n}\nreturn (\n&lt;form\nonSubmit={(e) =&gt; {\ne.preventDefault();\nsetIsSent(true);\nsendMessage(message);\n}}\n&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n\nfunction sendMessage(message) {\n// ...\n}\n</code></pre> <pre><code>label,\ntextarea {\nmargin-bottom: 10px;\ndisplay: block;\n}\n</code></pre> <p>Here's what happens when you click the button:</p> <ol> <li>The <code>onSubmit</code> event handler executes.</li> <li><code>setIsSent(true)</code> sets <code>isSent</code> to <code>true</code> and queues a new render.</li> <li>React re-renders the component according to the new <code>isSent</code> value.</li> </ol> <p>Let's take a closer look at the relationship between state and rendering.</p>"},{"location":"learn/state-as-a-snapshot/#rendering-takes-a-snapshot-in-time","title":"Rendering takes a snapshot in time","text":"<p>\"Rendering\" means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.</p> <p>Unlike a photograph or a movie frame, the UI \"snapshot\" you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.</p> <p>When React re-renders a component:</p> <ol> <li>React calls your function again.</li> <li>Your function returns a new JSX snapshot.</li> <li>React then updates the screen to match the snapshot you've returned.</li> </ol> <p> </p> <p>As a component's memory, state is not like a regular variable that disappears after your function returns. State actually \"lives\" in React itself--as if on a shelf!--outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</p> <p> </p> <p>Here's a little experiment to show you how this works. In this example, you might expect that clicking the \"+3\" button would increment the counter three times because it calls <code>setNumber(number + 1)</code> three times.</p> <p>See what happens when you click the \"+3\" button:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 1);\nsetNumber(number + 1);\nsetNumber(number + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>Notice that <code>number</code> only increments once per click!</p> <p>Setting state only changes it for the next render. During the first render, <code>number</code> was <code>0</code>. This is why, in that render's <code>on_click</code> handler, the value of <code>number</code> is still <code>0</code> even after <code>setNumber(number + 1)</code> was called:</p> <pre><code>&lt;button\non_click={() =&gt; {\nsetNumber(number + 1);\nsetNumber(number + 1);\nsetNumber(number + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n</code></pre> <p>Here is what this button's click handler tells React to do:</p> <ol> <li><code>setNumber(number + 1)</code>: <code>number</code> is <code>0</code> so <code>setNumber(0 + 1)</code>.<ul> <li>React prepares to change <code>number</code> to <code>1</code> on the next render.</li> </ul> </li> <li><code>setNumber(number + 1)</code>: <code>number</code> is <code>0</code> so <code>setNumber(0 + 1)</code>.<ul> <li>React prepares to change <code>number</code> to <code>1</code> on the next render.</li> </ul> </li> <li><code>setNumber(number + 1)</code>: <code>number</code> is <code>0</code> so <code>setNumber(0 + 1)</code>.<ul> <li>React prepares to change <code>number</code> to <code>1</code> on the next render.</li> </ul> </li> </ol> <p>Even though you called <code>setNumber(number + 1)</code> three times, in this render's event handler <code>number</code> is always <code>0</code>, so you set the state to <code>1</code> three times. This is why, after your event handler finishes, React re-renders the component with <code>number</code> equal to <code>1</code> rather than <code>3</code>.</p> <p>You can also visualize this by mentally substituting state variables with their values in your code. Since the <code>number</code> state variable is <code>0</code> for this render, its event handler looks like this:</p> <pre><code>&lt;button\non_click={() =&gt; {\nsetNumber(0 + 1);\nsetNumber(0 + 1);\nsetNumber(0 + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n</code></pre> <p>For the next render, <code>number</code> is <code>1</code>, so that render's click handler looks like this:</p> <pre><code>&lt;button\non_click={() =&gt; {\nsetNumber(1 + 1);\nsetNumber(1 + 1);\nsetNumber(1 + 1);\n}}\n&gt;\n+3\n&lt;/button&gt;\n</code></pre> <p>This is why clicking the button again will set the counter to <code>2</code>, then to <code>3</code> on the next click, and so on.</p>"},{"location":"learn/state-as-a-snapshot/#state-over-time","title":"State over time","text":"<p>Well, that was fun. Try to guess what clicking this button will alert:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 5);\nalert(number);\n}}\n&gt;\n+5\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>If you use the substitution method from before, you can guess that the alert shows \"0\":</p> <pre><code>setNumber(0 + 5);\nalert(0);\n</code></pre> <p>But what if you put a timer on the alert, so it only fires after the component re-rendered? Would it say \"0\" or \"5\"? Have a guess!</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [number, setNumber] = useState(0);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;{number}&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetNumber(number + 5);\nsetTimeout(() =&gt; {\nalert(number);\n}, 3000);\n}}\n&gt;\n+5\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: inline-block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: inline-block;\nmargin: 10px;\nwidth: 30px;\ntext-align: center;\n}\n</code></pre> <p>Surprised? If you use the substitution method, you can see the \"snapshot\" of the state passed to the alert.</p> <pre><code>setNumber(0 + 5);\nsetTimeout(() =&gt; {\nalert(0);\n}, 3000);\n</code></pre> <p>The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!</p> <p>A state variable's value never changes within a render, even if its event handler's code is asynchronous. Inside that render's <code>on_click</code>, the value of <code>number</code> continues to be <code>0</code> even after <code>setNumber(number + 5)</code> was called. Its value was \"fixed\" when React \"took the snapshot\" of the UI by calling your component.</p> <p>Here is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:</p> <ol> <li>You press the \"Send\" button, sending \"Hello\" to Alice.</li> <li>Before the five-second delay ends, you change the value of the \"To\" field to \"Bob\".</li> </ol> <p>What do you expect the <code>alert</code> to display? Would it display, \"You said Hello to Alice\"? Or would it display, \"You said Hello to Bob\"? Make a guess based on what you know, and then try it:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [to, setTo] = useState(\"Alice\");\nconst [message, setMessage] = useState(\"Hello\");\n\nfunction handleSubmit(e) {\ne.preventDefault();\nsetTimeout(() =&gt; {\nalert(`You said ${message} to ${to}`);\n}, 5000);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;label&gt;\nTo:{\" \"}\n&lt;select value={to} onChange={(e) =&gt; setTo(e.target.value)}&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n</code></pre> <pre><code>label,\ntextarea {\nmargin-bottom: 10px;\ndisplay: block;\n}\n</code></pre> <p>React keeps the state values \"fixed\" within one render's event handlers. You don't need to worry whether the state has changed while the code is running.</p> <p>But what if you wanted to read the latest state before a re-render? You'll want to use a state updater function, covered on the next page!</p> <p> <ul> <li>Setting state requests a new render.</li> <li>React stores state outside of your component, as if on a shelf.</li> <li>When you call <code>useState</code>, React gives you a snapshot of the state for that render.</li> <li>Variables and event handlers don't \"survive\" re-renders. Every render has its own event handlers.</li> <li>Every render (and functions inside it) will always \"see\" the snapshot of the state that React gave to that render.</li> <li>You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.</li> <li>Event handlers created in the past have the state values from the render in which they were created.</li> </ul> <p></p> <p>"},{"location":"learn/state-as-a-snapshot/#implement-a-traffic-light","title":"Implement a traffic light","text":"<p>Here is a crosswalk light component that toggles when the button is pressed:</p> <pre><code>import { useState } from \"react\";\n\nexport default function TrafficLight() {\nconst [walk, setWalk] = useState(true);\n\nfunction handleClick() {\nsetWalk(!walk);\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;\nChange to {walk ? \"Stop\" : \"Walk\"}\n&lt;/button&gt;\n&lt;h1\nstyle={{\ncolor: walk ? \"darkgreen\" : \"darkred\",\n}}\n&gt;\n{walk ? \"Walk\" : \"Stop\"}\n&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nmargin-top: 20px;\n}\n</code></pre> <p>Add an <code>alert</code> to the click handler. When the light is green and says \"Walk\", clicking the button should say \"Stop is next\". When the light is red and says \"Stop\", clicking the button should say \"Walk is next\".</p> <p>Does it make a difference whether you put the <code>alert</code> before or after the <code>setWalk</code> call?</p> <p> <p>Your <code>alert</code> should look like this:</p> <pre><code>import { useState } from \"react\";\n\nexport default function TrafficLight() {\nconst [walk, setWalk] = useState(true);\n\nfunction handleClick() {\nsetWalk(!walk);\nalert(walk ? \"Stop is next\" : \"Walk is next\");\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;\nChange to {walk ? \"Stop\" : \"Walk\"}\n&lt;/button&gt;\n&lt;h1\nstyle={{\ncolor: walk ? \"darkgreen\" : \"darkred\",\n}}\n&gt;\n{walk ? \"Walk\" : \"Stop\"}\n&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>h1 {\nmargin-top: 20px;\n}\n</code></pre> <p>Whether you put it before or after the <code>setWalk</code> call makes no difference. That render's value of <code>walk</code> is fixed. Calling <code>setWalk</code> will only change it for the next render, but will not affect the event handler from the previous render.</p> <p>This line might seem counter-intuitive at first:</p> <pre><code>alert(walk ? \"Stop is next\" : \"Walk is next\");\n</code></pre> <p>But it makes sense if you read it as: \"If the traffic light shows 'Walk now', the message should say 'Stop is next.'\" The <code>walk</code> variable inside your event handler matches that render's value of <code>walk</code> and does not change.</p> <p>You can verify that this is correct by applying the substitution method. When <code>walk</code> is <code>true</code>, you get:</p> <pre><code>&lt;button on_click={() =&gt; {\nsetWalk(false);\nalert('Stop is next');\n}}&gt;\nChange to Stop\n&lt;/button&gt;\n&lt;h1 style={{color: 'darkgreen'}}&gt;\nWalk\n&lt;/h1&gt;\n</code></pre> <p>So clicking \"Change to Stop\" queues a render with <code>walk</code> set to <code>false</code>, and alerts \"Stop is next\".</p> <p></p> <p></p>"},{"location":"learn/synchronizing-with-effects/","title":"Synchronizing with Effects \ud83d\udea7","text":""},{"location":"learn/synchronizing-with-effects/#overview","title":"Overview","text":"<p>  Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Effects let you run some code after rendering so that you can synchronize your component with some system outside of React.  </p> <p>You will learn</p> <ul> <li>What Effects are</li> <li>How Effects are different from events</li> <li>How to declare an Effect in your component</li> <li>How to skip re-running an Effect unnecessarily</li> <li>Why Effects run twice in development and how to fix them</li> </ul>"},{"location":"learn/synchronizing-with-effects/#what-are-effects-and-how-are-they-different-from-events","title":"What are Effects and how are they different from events?","text":"<p>Before getting to Effects, you need to be familiar with two types of logic inside React components:</p> <ul> <li> <p>Rendering code (introduced in Describing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen. Rendering code must be pure. Like a math formula, it should only calculate the result, but not do anything else.</p> </li> <li> <p>Event handlers (introduced in Adding Interactivity) are nested functions inside your components that do things rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain \"side effects\" (they change the program's state) caused by a specific user action (for example, a button click or typing).</p> </li> </ul> <p>Sometimes this isn't enough. Consider a <code>ChatRoom</code> component that must connect to the chat server whenever it's visible on the screen. Connecting to a server is not a pure calculation (it's a side effect) so it can't happen during rendering. However, there is no single particular event like a click that causes <code>ChatRoom</code> to be displayed.</p> <p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event. Sending a message in the chat is an event because it is directly caused by the user clicking a specific button. However, setting up a server connection is an Effect because it should happen no matter which interaction caused the component to appear. Effects run at the end of a commit after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).</p> <p> <p>Here and later in this text, capitalized \"Effect\" refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we'll say \"side effect\".</p> <p></p>"},{"location":"learn/synchronizing-with-effects/#you-might-not-need-an-effect","title":"You might not need an Effect","text":"<p>Don't rush to add Effects to your components. Keep in mind that Effects are typically used to \"step out\" of your React code and synchronize with some external system. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state, you might not need an Effect.</p>"},{"location":"learn/synchronizing-with-effects/#how-to-write-an-effect","title":"How to write an Effect","text":"<p>To write an Effect, follow these three steps:</p> <ol> <li>Declare an Effect. By default, your Effect will run after every render.</li> <li>Specify the Effect dependencies. Most Effects should only re-run when needed rather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifying dependencies.</li> <li>Add cleanup if needed. Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, \"connect\" needs \"disconnect\", \"subscribe\" needs \"unsubscribe\", and \"fetch\" needs either \"cancel\" or \"ignore\". You will learn how to do this by returning a cleanup function.</li> </ol> <p>Let's look at each of these steps in detail.</p>"},{"location":"learn/synchronizing-with-effects/#step-1-declare-an-effect","title":"Step 1: Declare an Effect","text":"<p>To declare an Effect in your component, import the <code>useEffect</code> Hook from React:</p> <pre><code>import { useEffect } from \"react\";\n</code></pre> <p>Then, call it at the top level of your component and put some code inside your Effect:</p> <pre><code>function MyComponent() {\nuseEffect(() =&gt; {\n// Code here will run after *every* render\n});\nreturn &lt;div /&gt;;\n}\n</code></pre> <p>Every time your component renders, React will update the screen and then run the code inside <code>useEffect</code>. In other words, <code>useEffect</code> \"delays\" a piece of code from running until that render is reflected on the screen.</p> <p>Let's see how you can use an Effect to synchronize with an external system. Consider a <code>&lt;VideoPlayer&gt;</code> React component. It would be nice to control whether it's playing or paused by passing an <code>isPlaying</code> prop to it:</p> <pre><code>&lt;VideoPlayer isPlaying={isPlaying} /&gt;\n</code></pre> <p>Your custom <code>VideoPlayer</code> component renders the built-in browser <code>&lt;video&gt;</code> tag:</p> <pre><code>function VideoPlayer({ src, isPlaying }) {\n// TODO: do something with isPlaying\nreturn &lt;video src={src} /&gt;;\n}\n</code></pre> <p>However, the browser <code>&lt;video&gt;</code> tag does not have an <code>isPlaying</code> prop. The only way to control it is to manually call the <code>play()</code> and <code>pause()</code> methods on the DOM element. You need to synchronize the value of <code>isPlaying</code> prop, which tells whether the video should currently be playing, with calls like <code>play()</code> and <code>pause()</code>.</p> <p>We'll need to first get a ref to the <code>&lt;video&gt;</code> DOM node.</p> <p>You might be tempted to try to call <code>play()</code> or <code>pause()</code> during rendering, but that isn't correct:</p> <pre><code>import { useState, useRef, useEffect } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nif (isPlaying) {\nref.current.play(); // Calling these while rendering isn't allowed.\n} else {\nref.current.pause(); // Also, this crashes.\n}\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n\nexport default function App() {\nconst [isPlaying, setIsPlaying] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setIsPlaying(!isPlaying)}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;VideoPlayer\nisPlaying={isPlaying}\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\nvideo {\nwidth: 250px;\n}\n</code></pre> <p>The reason this code isn't correct is that it tries to do something with the DOM node during rendering. In React, rendering should be a pure calculation of JSX and should not contain side effects like modifying the DOM.</p> <p>Moreover, when <code>VideoPlayer</code> is called for the first time, its DOM does not exist yet! There isn't a DOM node yet to call <code>play()</code> or <code>pause()</code> on, because React doesn't know what DOM to create until you return the JSX.</p> <p>The solution here is to wrap the side effect with <code>useEffect</code> to move it out of the rendering calculation:</p> <pre><code>import { useEffect, useRef } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (isPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n});\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n</code></pre> <p>By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.</p> <p>When your <code>VideoPlayer</code> component renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the <code>&lt;video&gt;</code> tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will call <code>play()</code> or <code>pause()</code> depending on the value of <code>isPlaying</code>.</p> <p>Press Play/Pause multiple times and see how the video player stays synchronized to the <code>isPlaying</code> value:</p> <pre><code>import { useState, useRef, useEffect } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (isPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n});\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n\nexport default function App() {\nconst [isPlaying, setIsPlaying] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setIsPlaying(!isPlaying)}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;VideoPlayer\nisPlaying={isPlaying}\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\nvideo {\nwidth: 250px;\n}\n</code></pre> <p>In this example, the \"external system\" you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.</p> <p>Note that controlling a video player is much more complex in practice. Calling <code>play()</code> may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.</p> <p> <p>By default, Effects run after every render. This is why code like this will produce an infinite loop:</p> <pre><code>const [count, setCount] = useState(0);\nuseEffect(() =&gt; {\nsetCount(count + 1);\n});\n</code></pre> <p>Effects run as a result of rendering. Setting state triggers rendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.</p> <p>Effects should usually synchronize your components with an external system. If there's no external system and you only want to adjust some state based on other state, you might not need an Effect.</p> <p></p>"},{"location":"learn/synchronizing-with-effects/#step-2-specify-the-effect-dependencies","title":"Step 2: Specify the Effect dependencies","text":"<p>By default, Effects run after every render. Often, this is not what you want:</p> <ul> <li>Sometimes, it's slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it's necessary. For example, you don't want to reconnect to the chat server on every keystroke.</li> <li>Sometimes, it's wrong. For example, you don't want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time.</li> </ul> <p>To demonstrate the issue, here is the previous example with a few <code>console.log</code> calls and a text input that updates the parent component's state. Notice how typing causes the Effect to re-run:</p> <pre><code>import { useState, useRef, useEffect } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (isPlaying) {\nconsole.log(\"Calling video.play()\");\nref.current.play();\n} else {\nconsole.log(\"Calling video.pause()\");\nref.current.pause();\n}\n});\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n\nexport default function App() {\nconst [isPlaying, setIsPlaying] = useState(false);\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={() =&gt; setIsPlaying(!isPlaying)}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;VideoPlayer\nisPlaying={isPlaying}\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>input,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nvideo {\nwidth: 250px;\n}\n</code></pre> <p>You can tell React to skip unnecessarily re-running the Effect by specifying an array of dependencies as the second argument to the <code>useEffect</code> call. Start by adding an empty <code>[]</code> array to the above example on line 14:</p> <pre><code>useEffect(() =&gt; {\n// ...\n}, []);\n</code></pre> <p>You should see an error saying <code>React Hook useEffect has a missing dependency: 'isPlaying'</code>:</p> <pre><code>import { useState, useRef, useEffect } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (isPlaying) {\nconsole.log(\"Calling video.play()\");\nref.current.play();\n} else {\nconsole.log(\"Calling video.pause()\");\nref.current.pause();\n}\n}, []); // This causes an error\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n\nexport default function App() {\nconst [isPlaying, setIsPlaying] = useState(false);\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={() =&gt; setIsPlaying(!isPlaying)}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;VideoPlayer\nisPlaying={isPlaying}\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>input,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nvideo {\nwidth: 250px;\n}\n</code></pre> <p>The problem is that the code inside of your Effect depends on the <code>isPlaying</code> prop to decide what to do, but this dependency was not explicitly declared. To fix this issue, add <code>isPlaying</code> to the dependency array:</p> <pre><code>useEffect(() =&gt; {\nif (isPlaying) {\n// It's used here...\n// ...\n} else {\n// ...\n}\n}, [isPlaying]); // ...so it must be declared here!\n</code></pre> <p>Now all dependencies are declared, so there is no error. Specifying <code>[isPlaying]</code> as the dependency array tells React that it should skip re-running your Effect if <code>isPlaying</code> is the same as it was during the previous render. With this change, typing into the input doesn't cause the Effect to re-run, but pressing Play/Pause does:</p> <pre><code>import { useState, useRef, useEffect } from \"react\";\n\nfunction VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (isPlaying) {\nconsole.log(\"Calling video.play()\");\nref.current.play();\n} else {\nconsole.log(\"Calling video.pause()\");\nref.current.pause();\n}\n}, [isPlaying]);\n\nreturn &lt;video ref={ref} src={src} loop playsInline /&gt;;\n}\n\nexport default function App() {\nconst [isPlaying, setIsPlaying] = useState(false);\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={() =&gt; setIsPlaying(!isPlaying)}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;VideoPlayer\nisPlaying={isPlaying}\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>input,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nvideo {\nwidth: 250px;\n}\n</code></pre> <p>The dependency array can contain multiple dependencies. React will only skip re-running the Effect if all of the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using the <code>Object.is</code> comparison. See the <code>useEffect</code> reference for details.</p> <p>Notice that you can't \"choose\" your dependencies. You will get a lint error if the dependencies you specified don't match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don't want some code to re-run, edit the Effect code itself to not \"need\" that dependency.</p> <p> <p>The behaviors without the dependency array and with an empty <code>[]</code> dependency array are different:</p> <pre><code>useEffect(() =&gt; {\n// This runs after every render\n});\n\nuseEffect(() =&gt; {\n// This runs only on mount (when the component appears)\n}, []);\n\nuseEffect(() =&gt; {\n// This runs on mount *and also* if either a or b have changed since the last render\n}, [a, b]);\n</code></pre> <p>We'll take a close look at what \"mount\" means in the next step.</p> <p></p> <p>"},{"location":"learn/synchronizing-with-effects/#why-was-the-ref-omitted-from-the-dependency-array","title":"Why was the ref omitted from the dependency array?","text":"<p>This Effect uses both <code>ref</code> and <code>isPlaying</code>, but only <code>isPlaying</code> is declared as a dependency:</p> <pre><code>function VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\nuseEffect(() =&gt; {\nif (isPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n}, [isPlaying]);\n</code></pre> <p>This is because the <code>ref</code> object has a stable identity: React guarantees you'll always get the same object from the same <code>useRef</code> call on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:</p> <pre><code>function VideoPlayer({ src, isPlaying }) {\nconst ref = useRef(null);\nuseEffect(() =&gt; {\nif (isPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n}, [isPlaying, ref]);\n</code></pre> <p>The <code>set</code> functions returned by <code>useState</code> also have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.</p> <p>Omitting always-stable dependencies only works when the linter can \"see\" that the object is stable. For example, if <code>ref</code> was passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can't know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effect would depend on which ref is passed.</p> <p></p>"},{"location":"learn/synchronizing-with-effects/#step-3-add-cleanup-if-needed","title":"Step 3: Add cleanup if needed","text":"<p>Consider a different example. You're writing a <code>ChatRoom</code> component that needs to connect to the chat server when it appears. You are given a <code>createConnection()</code> API that returns an object with <code>connect()</code> and <code>disconnect()</code> methods. How do you keep the component connected while it is displayed to the user?</p> <p>Start by writing the Effect logic:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\n});\n</code></pre> <p>It would be slow to connect to the chat after every re-render, so you add the dependency array:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\n}, []);\n</code></pre> <p>The code inside the Effect does not use any props or state, so your dependency array is <code>[]</code> (empty). This tells React to only run this code when the component \"mounts\", i.e. appears on the screen for the first time.</p> <p>Let's try running this code:</p> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport default function ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\n}, []);\nreturn &lt;h1&gt;Welcome to the chat!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection() {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\"\u2705 Connecting...\");\n},\ndisconnect() {\nconsole.log(\"\u274c Disconnected.\");\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p>This Effect only runs on mount, so you might expect <code>\"\u2705 Connecting...\"</code> to be printed once in the console. However, if you check the console, <code>\"\u2705 Connecting...\"</code> gets printed twice. Why does it happen?</p> <p>Imagine the <code>ChatRoom</code> component is a part of a larger app with many different screens. The user starts their journey on the <code>ChatRoom</code> page. The component mounts and calls <code>connection.connect()</code>. Then imagine the user navigates to another screen--for example, to the Settings page. The <code>ChatRoom</code> component unmounts. Finally, the user clicks Back and <code>ChatRoom</code> mounts again. This would set up a second connection--but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.</p> <p>Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.</p> <p>Seeing the <code>\"\u2705 Connecting...\"</code> log twice helps you notice the real issue: your code doesn't close the connection when the component unmounts.</p> <p>To fix the issue, return a cleanup function from your Effect:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, []);\n</code></pre> <p>React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let's see what happens when the cleanup function is implemented:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport default function ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []);\nreturn &lt;h1&gt;Welcome to the chat!&lt;/h1&gt;;\n}\n</code></pre> <pre><code>export function createConnection() {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\"\u2705 Connecting...\");\n},\ndisconnect() {\nconsole.log(\"\u274c Disconnected.\");\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre> <p>Now you get three console logs in development:</p> <ol> <li><code>\"\u2705 Connecting...\"</code></li> <li><code>\"\u274c Disconnected.\"</code></li> <li><code>\"\u2705 Connecting...\"</code></li> </ol> <p>This is the correct behavior in development. By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There's an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal--don't try to make it go away!</p> <p>In production, you would only see <code>\"\u2705 Connecting...\"</code> printed once. Remounting components only happens in development to help you find Effects that need cleanup. You can turn off Strict Mode to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.</p>"},{"location":"learn/synchronizing-with-effects/#how-to-handle-the-effect-firing-twice-in-development","title":"How to handle the Effect firing twice in development?","text":"<p>React intentionally remounts your components in development to find bugs like in the last example. The right question isn't \"how to run an Effect once\", but \"how to fix my Effect so that it works after remounting\".</p> <p>Usually, the answer is to implement the cleanup function. The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn't be able to distinguish between the Effect running once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as you'd see in development).</p> <p>Most of the Effects you'll write will fit into one of the common patterns below.</p>"},{"location":"learn/synchronizing-with-effects/#controlling-non-react-widgets","title":"Controlling non-React widgets","text":"<p>Sometimes you need to add UI widgets that aren't written to React. For example, let's say you're adding a map component to your page. It has a <code>setZoomLevel()</code> method, and you'd like to keep the zoom level in sync with a <code>zoomLevel</code> state variable in your React code. Your Effect would look similar to this:</p> <pre><code>useEffect(() =&gt; {\nconst map = mapRef.current;\nmap.setZoomLevel(zoomLevel);\n}, [zoomLevel]);\n</code></pre> <p>Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling <code>setZoomLevel</code> twice with the same value does not do anything. It may be slightly slower, but this doesn't matter because it won't remount needlessly in production.</p> <p>Some APIs may not allow you to call them twice in a row. For example, the <code>showModal</code> method of the built-in <code>&lt;dialog&gt;</code> element throws if you call it twice. Implement the cleanup function and make it close the dialog:</p> <pre><code>useEffect(() =&gt; {\nconst dialog = dialogRef.current;\ndialog.showModal();\nreturn () =&gt; dialog.close();\n}, []);\n</code></pre> <p>In development, your Effect will call <code>showModal()</code>, then immediately <code>close()</code>, and then <code>showModal()</code> again. This has the same user-visible behavior as calling <code>showModal()</code> once, as you would see in production.</p>"},{"location":"learn/synchronizing-with-effects/#subscribing-to-events","title":"Subscribing to events","text":"<p>If your Effect subscribes to something, the cleanup function should unsubscribe:</p> <pre><code>useEffect(() =&gt; {\nfunction handleScroll(e) {\nconsole.log(window.scrollX, window.scrollY);\n}\nwindow.addEventListener(\"scroll\", handleScroll);\nreturn () =&gt; window.removeEventListener(\"scroll\", handleScroll);\n}, []);\n</code></pre> <p>In development, your Effect will call <code>addEventListener()</code>, then immediately <code>removeEventListener()</code>, and then <code>addEventListener()</code> again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling <code>addEventListener()</code> once, as in production.</p>"},{"location":"learn/synchronizing-with-effects/#triggering-animations","title":"Triggering animations","text":"<p>If your Effect animates something in, the cleanup function should reset the animation to the initial values:</p> <pre><code>useEffect(() =&gt; {\nconst node = ref.current;\nnode.style.opacity = 1; // Trigger the animation\nreturn () =&gt; {\nnode.style.opacity = 0; // Reset to the initial value\n};\n}, []);\n</code></pre> <p>In development, opacity will be set to <code>1</code>, then to <code>0</code>, and then to <code>1</code> again. This should have the same user-visible behavior as setting it to <code>1</code> directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.</p>"},{"location":"learn/synchronizing-with-effects/#fetching-data","title":"Fetching data","text":"<p>If your Effect fetches something, the cleanup function should either abort the fetch or ignore its result:</p> <pre><code>useEffect(() =&gt; {\nlet ignore = false;\n\nasync function startFetching() {\nconst json = await fetchTodos(userId);\nif (!ignore) {\nsetTodos(json);\n}\n}\n\nstartFetching();\n\nreturn () =&gt; {\nignore = true;\n};\n}, [userId]);\n</code></pre> <p>You can't \"undo\" a network request that already happened, but your cleanup function should ensure that the fetch that's not relevant anymore does not keep affecting your application. If the <code>userId</code> changes from <code>'Alice'</code> to <code>'Bob'</code>, cleanup ensures that the <code>'Alice'</code> response is ignored even if it arrives after <code>'Bob'</code>.</p> <p>In development, you will see two fetches in the Network tab. There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the <code>ignore</code> variable will be set to <code>true</code>. So even though there is an extra request, it won't affect the state thanks to the <code>if (!ignore)</code> check.</p> <p>In production, there will only be one request. If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:</p> <pre><code>function TodoList() {\nconst todos = useSomeDataLibrary(`/api/user/${userId}/todos`);\n// ...\n</code></pre> <p>This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won't have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.</p> <p>"},{"location":"learn/synchronizing-with-effects/#what-are-good-alternatives-to-data-fetching-in-effects","title":"What are good alternatives to data fetching in Effects?","text":"<p>Writing <code>fetch</code> calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:</p> <ul> <li>Effects don't run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.</li> <li>Fetching directly in Effects makes it easy to create \"network waterfalls\". You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.</li> <li>Fetching directly in Effects usually means you don't preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.</li> <li>It's not very ergonomic. There's quite a bit of boilerplate code involved when writing <code>fetch</code> calls in a way that doesn't suffer from bugs like race conditions.</li> </ul> <p>This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:</p> <ul> <li>If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.</li> <li>Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).</li> </ul> <p>You can continue fetching data directly in Effects if neither of these approaches suit you.</p> <p></p>"},{"location":"learn/synchronizing-with-effects/#sending-analytics","title":"Sending analytics","text":"<p>Consider this code that sends an analytics event on the page visit:</p> <pre><code>useEffect(() =&gt; {\nlogVisit(url); // Sends a POST request\n}, [url]);\n</code></pre> <p>In development, <code>logVisit</code> will be called twice for every URL, so you might be tempted to try to fix that. We recommend keeping this code as is. Like with earlier examples, there is no user-visible behavior difference between running it once and running it twice. From a practical point of view, <code>logVisit</code> should not do anything in development because you don't want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.</p> <p>In production, there will be no duplicate visit logs.</p> <p>To debug the analytics events you're sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of Strict Mode and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, intersection observers can help track which components are in the viewport and how long they remain visible.</p>"},{"location":"learn/synchronizing-with-effects/#not-an-effect-initializing-the-application","title":"Not an Effect: Initializing the application","text":"<p>Some logic should only run once when the application starts. You can put it outside your components:</p> <pre><code>if (typeof window !== \"undefined\") {\n// Check if we're running in the browser.\ncheckAuthToken();\nloadDataFromLocalStorage();\n}\n\nfunction App() {\n// ...\n}\n</code></pre> <p>This guarantees that such logic only runs once after the browser loads the page.</p>"},{"location":"learn/synchronizing-with-effects/#not-an-effect-buying-a-product","title":"Not an Effect: Buying a product","text":"<p>Sometimes, even if you write a cleanup function, there's no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:</p> <pre><code>useEffect(() =&gt; {\n// \ud83d\udd34 Wrong: This Effect fires twice in development, exposing a problem in the code.\nfetch(\"/api/buy\", { method: \"POST\" });\n}, []);\n</code></pre> <p>You wouldn't want to buy the product twice. However, this is also why you shouldn't put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don't want to buy the product when the user visits a page; you want to buy it when the user clicks the Buy button.</p> <p>Buying is not caused by rendering; it's caused by a specific interaction. It should run only when the user presses the button. Delete the Effect and move your <code>/api/buy</code> request into the Buy button event handler:</p> <pre><code>function handleClick() {\n// \u2705 Buying is an event because it is caused by a particular interaction.\nfetch(\"/api/buy\", { method: \"POST\" });\n}\n</code></pre> <p>This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs. From the user's perspective, visiting a page shouldn't be different from visiting it, clicking a link, and pressing Back. React verifies that your components abide by this principle by remounting them once in development.</p>"},{"location":"learn/synchronizing-with-effects/#putting-it-all-together","title":"Putting it all together","text":"<p>This playground can help you \"get a feel\" for how Effects work in practice.</p> <p>This example uses <code>setTimeout</code> to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing \"Mount the component\":</p> <pre><code>import { useState, useEffect } from \"react\";\n\nfunction Playground() {\nconst [text, setText] = useState(\"a\");\n\nuseEffect(() =&gt; {\nfunction onTimeout() {\nconsole.log(\"\u23f0 \" + text);\n}\n\nconsole.log('\ud83d\udd35 Schedule \"' + text + '\" log');\nconst timeoutId = setTimeout(onTimeout, 3000);\n\nreturn () =&gt; {\nconsole.log('\ud83d\udfe1 Cancel \"' + text + '\" log');\nclearTimeout(timeoutId);\n};\n}, [text]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nWhat to log:{\" \"}\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;/label&gt;\n&lt;h1&gt;{text}&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow(!show)}&gt;\n{show ? \"Unmount\" : \"Mount\"} the component\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;Playground /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <p>You will see three logs at first: <code>Schedule \"a\" log</code>, <code>Cancel \"a\" log</code>, and <code>Schedule \"a\" log</code> again. Three second later there will also be a log saying <code>a</code>. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you've implemented cleanup well.</p> <p>Now edit the input to say <code>abc</code>. If you do it fast enough, you'll see <code>Schedule \"ab\" log</code> immediately followed by <code>Cancel \"ab\" log</code> and <code>Schedule \"abc\" log</code>. React always cleans up the previous render's Effect before the next render's Effect. This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.</p> <p>Type something into the input and then immediately press \"Unmount the component\". Notice how unmounting cleans up the last render's Effect. Here, it clears the last timeout before it has a chance to fire.</p> <p>Finally, edit the component above and comment out the cleanup function so that the timeouts don't get cancelled. Try typing <code>abcde</code> fast. What do you expect to happen in three seconds? Will <code>console.log(text)</code> inside the timeout print the latest <code>text</code> and produce five <code>abcde</code> logs? Give it a try to check your intuition!</p> <p>Three seconds later, you should see a sequence of logs (<code>a</code>, <code>ab</code>, <code>abc</code>, <code>abcd</code>, and <code>abcde</code>) rather than five <code>abcde</code> logs. Each Effect \"captures\" the <code>text</code> value from its corresponding render. It doesn't matter that the <code>text</code> state changed: an Effect from the render with <code>text = 'ab'</code> will always see <code>'ab'</code>. In other words, Effects from each render are isolated from each other. If you're curious how this works, you can read about closures.</p> <p>"},{"location":"learn/synchronizing-with-effects/#each-render-has-its-own-effects","title":"Each render has its own Effects","text":"<p>You can think of <code>useEffect</code> as \"attaching\" a piece of behavior to the render output. Consider this Effect:</p> <pre><code>export default function ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn &lt;h1&gt;Welcome to {roomId}!&lt;/h1&gt;;\n}\n</code></pre> <p>Let's see what exactly happens as the user navigates around the app.</p>"},{"location":"learn/synchronizing-with-effects/#initial-render","title":"Initial render","text":"<p>The user visits <code>&lt;ChatRoom roomId=\"general\" /&gt;</code>. Let's mentally substitute <code>roomId</code> with <code>'general'</code>:</p> <pre><code>// JSX for the first render (roomId = \"general\")\nreturn &lt;h1&gt;Welcome to general!&lt;/h1&gt;;\n</code></pre> <p>The Effect is also a part of the rendering output. The first render's Effect becomes:</p> <pre><code>// Effect for the first render (roomId = \"general\")\n() =&gt; {\nconst connection = createConnection(\"general\");\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n},\n// Dependencies for the first render (roomId = \"general\")\n[\"general\"];\n</code></pre> <p>React runs this Effect, which connects to the <code>'general'</code> chat room.</p>"},{"location":"learn/synchronizing-with-effects/#re-render-with-same-dependencies","title":"Re-render with same dependencies","text":"<p>Let's say <code>&lt;ChatRoom roomId=\"general\" /&gt;</code> re-renders. The JSX output is the same:</p> <pre><code>// JSX for the second render (roomId = \"general\")\nreturn &lt;h1&gt;Welcome to general!&lt;/h1&gt;;\n</code></pre> <p>React sees that the rendering output has not changed, so it doesn't update the DOM.</p> <p>The Effect from the second render looks like this:</p> <pre><code>// Effect for the second render (roomId = \"general\")\n() =&gt; {\nconst connection = createConnection(\"general\");\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n},\n// Dependencies for the second render (roomId = \"general\")\n[\"general\"];\n</code></pre> <p>React compares <code>['general']</code> from the second render with <code>['general']</code> from the first render. Because all dependencies are the same, React ignores the Effect from the second render. It never gets called.</p>"},{"location":"learn/synchronizing-with-effects/#re-render-with-different-dependencies","title":"Re-render with different dependencies","text":"<p>Then, the user visits <code>&lt;ChatRoom roomId=\"travel\" /&gt;</code>. This time, the component returns different JSX:</p> <pre><code>// JSX for the third render (roomId = \"travel\")\nreturn &lt;h1&gt;Welcome to travel!&lt;/h1&gt;;\n</code></pre> <p>React updates the DOM to change <code>\"Welcome to general\"</code> into <code>\"Welcome to travel\"</code>.</p> <p>The Effect from the third render looks like this:</p> <pre><code>// Effect for the third render (roomId = \"travel\")\n() =&gt; {\nconst connection = createConnection(\"travel\");\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n},\n// Dependencies for the third render (roomId = \"travel\")\n[\"travel\"];\n</code></pre> <p>React compares <code>['travel']</code> from the third render with <code>['general']</code> from the second render. One dependency is different: <code>Object.is('travel', 'general')</code> is <code>false</code>. The Effect can't be skipped.</p> <p>Before React can apply the Effect from the third render, it needs to clean up the last Effect that did run. The second render's Effect was skipped, so React needs to clean up the first render's Effect. If you scroll up to the first render, you'll see that its cleanup calls <code>disconnect()</code> on the connection that was created with <code>createConnection('general')</code>. This disconnects the app from the <code>'general'</code> chat room.</p> <p>After that, React runs the third render's Effect. It connects to the <code>'travel'</code> chat room.</p>"},{"location":"learn/synchronizing-with-effects/#unmount","title":"Unmount","text":"<p>Finally, let's say the user navigates away, and the <code>ChatRoom</code> component unmounts. React runs the last Effect's cleanup function. The last Effect was from the third render. The third render's cleanup destroys the <code>createConnection('travel')</code> connection. So the app disconnects from the <code>'travel'</code> room.</p>"},{"location":"learn/synchronizing-with-effects/#development-only-behaviors","title":"Development-only behaviors","text":"<p>When Strict Mode is on, React remounts every component once after mount (state and DOM are preserved). This helps you find Effects that need cleanup and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.</p> <p></p> <p> <ul> <li>Unlike events, Effects are caused by rendering itself rather than a particular interaction.</li> <li>Effects let you synchronize a component with some external system (third-party API, network, etc).</li> <li>By default, Effects run after every render (including the initial one).</li> <li>React will skip the Effect if all of its dependencies have the same values as during the last render.</li> <li>You can't \"choose\" your dependencies. They are determined by the code inside the Effect.</li> <li>Empty dependency array (<code>[]</code>) corresponds to the component \"mounting\", i.e. being added to the screen.</li> <li>In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.</li> <li>If your Effect breaks because of remounting, you need to implement a cleanup function.</li> <li>React will call your cleanup function before the Effect runs next time, and during the unmount.</li> </ul> <p></p> <p>"},{"location":"learn/synchronizing-with-effects/#focus-a-field-on-mount","title":"Focus a field on mount","text":"<p>In this example, the form renders a <code>&lt;MyInput /&gt;</code> component.</p> <p>Use the input's <code>focus()</code> method to make <code>MyInput</code> automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn't quite work. Figure out why it doesn't work, and fix it. (If you're familiar with the <code>autoFocus</code> attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)</p> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function MyInput({ value, onChange }) {\nconst ref = useRef(null);\n\n// TODO: This doesn't quite work. Fix it.\n// ref.current.focus()\n\nreturn &lt;input ref={ref} value={value} onChange={onChange} /&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport MyInput from \"./MyInput.js\";\n\nexport default function Form() {\nconst [show, setShow] = useState(false);\nconst [name, setName] = useState(\"Taylor\");\nconst [upper, setUpper] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} form\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; (\n&lt;&gt;\n&lt;label&gt;\nEnter your name:\n&lt;MyInput\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={upper}\nonChange={(e) =&gt; setUpper(e.target.checked)}\n/&gt;\nMake it uppercase\n&lt;/label&gt;\n&lt;p&gt;\nHello, &lt;b&gt;{upper ? name.toUpperCase() : name}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n)}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p>To verify that your solution works, press \"Show form\" and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press \"Hide form\" and \"Show form\" again. Verify the input is highlighted again.</p> <p><code>MyInput</code> should only focus on mount rather than after every render. To verify that the behavior is right, press \"Show form\" and then repeatedly press the \"Make it uppercase\" checkbox. Clicking the checkbox should not focus the input above it.</p> <p> <p>Calling <code>ref.current.focus()</code> during render is wrong because it is a side effect. Side effects should either be placed inside an event handler or be declared with <code>useEffect</code>. In this case, the side effect is caused by the component appearing rather than by any specific interaction, so it makes sense to put it in an Effect.</p> <p>To fix the mistake, wrap the <code>ref.current.focus()</code> call into an Effect declaration. Then, to ensure that this Effect runs only on mount rather than after every render, add the empty <code>[]</code> dependencies to it.</p> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function MyInput({ value, onChange }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nref.current.focus();\n}, []);\n\nreturn &lt;input ref={ref} value={value} onChange={onChange} /&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport MyInput from \"./MyInput.js\";\n\nexport default function Form() {\nconst [show, setShow] = useState(false);\nconst [name, setName] = useState(\"Taylor\");\nconst [upper, setUpper] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} form\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; (\n&lt;&gt;\n&lt;label&gt;\nEnter your name:\n&lt;MyInput\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={upper}\nonChange={(e) =&gt; setUpper(e.target.checked)}\n/&gt;\nMake it uppercase\n&lt;/label&gt;\n&lt;p&gt;\nHello, &lt;b&gt;{upper ? name.toUpperCase() : name}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n)}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p></p>"},{"location":"learn/synchronizing-with-effects/#focus-a-field-conditionally","title":"Focus a field conditionally","text":"<p>This form renders two <code>&lt;MyInput /&gt;</code> components.</p> <p>Press \"Show form\" and notice that the second field automatically gets focused. This is because both of the <code>&lt;MyInput /&gt;</code> components try to focus the field inside. When you call <code>focus()</code> for two input fields in a row, the last one always \"wins\".</p> <p>Let's say you want to focus the first field. The first <code>MyInput</code> component now receives a boolean <code>shouldFocus</code> prop set to <code>true</code>. Change the logic so that <code>focus()</code> is only called if the <code>shouldFocus</code> prop received by <code>MyInput</code> is <code>true</code>.</p> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function MyInput({ shouldFocus, value, onChange }) {\nconst ref = useRef(null);\n\n// TODO: call focus() only if shouldFocus is true.\nuseEffect(() =&gt; {\nref.current.focus();\n}, []);\n\nreturn &lt;input ref={ref} value={value} onChange={onChange} /&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport MyInput from \"./MyInput.js\";\n\nexport default function Form() {\nconst [show, setShow] = useState(false);\nconst [firstName, setFirstName] = useState(\"Taylor\");\nconst [lastName, setLastName] = useState(\"Swift\");\nconst [upper, setUpper] = useState(false);\nconst name = firstName + \" \" + lastName;\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} form\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; (\n&lt;&gt;\n&lt;label&gt;\nEnter your first name:\n&lt;MyInput\nvalue={firstName}\nonChange={(e) =&gt; setFirstName(e.target.value)}\nshouldFocus={true}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEnter your last name:\n&lt;MyInput\nvalue={lastName}\nonChange={(e) =&gt; setLastName(e.target.value)}\nshouldFocus={false}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\nHello, &lt;b&gt;{upper ? name.toUpperCase() : name}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n)}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p>To verify your solution, press \"Show form\" and \"Hide form\" repeatedly. When the form appears, only the first input should get focused. This is because the parent component renders the first input with <code>shouldFocus={true}</code> and the second input with <code>shouldFocus={false}</code>. Also check that both inputs still work and you can type into both of them.</p> <p> <p>You can't declare an Effect conditionally, but your Effect can include conditional logic.</p> <p></p> <p> <p>Put the conditional logic inside the Effect. You will need to specify <code>shouldFocus</code> as a dependency because you are using it inside the Effect. (This means that if some input's <code>shouldFocus</code> changes from <code>false</code> to <code>true</code>, it will focus after mount.)</p> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function MyInput({ shouldFocus, value, onChange }) {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nif (shouldFocus) {\nref.current.focus();\n}\n}, [shouldFocus]);\n\nreturn &lt;input ref={ref} value={value} onChange={onChange} /&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport MyInput from \"./MyInput.js\";\n\nexport default function Form() {\nconst [show, setShow] = useState(false);\nconst [firstName, setFirstName] = useState(\"Taylor\");\nconst [lastName, setLastName] = useState(\"Swift\");\nconst [upper, setUpper] = useState(false);\nconst name = firstName + \" \" + lastName;\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} form\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; (\n&lt;&gt;\n&lt;label&gt;\nEnter your first name:\n&lt;MyInput\nvalue={firstName}\nonChange={(e) =&gt; setFirstName(e.target.value)}\nshouldFocus={true}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEnter your last name:\n&lt;MyInput\nvalue={lastName}\nonChange={(e) =&gt; setLastName(e.target.value)}\nshouldFocus={false}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\nHello, &lt;b&gt;{upper ? name.toUpperCase() : name}&lt;/b&gt;\n&lt;/p&gt;\n&lt;/&gt;\n)}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p></p>"},{"location":"learn/synchronizing-with-effects/#fix-an-interval-that-fires-twice","title":"Fix an interval that fires twice","text":"<p>This <code>Counter</code> component displays a counter that should increment every second. On mount, it calls <code>setInterval</code>. This causes <code>onTick</code> to run every second. The <code>onTick</code> function increments the counter.</p> <p>However, instead of incrementing once per second, it increments twice. Why is that? Find the cause of the bug and fix it.</p> <p> <p>Keep in mind that <code>setInterval</code> returns an interval ID, which you can pass to <code>clearInterval</code> to stop the interval.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nfunction onTick() {\nsetCount((c) =&gt; c + 1);\n}\n\nsetInterval(onTick, 1000);\n}, []);\n\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport Counter from \"./Counter.js\";\n\nexport default function Form() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} counter\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Counter /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p> <p>When Strict Mode is on (like in the sandboxes on this site), React remounts each component once in development. This causes the interval to be set up twice, and this is why each second the counter increments twice.</p> <p>However, React's behavior is not the cause of the bug: the bug already exists in the code. React's behavior makes the bug more noticeable. The real cause is that this Effect starts a process but doesn't provide a way to clean it up.</p> <p>To fix this code, save the interval ID returned by <code>setInterval</code>, and implement a cleanup function with <code>clearInterval</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nfunction onTick() {\nsetCount((c) =&gt; c + 1);\n}\n\nconst intervalId = setInterval(onTick, 1000);\nreturn () =&gt; clearInterval(intervalId);\n}, []);\n\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>import { useState } from \"react\";\nimport Counter from \"./Counter.js\";\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button on_click={() =&gt; setShow((s) =&gt; !s)}&gt;\n{show ? \"Hide\" : \"Show\"} counter\n&lt;/button&gt;\n&lt;br /&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Counter /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p>In development, React will still remount your component once to verify that you've implemented cleanup well. So there will be a <code>setInterval</code> call, immediately followed by <code>clearInterval</code>, and <code>setInterval</code> again. In production, there will be only one <code>setInterval</code> call. The user-visible behavior in both cases is the same: the counter increments once per second.</p> <p></p>"},{"location":"learn/synchronizing-with-effects/#fix-fetching-inside-an-effect","title":"Fix fetching inside an Effect","text":"<p>This component shows the biography for the selected person. It loads the biography by calling an asynchronous function <code>fetchBio(person)</code> on mount and whenever <code>person</code> changes. That asynchronous function returns a Promise which eventually resolves to a string. When fetching is done, it calls <code>setBio</code> to display that string under the select box.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\n\nuseEffect(() =&gt; {\nsetBio(null);\nfetchBio(person).then((result) =&gt; {\nsetBio(result);\n});\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>There is a bug in this code. Start by selecting \"Alice\". Then select \"Bob\" and then immediately after that select \"Taylor\". If you do this fast enough, you will notice that bug: Taylor is selected, but the paragraph below says \"This is Bob's bio.\"</p> <p>Why does this happen? Fix the bug inside this Effect.</p> <p> <p>If an Effect fetches something asynchronously, it usually needs cleanup.</p> <p></p> <p> <p>To trigger the bug, things need to happen in this order:</p> <ul> <li>Selecting <code>'Bob'</code> triggers <code>fetchBio('Bob')</code></li> <li>Selecting <code>'Taylor'</code> triggers <code>fetchBio('Taylor')</code></li> <li>Fetching <code>'Taylor'</code> completes before fetching <code>'Bob'</code></li> <li>The Effect from the <code>'Taylor'</code> render calls <code>setBio('This is Taylor\u2019s bio')</code></li> <li>Fetching <code>'Bob'</code> completes</li> <li>The Effect from the <code>'Bob'</code> render calls <code>setBio('This is Bob\u2019s bio')</code></li> </ul> <p>This is why you see Bob's bio even though Taylor is selected. Bugs like this are called race conditions because two asynchronous operations are \"racing\" with each other, and they might arrive in an unexpected order.</p> <p>To fix this race condition, add a cleanup function:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\nuseEffect(() =&gt; {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then((result) =&gt; {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>Each render's Effect has its own <code>ignore</code> variable. Initially, the <code>ignore</code> variable is set to <code>false</code>. However, if an Effect gets cleaned up (such as when you select a different person), its <code>ignore</code> variable becomes <code>true</code>. So now it doesn't matter in which order the requests complete. Only the last person's Effect will have <code>ignore</code> set to <code>false</code>, so it will call <code>setBio(result)</code>. Past Effects have been cleaned up, so the <code>if (!ignore)</code> check will prevent them from calling <code>setBio</code>:</p> <ul> <li>Selecting <code>'Bob'</code> triggers <code>fetchBio('Bob')</code></li> <li>Selecting <code>'Taylor'</code> triggers <code>fetchBio('Taylor')</code> and cleans up the previous (Bob's) Effect</li> <li>Fetching <code>'Taylor'</code> completes before fetching <code>'Bob'</code></li> <li>The Effect from the <code>'Taylor'</code> render calls <code>setBio('This is Taylor\u2019s bio')</code></li> <li>Fetching <code>'Bob'</code> completes</li> <li>The Effect from the <code>'Bob'</code> render does not do anything because its <code>ignore</code> flag was set to <code>true</code></li> </ul> <p>In addition to ignoring the result of an outdated API call, you can also use <code>AbortController</code> to cancel the requests that are no longer needed. However, by itself this is not enough to protect against race conditions. More asynchronous steps could be chained after the fetch, so using an explicit flag like <code>ignore</code> is the most reliable way to fix this type of problems.</p> <p></p> <p></p>"},{"location":"learn/thinking-in-react/","title":"Thinking in React","text":""},{"location":"learn/thinking-in-react/#overview","title":"Overview","text":"<p>  React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called components. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we\u2019ll guide you through the thought process of building a searchable product data table with React.  </p>"},{"location":"learn/thinking-in-react/#start-with-the-mockup","title":"Start with the mockup","text":"<p>Imagine that you already have a JSON API and a mockup from a designer.</p> <p>The JSON API returns some data that looks like this:</p> <pre><code>[\n{\n\"category\": \"Fruits\",\n\"price\": \"$1\",\n\"stocked\": true,\n\"name\": \"Apple\"\n},\n{\n\"category\": \"Fruits\",\n\"price\": \"$1\",\n\"stocked\": true,\n\"name\": \"Dragonfruit\"\n},\n{\n\"category\": \"Fruits\",\n\"price\": \"$2\",\n\"stocked\": false,\n\"name\": \"Passionfruit\"\n},\n{\n\"category\": \"Vegetables\",\n\"price\": \"$2\",\n\"stocked\": true,\n\"name\": \"Spinach\"\n},\n{\n\"category\": \"Vegetables\",\n\"price\": \"$4\",\n\"stocked\": false,\n\"name\": \"Pumpkin\"\n},\n{\n\"category\": \"Vegetables\",\n\"price\": \"$1\",\n\"stocked\": true,\n\"name\": \"Peas\"\n}\n]\n</code></pre> <p>The mockup looks like this:</p> <p></p> <p>To implement a UI in React, you will usually follow the same five steps.</p>"},{"location":"learn/thinking-in-react/#step-1-break-the-ui-into-a-component-hierarchy","title":"Step 1: Break the UI into a component hierarchy","text":"<p>Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them!</p> <p>Depending on your background, you can think about splitting up a design into components in different ways:</p> <ul> <li>Programming--use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</li> <li>CSS--consider what you would make class selectors for. (However, components are a bit less granular.)</li> <li>Design--consider how you would organize the design's layers.</li> </ul> <p>If your JSON is well-structured, you'll often find that it naturally maps to the component structure of your UI. That's because UI and data models often have the same information architecture--that is, the same shape. Separate your UI into components, where each component matches one piece of your data model.</p> <p>There are five components on this screen:</p> <p></p> <ol> <li><code>filterable_product_table</code> (grey) contains the entire app.</li> <li><code>search_bar</code> (blue) receives the user input.</li> <li><code>product_table</code> (lavender) displays and filters the list according to the user input.</li> <li><code>product_category_row</code> (green) displays a heading for each category.</li> <li><code>product_row</code> (yellow) displays a row for each product.</li> </ol> <p>If you look at <code>product_table</code> (lavender), you'll see that the table header (containing the \"Name\" and \"Price\" labels) isn't its own component. This is a matter of preference, and you could go either way. For this example, it is a part of <code>product_table</code> because it appears inside the <code>product_table</code>'s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its own <code>product_table_header</code> component.</p> <p>Now that you've identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy:</p> <ul> <li><code>filterable_product_table</code><ul> <li><code>search_bar</code></li> <li><code>product_table</code><ul> <li><code>product_category_row</code></li> <li><code>product_row</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"learn/thinking-in-react/#step-2-build-a-static-version-in-react","title":"Step 2: Build a static version in React","text":"<p>Now that you have your component hierarchy, it's time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity... yet! It's often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing.</p> <p>To build a static version of your app that renders your data model, you'll want to build components that reuse other components and pass data using props. Props are a way of passing data from parent to child. (If you're familiar with the concept of state, don't use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don't need it.)</p> <p>You can either build \"top down\" by starting with building the components higher up in the hierarchy (like <code>filterable_product_table</code>) or \"bottom up\" by working from components lower down (like <code>product_row</code>). In simpler examples, it\u2019s usually easier to go top-down, and on larger projects, it\u2019s easier to go bottom-up.</p> app.pystyles.css Run <pre><code>from reactpy import component, html\n\n\n@component\ndef product_category_row(category):\n    return html.tr(html.th({\"colSpan\": \"2\"}, category))\n\n\n@component\ndef product_row(product):\n    if product[\"stocked\"]:\n        name = product[\"name\"]\n    else:\n        name = html.span({\"style\": {\"color\": \"red\"}}, product[\"name\"])\n    return html.tr(html.td(name), html.td(product[\"price\"]))\n\n\n@component\ndef product_table(products):\n    rows = []\n    last_category = None\n    for product in products:\n        if product[\"category\"] != last_category:\n            rows.append(\n                product_category_row(product[\"category\"], key=product[\"category\"])\n            )\n        rows.append(product_row(product, key=product[\"name\"]))\n        last_category = product[\"category\"]\n\n    return html.table(\n        html.thead(html.tr(html.th(\"Name\"), html.th(\"Price\"))), html.tbody(rows)\n    )\n\n\n@component\ndef search_bar():\n    return html.form(\n        html.input({\"type\": \"text\", \"placeholder\": \"Search...\"}),\n        html.label(html.input({\"type\": \"checkbox\"}), \"Only show products in stock\"),\n    )\n\n\n@component\ndef filterable_product_table(products):\n    return html.div(search_bar(), product_table(products))\n\n\nPRODUCTS = [\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Apple\"},\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Dragonfruit\"},\n    {\"category\": \"Fruits\", \"price\": \"$2\", \"stocked\": False, \"name\": \"Passionfruit\"},\n    {\"category\": \"Vegetables\", \"price\": \"$2\", \"stocked\": True, \"name\": \"Spinach\"},\n    {\"category\": \"Vegetables\", \"price\": \"$4\", \"stocked\": False, \"name\": \"Pumpkin\"},\n    {\"category\": \"Vegetables\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Peas\"},\n]\n\n\n@component\ndef app():\n    return filterable_product_table(PRODUCTS)\n</code></pre> <pre><code>body {\npadding: 5px;\n}\nlabel {\ndisplay: block;\nmargin-top: 5px;\nmargin-bottom: 5px;\n}\nth {\npadding-top: 10px;\n}\ntd {\npadding: 2px;\npadding-right: 40px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>(If this code looks intimidating, go through the Quick Start first!)</p> <p>After building your components, you'll have a library of reusable components that render your data model. Because this is a static app, the components will only return non-interactive HTML. The component at the top of the hierarchy (<code>filterable_product_table</code>) will take your data model as a prop. This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree.</p> <p>Pitfall</p> <p>At this point, you should not be using any state values. That\u2019s for the next step!</p>"},{"location":"learn/thinking-in-react/#step-3-find-the-minimal-but-complete-representation-of-ui-state","title":"Step 3: Find the minimal but complete representation of UI state","text":"<p>To make the UI interactive, you need to let users change your underlying data model. You will use state for this.</p> <p>Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it DRY (Don't Repeat Yourself). Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you're building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don't store the number of items as another state value--instead, read the length of your array.</p> <p>Now think of all of the pieces of data in this example application:</p> <ol> <li>The original list of products</li> <li>The search text the user has entered</li> <li>The value of the checkbox</li> <li>The filtered list of products</li> </ol> <p>Which of these are state? Identify the ones that are not:</p> <ul> <li>Does it remain unchanged over time? If so, it isn't state.</li> <li>Is it passed in from a parent via props? If so, it isn't state.</li> <li>Can you compute it based on existing state or props in your component? If so, it definitely isn't state!</li> </ul> <p>What's left is probably state.</p> <p>Let's go through them one by one again:</p> <ol> <li>The original list of products is passed in as props, so it's not state.</li> <li>The search text seems to be state since it changes over time and can't be computed from anything.</li> <li>The value of the checkbox seems to be state since it changes over time and can't be computed from anything.</li> <li>The filtered list of products isn't state because it can be computed by taking the original list of products and filtering it according to the search text and value of the checkbox.</li> </ol> <p>This means only the search text and the value of the checkbox are state! Nicely done!</p> <p>Deep Dive</p> <p>Props vs State</p> <p>There are two types of \"model\" data in React: props and state. The two are very different:</p> <ul> <li>Props are like arguments you pass to a function. They let a parent component pass data to a child component and customize its appearance. For example, a <code>html.form</code> can pass a <code>color</code> prop to a <code>html.button</code>.</li> <li>State is like a component\u2019s memory. It lets a component keep track of some information and change it in response to interactions. For example, a <code>html.button</code> might keep track of <code>is_hovered</code> state.</li> </ul> <p>Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props. It's okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!</p>"},{"location":"learn/thinking-in-react/#step-4-identify-where-your-state-should-live","title":"Step 4: Identify where your state should live","text":"<p>After identifying your app\u2019s minimal state data, you need to identify which component is responsible for changing this state, or owns the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you\u2019re new to this concept, but you can figure it out by following these steps!</p> <p>For each piece of state in your application:</p> <ol> <li>Identify every component that renders something based on that state.</li> <li>Find their closest common parent component\u2014a component above them all in the hierarchy.</li> <li>Decide where the state should live:<ol> <li>Often, you can put the state directly into their common parent.</li> <li>You can also put the state into some component above their common parent.</li> <li>If you can't find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.</li> </ol> </li> </ol> <p>In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place.</p> <p>Now let's run through our strategy for them:</p> <ol> <li>Identify components that use state:<ul> <li><code>product_table</code> needs to filter the product list based on that state (search text and checkbox value).</li> <li><code>search_bar</code> needs to display that state (search text and checkbox value).</li> </ul> </li> <li>Find their common parent: The first parent component both components share is <code>filterable_product_table</code>.</li> <li>Decide where the state lives: We'll keep the filter text and checked state values in <code>filterable_product_table</code>.</li> </ol> <p>So the state values will live in <code>filterable_product_table</code>.</p> <p>Add state to the component with the <code>use_state()</code> Hook. Hooks are special functions that let you \"hook into\" React. Add two state variables at the top of <code>filterable_product_table</code> and specify their initial state:</p> <pre><code>@component\ndef filterable_product_table(products):\n    filter_text, set_filter_text = use_state(\"\")\n    in_stock_only, set_in_stock_only = use_state(False)\n</code></pre> <p>Then, pass <code>filter_text</code> and <code>in_stock_only</code> to <code>product_table</code> and <code>search_bar</code> as props:</p> <pre><code>html.div(\n    search_bar(filter_text=filter_text, in_stock_only=in_stock_only),\n    product_table(products=products, filter_text=filter_text, in_stock_only=in_stock_only),\n)\n</code></pre> <p>You can start seeing how your application will behave. Edit the <code>filter_text</code> initial value from <code>use_state('')</code> to <code>use_state('fruit')</code> in the sandbox code below. You'll see both the search input text and the table update:</p> app.pystyles.css Run <pre><code>from reactpy import component, html, use_state\n\n\n@component\ndef filterable_product_table(products):\n    filter_text, set_filter_text = use_state(\"\")\n    in_stock_only, set_in_stock_only = use_state(False)\n\n    return html.div(\n        search_bar(filter_text=filter_text, in_stock_only=in_stock_only),\n        product_table(\n            products=products, filter_text=filter_text, in_stock_only=in_stock_only\n        ),\n    )\n\n\n@component\ndef product_category_row(category):\n    return html.tr(\n        html.th({\"colspan\": 2}, category),\n    )\n\n\n@component\ndef product_row(product):\n    if product[\"stocked\"]:\n        name = product[\"name\"]\n    else:\n        name = html.span({\"style\": {\"color\": \"red\"}}, product[\"name\"])\n\n    return html.tr(\n        html.td(name),\n        html.td(product[\"price\"]),\n    )\n\n\n@component\ndef product_table(products, filter_text, in_stock_only):\n    rows = []\n    last_category = None\n\n    for product in products:\n        if filter_text.lower() not in product[\"name\"].lower():\n            continue\n        if in_stock_only and not product[\"stocked\"]:\n            continue\n        if product[\"category\"] != last_category:\n            rows.append(\n                product_category_row(product[\"category\"], key=product[\"category\"])\n            )\n        rows.append(product_row(product, key=product[\"name\"]))\n        last_category = product[\"category\"]\n\n    return html.table(\n        html.thead(\n            html.tr(\n                html.th(\"Name\"),\n                html.th(\"Price\"),\n            ),\n        ),\n        html.tbody(rows),\n    )\n\n\n@component\ndef search_bar(filter_text, in_stock_only):\n    return html.form(\n        html.input({\"type\": \"text\", \"value\": filter_text, \"placeholder\": \"Search...\"}),\n        html.label(\n            html.input({\"type\": \"checkbox\", \"checked\": in_stock_only}),\n            \"Only show products in stock\",\n        ),\n    )\n\n\nPRODUCTS = [\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Apple\"},\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Dragonfruit\"},\n    {\"category\": \"Fruits\", \"price\": \"$2\", \"stocked\": False, \"name\": \"Passionfruit\"},\n    {\"category\": \"Vegetables\", \"price\": \"$2\", \"stocked\": True, \"name\": \"Spinach\"},\n    {\"category\": \"Vegetables\", \"price\": \"$4\", \"stocked\": False, \"name\": \"Pumpkin\"},\n    {\"category\": \"Vegetables\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Peas\"},\n]\n\n\n@component\ndef app():\n    return filterable_product_table(PRODUCTS)\n</code></pre> <pre><code>body {\npadding: 5px;\n}\nlabel {\ndisplay: block;\nmargin-top: 5px;\nmargin-bottom: 5px;\n}\nth {\npadding-top: 5px;\n}\ntd {\npadding: 2px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>Notice that editing the form doesn't work yet.</p> <p>In the code above, <code>product_table</code> and <code>search_bar</code> read the <code>filter_text</code> and <code>in_stock_only</code> props to render the table, the input, and the checkbox. For example, here is how <code>search_bar</code> populates the input value:</p> <pre><code>@component\ndef search_bar(filter_text, in_stock_only):\nreturn html.form(\n        html.input(\n            {\n                \"type\": \"text\",\n\"value\": filter_text,\n\"placeholder\": \"Search...\",\n            }\n        ),\n        html.p(\n            html.input({\"type\": \"checkbox\", \"checked\": in_stock_only}),\n            \"Only show products in stock\",\n        ),\n    )\n</code></pre> <p>However, you haven't added any code to respond to the user actions like typing yet. This will be your final step.</p>"},{"location":"learn/thinking-in-react/#step-5-add-inverse-data-flow","title":"Step 5: Add inverse data flow","text":"<p>Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in <code>filterable_product_table</code>.</p> <p>React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you'll see that React ignores your input. This is intentional. By writing <code>&lt;input value={filter_text} /&gt;</code>, you've set the <code>value</code> prop of the <code>input</code> to always be equal to the <code>filter_text</code> state passed in from <code>filterable_product_table</code>. Since <code>filter_text</code> state is never set, the input never changes.</p> <p>You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned by <code>filterable_product_table</code>, so only it can call <code>set_filter_text</code> and <code>set_in_stock_only</code>. To let <code>search_bar</code> update the <code>filterable_product_table</code>'s state, you need to pass these functions down to <code>search_bar</code>:</p> <pre><code>@component\ndef filterable_product_table(products):\nfilter_text, set_filter_text = hooks.use_state(\"\")\nin_stock_only, set_in_stock_only = hooks.use_state(False)\nreturn html.div(\n        search_bar(\n            filter_text=filter_text,\n            in_stock_only=in_stock_only,\nset_filter_text=set_filter_text,\nset_in_stock_only=set_in_stock_only,\n)\n    )\n</code></pre> <p>Inside the <code>search_bar</code>, you will add the <code>onChange</code> event handlers and set the parent state from them:</p> <pre><code>html.input(\n    {\n        \"type\": \"text\",\n        \"value\": filter_text,\n        \"placeholder\": \"Search...\",\n\"onChange\": lambda event: set_filter_text(event[\"target\"][\"value\"]),\n}\n)\n</code></pre> <p>Now the application fully works!</p> app.pystyles.css Run <pre><code>from reactpy import component, html, use_state\n\n\n@component\ndef filterable_product_table(products):\n    filter_text, set_filter_text = use_state(\"\")\n    in_stock_only, set_in_stock_only = use_state(False)\n\n    return html.div(\n        search_bar(\n            filter_text=filter_text,\n            in_stock_only=in_stock_only,\n            set_filter_text=set_filter_text,\n            set_in_stock_only=set_in_stock_only,\n        ),\n        product_table(\n            products=products, filter_text=filter_text, in_stock_only=in_stock_only\n        ),\n    )\n\n\n@component\ndef product_category_row(category):\n    return html.tr(\n        html.th({\"colspan\": 2}, category),\n    )\n\n\n@component\ndef product_row(product):\n    if product[\"stocked\"]:\n        name = product[\"name\"]\n    else:\n        name = html.span({\"style\": {\"color\": \"red\"}}, product[\"name\"])\n\n    return html.tr(\n        html.td(name),\n        html.td(product[\"price\"]),\n    )\n\n\n@component\ndef product_table(products, filter_text, in_stock_only):\n    rows = []\n    last_category = None\n\n    for product in products:\n        if filter_text.lower() not in product[\"name\"].lower():\n            continue\n        if in_stock_only and not product[\"stocked\"]:\n            continue\n        if product[\"category\"] != last_category:\n            rows.append(\n                product_category_row(product[\"category\"], key=product[\"category\"])\n            )\n        rows.append(product_row(product, key=product[\"name\"]))\n        last_category = product[\"category\"]\n\n    return html.table(\n        html.thead(\n            html.tr(\n                html.th(\"Name\"),\n                html.th(\"Price\"),\n            ),\n        ),\n        html.tbody(rows),\n    )\n\n\n@component\ndef search_bar(filter_text, in_stock_only, set_filter_text, set_in_stock_only):\n    return html.form(\n        html.input(\n            {\n                \"type\": \"text\",\n                \"value\": filter_text,\n                \"placeholder\": \"Search...\",\n                \"onChange\": lambda event: set_filter_text(event[\"target\"][\"value\"]),\n            }\n        ),\n        html.label(\n            html.input(\n                {\n                    \"type\": \"checkbox\",\n                    \"checked\": in_stock_only,\n                    \"onChange\": lambda event: set_in_stock_only(\n                        event[\"target\"][\"checked\"]\n                    ),\n                }\n            ),\n            \"Only show products in stock\",\n        ),\n    )\n\n\nPRODUCTS = [\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Apple\"},\n    {\"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Dragonfruit\"},\n    {\"category\": \"Fruits\", \"price\": \"$2\", \"stocked\": False, \"name\": \"Passionfruit\"},\n    {\"category\": \"Vegetables\", \"price\": \"$2\", \"stocked\": True, \"name\": \"Spinach\"},\n    {\"category\": \"Vegetables\", \"price\": \"$4\", \"stocked\": False, \"name\": \"Pumpkin\"},\n    {\"category\": \"Vegetables\", \"price\": \"$1\", \"stocked\": True, \"name\": \"Peas\"},\n]\n\n\n@component\ndef app():\n    return filterable_product_table(PRODUCTS)\n</code></pre> <pre><code>body {\npadding: 5px;\n}\nlabel {\ndisplay: block;\nmargin-top: 5px;\nmargin-bottom: 5px;\n}\nth {\npadding: 4px;\n}\ntd {\npadding: 2px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>You can learn all about handling events and updating state in the Adding Interactivity section.</p>"},{"location":"learn/thinking-in-react/#where-to-go-from-here","title":"Where to go from here","text":"<p>This was a very brief introduction to how to think about building components and applications with React. You can start a React project right now or dive deeper on all the syntax used in this tutorial.</p>"},{"location":"learn/tutorial-material-ui/","title":"Tutorial material ui","text":"<p>Planned / Undeveloped</p> <p>This tutorial is planned, but is missing a key feature before this page can be written.</p> <p>See this issue for more details.</p>"},{"location":"learn/tutorial-react-bootstrap/","title":"Tutorial react bootstrap","text":"<p>Planned / Undeveloped</p> <p>This tutorial is planned, but is missing a key feature before this page can be written.</p> <p>See this issue for more details.</p>"},{"location":"learn/tutorial-tic-tac-toe/","title":"Tutorial: Tic-Tac-Toe \ud83d\udea7","text":""},{"location":"learn/tutorial-tic-tac-toe/#overview","title":"Overview","text":"<p>  You will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques you'll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React.  </p> <p>Note</p> <p>This tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, start with Describing the UI.</p> <p>The tutorial is divided into several sections:</p> <ul> <li>Setup for the tutorial will give you a starting point to follow the tutorial.</li> <li>Overview will teach you the fundamentals of React: components, props, and state.</li> <li>Completing the game will teach you the most common techniques in React development.</li> <li>Adding time travel will give you a deeper insight into the unique strengths of React.</li> </ul>"},{"location":"learn/tutorial-tic-tac-toe/#what-are-you-building","title":"What are you building?","text":"<p>In this tutorial, you'll build an interactive tic-tac-toe game with React.</p> <p>You can see what it will look like when you're finished here:</p> app.pystyles.css Run <pre><code>from copy import deepcopy\n\nfrom reactpy import component, html, use_state\n\n\n@component\ndef square(value, on_square_click):\n    return html.button(\n        {\"className\": \"square\", \"onClick\": on_square_click},\n        value,\n    )\n\n\n@component\ndef board(x_is_next, squares, on_play):\n    def handle_click(i):\n        def inner(event):\n\"\"\"\n            Due to a quirk of Python, if your event handler needs args other than\n            `event`, you will need to create a wrapper function as seen above.\n            Ref: https://pylint.readthedocs.io/en/stable/user_guide/messages/warning/cell-var-from-loop.html\n            \"\"\"\n            if calculate_winner(squares) or squares[i]:\n                return\n\n            next_squares = squares.copy()\n            next_squares[i] = \"X\" if x_is_next else \"O\"\n            on_play(next_squares)\n\n        return inner\n\n    winner = calculate_winner(squares)\n    status = (\n        f\"Winner: {winner}\" if winner else \"Next player: \" + (\"X\" if x_is_next else \"O\")\n    )\n\n    return html._(\n        html.div({\"className\": \"status\"}, status),\n        html.div(\n            {\"className\": \"board-row\"},\n            square(squares[0], handle_click(0)),\n            square(squares[1], handle_click(1)),\n            square(squares[2], handle_click(2)),\n        ),\n        html.div(\n            {\"className\": \"board-row\"},\n            square(squares[3], handle_click(3)),\n            square(squares[4], handle_click(4)),\n            square(squares[5], handle_click(5)),\n        ),\n        html.div(\n            {\"className\": \"board-row\"},\n            square(squares[6], handle_click(6)),\n            square(squares[7], handle_click(7)),\n            square(squares[8], handle_click(8)),\n        ),\n    )\n\n\n@component\ndef game():\n    history, set_history = use_state([[None] * 9])\n    current_move, set_current_move = use_state(0)\n    x_is_next = current_move % 2 == 0\n    current_squares = history[current_move]\n\n    def handle_play(next_squares):\n        next_history = deepcopy(history[: current_move + 1])\n        next_history.append(next_squares)\n        set_history(next_history)\n        set_current_move(len(next_history) - 1)\n\n    def jump_to(next_move):\n        return lambda _event: set_current_move(next_move)\n\n    moves = []\n    for move, _squares in enumerate(history):\n        description = f\"Go to move #{move}\" if move &gt; 0 else \"Go to game start\"\n\n        moves.append(\n            html.li(\n                {\"key\": move},\n                html.button({\"onClick\": jump_to(move)}, description),\n            )\n        )\n\n    return html.div(\n        {\"className\": \"game\"},\n        html.div(\n            {\"className\": \"game-board\"},\n            board(x_is_next, current_squares, handle_play),\n        ),\n        html.div({\"className\": \"game-info\"}, html.ol(moves)),\n    )\n\n\ndef calculate_winner(squares):\n    lines = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8],\n        [0, 3, 6],\n        [1, 4, 7],\n        [2, 5, 8],\n        [0, 4, 8],\n        [2, 4, 6],\n    ]\n    for line in lines:\n        a, b, c = line\n        if not squares:\n            continue\n        if squares[a] and squares[a] == squares[b] and squares[a] == squares[c]:\n            return squares[a]\n\n    return None\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>If the code doesn't make sense to you yet, or if you are unfamiliar with the code's syntax, don't worry! The goal of this tutorial is to help you understand React and its syntax.</p> <p>We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that you'll notice is that there is a numbered list to the right of the game's board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses.</p> <p>Once you've played around with the finished tic-tac-toe game, keep scrolling. You'll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game.</p>"},{"location":"learn/tutorial-tic-tac-toe/#setup-for-the-tutorial","title":"Setup for the tutorial","text":"<p>In the code example below, click Run to open the editor in a new tab using the website Jupyter. Jupyter lets you write code in your browser and preview how your users will see the app you've created. The new tab should display an empty square and the starter code for this tutorial.</p> app.pystyles.css Run <pre><code>@component\ndef square():\n    return html.button({\"className\": \"square\"}, \"X\")\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <pre><code># TODO\n</code></pre> <p>Note</p> <p>You can also follow this tutorial using your local development environment. To do this, you need to:</p> <ol> <li>Install Python</li> <li>Copy the example above into a file called <code>app.py</code></li> <li>Install ReactPy for your backend, for example <code>pip install reactpy[fastapi]</code></li> <li>Add <code>reactpy.run(...)</code> to the end of your Python file</li> <li>Run <code>python app.py</code> to start a local server and follow the prompts to view the code running in a browser</li> </ol> <p>If you get stuck, don't let this stop you! Follow along online instead and try a local setup again later.</p>"},{"location":"learn/tutorial-tic-tac-toe/#overview_1","title":"Overview","text":"<p>Now that you're set up, let's get an overview of React!</p>"},{"location":"learn/tutorial-tic-tac-toe/#inspecting-the-starter-code","title":"Inspecting the starter code","text":"<p>In Jupyter you'll see three main sections:</p> <p></p> <ol> <li>The Files section with a list of files like <code>tic-tac-toe.ipynb</code></li> <li>The interactive code notebook where you'll see the source code for each step</li> <li>The run button located on top of the notebook in the command strip</li> </ol> <p>The <code>tic-tac-toe.ipynb</code> file should be selected in the Files section. Click on the first code box, where the contents of that code editor should be:</p> <pre><code>@component\ndef square():\n    return html.button({\"className\": \"square\"}, \"X\")\n</code></pre> <p>After clicking the run button the notebook should be displaying a square with a X in it like this:</p> <p></p> <p>Now let's have a look at the files in the starter code.</p>"},{"location":"learn/tutorial-tic-tac-toe/#appjs","title":"<code>App.js</code>","text":"<p>The code in <code>App.js</code> creates a component. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Let's look at the component line by line to see what's going on:</p> <pre><code>export default function Square() {\nreturn &lt;button className=\"square\"&gt;X&lt;/button&gt;;\n}\n</code></pre> <p>The first line defines a function called <code>Square</code>. The <code>export</code> JavaScript keyword makes this function accessible outside of this file. The <code>default</code> keyword tells other files using your code that it's the main function in your file.</p> <pre><code>export default function Square() {\nreturn &lt;button className=\"square\"&gt;X&lt;/button&gt;;\n}\n</code></pre> <p>The second line returns a button. The <code>return</code> JavaScript keyword means whatever comes after is returned as a value to the caller of the function. <code>&lt;button&gt;</code> is a JSX element. A JSX element is a combination of JavaScript code and HTML tags that describes what you'd like to display. <code>className=\"square\"</code> is a button property or prop that tells CSS how to style the button. <code>X</code> is the text displayed inside of the button and <code>&lt;/button&gt;</code> closes the JSX element to indicate that any following content shouldn't be placed inside the button.</p>"},{"location":"learn/tutorial-tic-tac-toe/#stylescss","title":"<code>styles.css</code>","text":"<p>Click on the file labeled <code>styles.css</code> in the Files section of CodeSandbox. This file defines the styles for your React app. The first two CSS selectors (<code>*</code> and <code>body</code>) define the style of large parts of your app while the <code>.square</code> selector defines the style of any component where the <code>className</code> property is set to <code>square</code>. In your code, that would match the button from your Square component in the <code>App.js</code> file.</p>"},{"location":"learn/tutorial-tic-tac-toe/#indexjs","title":"<code>index.js</code>","text":"<p>Click on the file labeled <code>index.js</code> in the Files section of CodeSandbox. You won't be editing this file during the tutorial but it is the bridge between the component you created in the <code>App.js</code> file and the web browser.</p> <pre><code>import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport \"./styles.css\";\n\nimport App from \"./App\";\n</code></pre> <p>Lines 1-5 brings all the necessary pieces together:</p> <ul> <li>React</li> <li>React's library to talk to web browsers (React DOM)</li> <li>the styles for your components</li> <li>the component you created in <code>App.js</code>.</li> </ul> <p>The remainder of the file brings all the pieces together and injects the final product into <code>index.html</code> in the <code>public</code> folder.</p>"},{"location":"learn/tutorial-tic-tac-toe/#building-the-board","title":"Building the board","text":"<p>Let's get back to <code>App.js</code>. This is where you'll spend the rest of the tutorial.</p> <p>Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this:</p> <pre><code>export default function Square() {\nreturn &lt;button className=\"square\"&gt;X&lt;/button&gt;&lt;button className=\"square\"&gt;X&lt;/button&gt;;\n}\n</code></pre> <p>You'll get this error:</p> <p> <p>/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <code>&lt;&gt;...</code>?</p> <p></p> <p>React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can use fragments (<code>&lt;&gt;</code> and ``) to wrap multiple adjacent JSX elements like this:</p> <pre><code>export default function Square() {\nreturn (\n&lt;&gt;\n&lt;button className=\"square\"&gt;X&lt;/button&gt;\n&lt;button className=\"square\"&gt;X&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now you should see:</p> <p></p> <p>Great! Now you just need to copy-paste a few times to add nine squares and...</p> <p></p> <p>Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this you'll need to group your squares into rows with <code>div</code>s and add some CSS classes. While you're at it, you'll give each square a number to make sure you know where each square is displayed.</p> <p>In the <code>App.js</code> file, update the <code>Square</code> component to look like this:</p> <pre><code>export default function Square() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;1&lt;/button&gt;\n&lt;button className=\"square\"&gt;2&lt;/button&gt;\n&lt;button className=\"square\"&gt;3&lt;/button&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;4&lt;/button&gt;\n&lt;button className=\"square\"&gt;5&lt;/button&gt;\n&lt;button className=\"square\"&gt;6&lt;/button&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;7&lt;/button&gt;\n&lt;button className=\"square\"&gt;8&lt;/button&gt;\n&lt;button className=\"square\"&gt;9&lt;/button&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>The CSS defined in <code>styles.css</code> styles the divs with the <code>className</code> of <code>board-row</code>. Now that you've grouped your components into rows with the styled <code>div</code>s you have your tic-tac-toe board:</p> <p></p> <p>But you now have a problem. Your component named <code>Square</code>, really isn't a square anymore. Let's fix that by changing the name to <code>Board</code>:</p> <pre><code>export default function Board() {\n//...\n}\n</code></pre> <p>At this point your code should look something like this:</p> <pre><code>export default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;1&lt;/button&gt;\n&lt;button className=\"square\"&gt;2&lt;/button&gt;\n&lt;button className=\"square\"&gt;3&lt;/button&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;4&lt;/button&gt;\n&lt;button className=\"square\"&gt;5&lt;/button&gt;\n&lt;button className=\"square\"&gt;6&lt;/button&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;button className=\"square\"&gt;7&lt;/button&gt;\n&lt;button className=\"square\"&gt;8&lt;/button&gt;\n&lt;button className=\"square\"&gt;9&lt;/button&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p> <p>Psssst... That's a lot to type! It's okay to copy and paste code from this page. However, if you're up for a little challenge, we recommend only copying code that you've manually typed at least once yourself.</p> <p></p>"},{"location":"learn/tutorial-tic-tac-toe/#passing-data-through-props","title":"Passing data through props","text":"<p>Next, you'll want to change the value of a square from empty to \"X\" when the user clicks on the square. With how you've built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, React's component architecture allows you to create a reusable component to avoid messy, duplicated code.</p> <p>First, you are going to copy the line defining your first square (<code>&lt;button className=\"square\"&gt;1&lt;/button&gt;</code>) from your <code>Board</code> component into a new <code>Square</code> component:</p> <pre><code>function Square() {\nreturn &lt;button className=\"square\"&gt;1&lt;/button&gt;;\n}\n\nexport default function Board() {\n// ...\n}\n</code></pre> <p>Then you'll update the Board component to render that <code>Square</code> component using JSX syntax:</p> <pre><code>// ...\nexport default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Note how unlike the browser <code>div</code>s, your own components <code>Board</code> and <code>Square</code> must start with a capital letter.</p> <p>Let's take a look:</p> <p></p> <p>Oh no! You lost the numbered squares you had before. Now each square says \"1\". To fix this, you will use props to pass the value each square should have from the parent component (<code>Board</code>) to its child (<code>Square</code>).</p> <p>Update the <code>Square</code> component to read the <code>value</code> prop that you'll pass from the <code>Board</code>:</p> <pre><code>function Square({ value }) {\nreturn &lt;button className=\"square\"&gt;1&lt;/button&gt;;\n}\n</code></pre> <p><code>function Square({ value })</code> indicates the Square component can be passed a prop called <code>value</code>.</p> <p>Now you want to display that <code>value</code> instead of <code>1</code> inside every square. Try doing it like this:</p> <pre><code>function Square({ value }) {\nreturn &lt;button className=\"square\"&gt;value&lt;/button&gt;;\n}\n</code></pre> <p>Oops, this is not what you wanted:</p> <p></p> <p>You wanted to render the JavaScript variable called <code>value</code> from your component, not the word \"value\". To \"escape into JavaScript\" from JSX, you need curly braces. Add curly braces around <code>value</code> in JSX like so:</p> <pre><code>function Square({ value }) {\nreturn &lt;button className=\"square\"&gt;{value}&lt;/button&gt;;\n}\n</code></pre> <p>For now, you should see an empty board:</p> <p></p> <p>This is because the <code>Board</code> component hasn't passed the <code>value</code> prop to each <code>Square</code> component it renders yet. To fix it you'll add the <code>value</code> prop to each <code>Square</code> component rendered by the <code>Board</code> component:</p> <pre><code>export default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"1\" /&gt;\n&lt;Square value=\"2\" /&gt;\n&lt;Square value=\"3\" /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"4\" /&gt;\n&lt;Square value=\"5\" /&gt;\n&lt;Square value=\"6\" /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"7\" /&gt;\n&lt;Square value=\"8\" /&gt;\n&lt;Square value=\"9\" /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now you should see a grid of numbers again:</p> <p></p> <p>Your updated code should look like this:</p> <pre><code>function Square({ value }) {\nreturn &lt;button className=\"square\"&gt;{value}&lt;/button&gt;;\n}\n\nexport default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"1\" /&gt;\n&lt;Square value=\"2\" /&gt;\n&lt;Square value=\"3\" /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"4\" /&gt;\n&lt;Square value=\"5\" /&gt;\n&lt;Square value=\"6\" /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value=\"7\" /&gt;\n&lt;Square value=\"8\" /&gt;\n&lt;Square value=\"9\" /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#making-an-interactive-component","title":"Making an interactive component","text":"<p>Let's fill the <code>Square</code> component with an <code>X</code> when you click it. Declare a function called <code>handleClick</code> inside of the <code>Square</code>. Then, add <code>on_click</code> to the props of the button JSX element returned from the <code>Square</code>:</p> <pre><code>function Square({ value }) {\nfunction handleClick() {\nconsole.log(\"clicked!\");\n}\n\nreturn (\n&lt;button className=\"square\" on_click={handleClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>If you click on a square now, you should see a log saying <code>\"clicked!\"</code> in the Console tab at the bottom of the Browser section in CodeSandbox. Clicking the square more than once will log <code>\"clicked!\"</code> again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first <code>\"clicked!\"</code> log.</p> <p> <p>If you are following this tutorial using your local development environment, you need to open your browser's Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcut Shift + Ctrl + J (on Windows/Linux) or Option + \u2318 + J (on macOS).</p> <p></p> <p>As a next step, you want the Square component to \"remember\" that it got clicked, and fill it with an \"X\" mark. To \"remember\" things, components use state.</p> <p>React provides a special function called <code>useState</code> that you can call from your component to let it \"remember\" things. Let's store the current value of the <code>Square</code> in state, and change it when the <code>Square</code> is clicked.</p> <p>Import <code>useState</code> at the top of the file. Remove the <code>value</code> prop from the <code>Square</code> component. Instead, add a new line at the start of the <code>Square</code> that calls <code>useState</code>. Have it return a state variable called <code>value</code>:</p> <pre><code>import { useState } from 'react';\n\nfunction Square() {\nconst [value, setValue] = useState(null);\n\nfunction handleClick() {\n//...\n</code></pre> <p><code>value</code> stores the value and <code>setValue</code> is a function that can be used to change the value. The <code>null</code> passed to <code>useState</code> is used as the initial value for this state variable, so <code>value</code> here starts off equal to <code>null</code>.</p> <p>Since the <code>Square</code> component no longer accepts props anymore, you'll remove the <code>value</code> prop from all nine of the Square components created by the Board component:</p> <pre><code>// ...\nexport default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now you'll change <code>Square</code> to display an \"X\" when clicked. Replace the <code>console.log(\"clicked!\");</code> event handler with <code>setValue('X');</code>. Now your <code>Square</code> component looks like this:</p> <pre><code>function Square() {\nconst [value, setValue] = useState(null);\n\nfunction handleClick() {\nsetValue(\"X\");\n}\n\nreturn (\n&lt;button className=\"square\" on_click={handleClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>By calling this <code>set</code> function from an <code>on_click</code> handler, you're telling React to re-render that <code>Square</code> whenever its <code>&lt;button&gt;</code> is clicked. After the update, the <code>Square</code>'s <code>value</code> will be <code>'X'</code>, so you'll see the \"X\" on the game board. Click on any Square, and \"X\" should show up:</p> <p></p> <p>Each Square has its own state: the <code>value</code> stored in each Square is completely independent of the others. When you call a <code>set</code> function in a component, React automatically updates the child components inside too.</p> <p>After you've made the above changes, your code will look like this:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square() {\nconst [value, setValue] = useState(null);\n\nfunction handleClick() {\nsetValue(\"X\");\n}\n\nreturn (\n&lt;button className=\"square\" on_click={handleClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nexport default function Board() {\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;Square /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#react-developer-tools","title":"React Developer Tools","text":"<p>React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of the browser section in CodeSandbox:</p> <p></p> <p>To inspect a particular component on the screen, use the button in the top left corner of React DevTools:</p> <p></p> <p> <p>For local development, React DevTools is available as a Chrome, Firefox, and Edge browser extension. Install it, and the Components tab will appear in your browser Developer Tools for sites using React.</p> <p></p>"},{"location":"learn/tutorial-tic-tac-toe/#completing-the-game","title":"Completing the game","text":"<p>By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing \"X\"s and \"O\"s on the board, and you need a way to determine a winner.</p>"},{"location":"learn/tutorial-tic-tac-toe/#lifting-state-up","title":"Lifting state up","text":"<p>Currently, each <code>Square</code> component maintains a part of the game's state. To check for a winner in a tic-tac-toe game, the <code>Board</code> would need to somehow know the state of each of the 9 <code>Square</code> components.</p> <p>How would you approach that? At first, you might guess that the <code>Board</code> needs to \"ask\" each <code>Square</code> for that <code>Square</code>'s state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game's state in the parent <code>Board</code> component instead of in each <code>Square</code>. The <code>Board</code> component can tell each <code>Square</code> what to display by passing a prop, like you did when you passed a number to each Square.</p> <p>To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.</p> <p>Lifting state into a parent component is common when React components are refactored.</p> <p>Let's take this opportunity to try it out. Edit the <code>Board</code> component so that it declares a state variable named <code>squares</code> that defaults to an array of 9 nulls corresponding to the 9 squares:</p> <pre><code>// ...\nexport default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\nreturn (\n// ...\n);\n}\n</code></pre> <p><code>Array(9).fill(null)</code> creates an array with nine elements and sets each of them to <code>null</code>. The <code>useState()</code> call around it declares a <code>squares</code> state variable that's initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, the <code>squares</code> array will look like this:</p> <pre><code>[\"O\", null, \"X\", \"X\", \"X\", \"O\", \"O\", null, null];\n</code></pre> <p>Now your <code>Board</code> component needs to pass the <code>value</code> prop down to each <code>Square</code> that it renders:</p> <pre><code>export default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[0]} /&gt;\n&lt;Square value={squares[1]} /&gt;\n&lt;Square value={squares[2]} /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[3]} /&gt;\n&lt;Square value={squares[4]} /&gt;\n&lt;Square value={squares[5]} /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[6]} /&gt;\n&lt;Square value={squares[7]} /&gt;\n&lt;Square value={squares[8]} /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Next, you'll edit the <code>Square</code> component to receive the <code>value</code> prop from the Board component. This will require removing the Square component's own stateful tracking of <code>value</code> and the button's <code>on_click</code> prop:</p> <pre><code>function Square({ value }) {\nreturn &lt;button className=\"square\"&gt;{value}&lt;/button&gt;;\n}\n</code></pre> <p>At this point you should see an empty tic-tac-toe board:</p> <p></p> <p>And your code should look like this:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value }) {\nreturn &lt;button className=\"square\"&gt;{value}&lt;/button&gt;;\n}\n\nexport default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[0]} /&gt;\n&lt;Square value={squares[1]} /&gt;\n&lt;Square value={squares[2]} /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[3]} /&gt;\n&lt;Square value={squares[4]} /&gt;\n&lt;Square value={squares[5]} /&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[6]} /&gt;\n&lt;Square value={squares[7]} /&gt;\n&lt;Square value={squares[8]} /&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p>Each Square will now receive a <code>value</code> prop that will either be <code>'X'</code>, <code>'O'</code>, or <code>null</code> for empty squares.</p> <p>Next, you need to change what happens when a <code>Square</code> is clicked. The <code>Board</code> component now maintains which squares are filled. You'll need to create a way for the <code>Square</code> to update the <code>Board</code>'s state. Since state is private to a component that defines it, you cannot update the <code>Board</code>'s state directly from <code>Square</code>.</p> <p>Instead, you'll pass down a function from the <code>Board</code> component to the <code>Square</code> component, and you'll have <code>Square</code> call that function when a square is clicked. You'll start with the function that the <code>Square</code> component will call when it is clicked. You'll call that function <code>onSquareClick</code>:</p> <pre><code>function Square({ value }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>Next, you'll add the <code>onSquareClick</code> function to the <code>Square</code> component's props:</p> <pre><code>function Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>Now you'll connect the <code>onSquareClick</code> prop to a function in the <code>Board</code> component that you'll name <code>handleClick</code>. To connect <code>onSquareClick</code> to <code>handleClick</code> you'll pass a function to the <code>onSquareClick</code> prop of the first <code>Square</code> component:</p> <pre><code>export default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[0]} onSquareClick={handleClick} /&gt;\n//...\n);\n}\n</code></pre> <p>Lastly, you will define the <code>handleClick</code> function inside the Board component to update the <code>squares</code> array holding your board's state:</p> <pre><code>export default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick() {\nconst nextSquares = squares.slice();\nnextSquares[0] = \"X\";\nsetSquares(nextSquares);\n}\n\nreturn (\n// ...\n)\n}\n</code></pre> <p>The <code>handleClick</code> function creates a copy of the <code>squares</code> array (<code>nextSquares</code>) with the JavaScript <code>slice()</code> Array method. Then, <code>handleClick</code> updates the <code>nextSquares</code> array to add <code>X</code> to the first (<code>[0]</code> index) square.</p> <p>Calling the <code>setSquares</code> function lets React know the state of the component has changed. This will trigger a re-render of the components that use the <code>squares</code> state (<code>Board</code>) as well as its child components (the <code>Square</code> components that make up the board).</p> <p> <p>JavaScript supports closures which means an inner function (e.g. <code>handleClick</code>) has access to variables and functions defined in a outer function (e.g. <code>Board</code>). The <code>handleClick</code> function can read the <code>squares</code> state and call the <code>setSquares</code> method because they are both defined inside of the <code>Board</code> function.</p> <p></p> <p>Now you can add X's to the board... but only to the upper left square. Your <code>handleClick</code> function is hardcoded to update the index for the upper left square (<code>0</code>). Let's update <code>handleClick</code> to be able to update any square. Add an argument <code>i</code> to the <code>handleClick</code> function that takes the index of the square to update:</p> <pre><code>export default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick(i) {\nconst nextSquares = squares.slice();\nnextSquares[i] = \"X\";\nsetSquares(nextSquares);\n}\n\nreturn (\n// ...\n)\n}\n</code></pre> <p>Next, you will need to pass that <code>i</code> to <code>handleClick</code>. You could try to set the <code>onSquareClick</code> prop of square to be <code>handleClick(0)</code> directly in the JSX like this, but it won't work:</p> <pre><code>&lt;Square value={squares[0]} onSquareClick={handleClick(0)} /&gt;\n</code></pre> <p>Here is why this doesn't work. The <code>handleClick(0)</code> call will be a part of rendering the board component. Because <code>handleClick(0)</code> alters the state of the board component by calling <code>setSquares</code>, your entire board component will be re-rendered again. But this runs <code>handleClick(0)</code> again, leading to an infinite loop:</p> <p> <p>Too many re-renders. React limits the number of renders to prevent an infinite loop.</p> <p></p> <p>Why didn't this problem happen earlier?</p> <p>When you were passing <code>onSquareClick={handleClick}</code>, you were passing the <code>handleClick</code> function down as a prop. You were not calling it! But now you are calling that function right away--notice the parentheses in <code>handleClick(0)</code>--and that's why it runs too early. You don't want to call <code>handleClick</code> until the user clicks!</p> <p>You could fix by creating a function like <code>handleFirstSquareClick</code> that calls <code>handleClick(0)</code>, a function like <code>handleSecondSquareClick</code> that calls <code>handleClick(1)</code>, and so on. You would pass (rather than call) these functions down as props like <code>onSquareClick={handleFirstSquareClick}</code>. This would solve the infinite loop.</p> <p>However, defining nine different functions and giving each of them a name is too verbose. Instead, let's do this:</p> <pre><code>export default function Board() {\n// ...\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square value={squares[0]} onSquareClick={() =&gt; handleClick(0)} /&gt;\n// ...\n);\n}\n</code></pre> <p>Notice the new <code>() =&gt;</code> syntax. Here, <code>() =&gt; handleClick(0)</code> is an arrow function, which is a shorter way to define functions. When the square is clicked, the code after the <code>=&gt;</code> \"arrow\" will run, calling <code>handleClick(0)</code>.</p> <p>Now you need to update the other eight squares to call <code>handleClick</code> from the arrow functions you pass. Make sure that the argument for each call of the <code>handleClick</code> corresponds to the index of the correct square:</p> <pre><code>export default function Board() {\n// ...\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Now you can again add X's to any square on the board by clicking on them:</p> <p></p> <p>But this time all the state management is handled by the <code>Board</code> component!</p> <p>This is what your code should look like:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nexport default function Board() {\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick(i) {\nconst nextSquares = squares.slice();\nnextSquares[i] = \"X\";\nsetSquares(nextSquares);\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p>Now that your state handling is in the <code>Board</code> component, the parent <code>Board</code> component passes props to the child <code>Square</code> components so that they can be displayed correctly. When clicking on a <code>Square</code>, the child <code>Square</code> component now asks the parent <code>Board</code> component to update the state of the board. When the <code>Board</code>'s state changes, both the <code>Board</code> component and every child <code>Square</code> re-renders automatically. Keeping the state of all squares in the <code>Board</code> component will allow it to determine the winner in the future.</p> <p>Let's recap what happens when a user clicks the top left square on your board to add an <code>X</code> to it:</p> <ol> <li>Clicking on the upper left square runs the function that the <code>button</code> received as its <code>on_click</code> prop from the <code>Square</code>. The <code>Square</code> component received that function as its <code>onSquareClick</code> prop from the <code>Board</code>. The <code>Board</code> component defined that function directly in the JSX. It calls <code>handleClick</code> with an argument of <code>0</code>.</li> <li><code>handleClick</code> uses the argument (<code>0</code>) to update the first element of the <code>squares</code> array from <code>null</code> to <code>X</code>.</li> <li>The <code>squares</code> state of the <code>Board</code> component was updated, so the <code>Board</code> and all of its children re-render. This causes the <code>value</code> prop of the <code>Square</code> component with index <code>0</code> to change from <code>null</code> to <code>X</code>.</li> </ol> <p>In the end the user sees that the upper left square has changed from empty to having a <code>X</code> after clicking it.</p> <p> <p>The DOM <code>&lt;button&gt;</code> element's <code>on_click</code> attribute has a special meaning to React because it is a built-in component. For custom components like Square, the naming is up to you. You could give any name to the <code>Square</code>'s <code>onSquareClick</code> prop or <code>Board</code>'s <code>handleClick</code> function, and the code would work the same. In React, it's conventional to use <code>onSomething</code> names for props which represent events and <code>handleSomething</code> for the function definitions which handle those events.</p> <p></p>"},{"location":"learn/tutorial-tic-tac-toe/#why-immutability-is-important","title":"Why immutability is important","text":"<p>Note how in <code>handleClick</code>, you call <code>.slice()</code> to create a copy of the <code>squares</code> array instead of modifying the existing array. To explain why, we need to discuss immutability and why immutability is important to learn.</p> <p>There are generally two approaches to changing data. The first approach is to mutate the data by directly changing the data's values. The second approach is to replace the data with a new copy which has the desired changes. Here is what it would look like if you mutated the <code>squares</code> array:</p> <pre><code>const squares = [null, null, null, null, null, null, null, null, null];\nsquares[0] = \"X\";\n// Now `squares` is [\"X\", null, null, null, null, null, null, null, null];\n</code></pre> <p>And here is what it would look like if you changed data without mutating the <code>squares</code> array:</p> <pre><code>const squares = [null, null, null, null, null, null, null, null, null];\nconst nextSquares = [\"X\", null, null, null, null, null, null, null, null];\n// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`\n</code></pre> <p>The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits.</p> <p>Immutability makes complex features much easier to implement. Later in this tutorial, you will implement a \"time travel\" feature that lets you review the game's history and \"jump back\" to past moves. This functionality isn't specific to games--an ability to undo and redo certain actions is a common requirement for apps. Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later.</p> <p>There is also another benefit of immutability. By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that weren't affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldn't actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn't affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. You can learn more about how React chooses when to re-render a component in the <code>memo</code> API reference.</p>"},{"location":"learn/tutorial-tic-tac-toe/#taking-turns","title":"Taking turns","text":"<p>It's now time to fix a major defect in this tic-tac-toe game: the \"O\"s cannot be marked on the board.</p> <p>You'll set the first move to be \"X\" by default. Let's keep track of this by adding another piece of state to the Board component:</p> <pre><code>function Board() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\n// ...\n}\n</code></pre> <p>Each time a player moves, <code>xIsNext</code> (a boolean) will be flipped to determine which player goes next and the game's state will be saved. You'll update the <code>Board</code>'s <code>handleClick</code> function to flip the value of <code>xIsNext</code>:</p> <pre><code>export default function Board() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick(i) {\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nsetSquares(nextSquares);\nsetXIsNext(!xIsNext);\n}\n\nreturn (\n//...\n);\n}\n</code></pre> <p>Now, as you click on different squares, they will alternate between <code>X</code> and <code>O</code>, as they should!</p> <p>But wait, there's a problem. Try clicking on the same square multiple times:</p> <p></p> <p>The <code>X</code> is overwritten by an <code>O</code>! While this would add a very interesting twist to the game, we're going to stick to the original rules for now.</p> <p>When you mark a square with a <code>X</code> or an <code>O</code> you aren't first checking to see if the square already has a <code>X</code> or <code>O</code> value. You can fix this by returning early. You'll check to see if the square already has a <code>X</code> or an <code>O</code>. If the square is already filled, you will <code>return</code> in the <code>handleClick</code> function early--before it tries to update the board state.</p> <pre><code>function handleClick(i) {\nif (squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\n//...\n}\n</code></pre> <p>Now you can only add <code>X</code>'s or <code>O</code>'s to empty squares! Here is what your code should look like at this point:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nexport default function Board() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick(i) {\nif (squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nsetSquares(nextSquares);\nsetXIsNext(!xIsNext);\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#declaring-a-winner","title":"Declaring a winner","text":"<p>Now that the players can take turns, you'll want to show when the game is won and there are no more turns to make. To do this you'll add a helper function called <code>calculateWinner</code> that takes an array of 9 squares, checks for a winner and returns <code>'X'</code>, <code>'O'</code>, or <code>null</code> as appropriate. Don't worry too much about the <code>calculateWinner</code> function; it's not specific to React:</p> <pre><code>export default function Board() {\n//...\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <p> <p>It does not matter whether you define <code>calculateWinner</code> before or after the <code>Board</code>. Let's put it at the end so that you don't have to scroll past it every time you edit your components.</p> <p></p> <p>You will call <code>calculateWinner(squares)</code> in the <code>Board</code> component's <code>handleClick</code> function to check if a player has won. You can perform this check at the same time you check if a user has clicked a square that already has a <code>X</code> or and <code>O</code>. We'd like to return early in both cases:</p> <pre><code>function handleClick(i) {\nif (squares[i] || calculateWinner(squares)) {\nreturn;\n}\nconst nextSquares = squares.slice();\n//...\n}\n</code></pre> <p>To let the players know when the game is over, you can display text such as \"Winner: X\" or \"Winner: O\". To do that you'll add a <code>status</code> section to the <code>Board</code> component. The status will display the winner if the game is over and if the game is ongoing you'll display which player's turn is next:</p> <pre><code>export default function Board() {\n// ...\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n// ...\n)\n}\n</code></pre> <p>Congratulations! You now have a working tic-tac-toe game. And you've just learned the basics of React too. So you are the real winner here. Here is what the code should look like:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nexport default function Board() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [squares, setSquares] = useState(Array(9).fill(null));\n\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nsetSquares(nextSquares);\nsetXIsNext(!xIsNext);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#adding-time-travel","title":"Adding time travel","text":"<p>As a final exercise, let's make it possible to \"go back in time\" to the previous moves in the game.</p>"},{"location":"learn/tutorial-tic-tac-toe/#storing-a-history-of-moves","title":"Storing a history of moves","text":"<p>If you mutated the <code>squares</code> array, implementing time travel would be very difficult.</p> <p>However, you used <code>slice()</code> to create a new copy of the <code>squares</code> array after every move, and treated it as immutable. This will allow you to store every past version of the <code>squares</code> array, and navigate between the turns that have already happened.</p> <p>You'll store the past <code>squares</code> arrays in another array called <code>history</code>, which you'll store as a new state variable. The <code>history</code> array represents all board states, from the first to the last move, and has a shape like this:</p> <pre><code>[\n// Before first move\n[null, null, null, null, null, null, null, null, null],\n// After first move\n[null, null, null, null, \"X\", null, null, null, null],\n// After second move\n[null, null, null, null, \"X\", null, null, null, \"O\"],\n// ...\n];\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#lifting-state-up-again","title":"Lifting state up, again","text":"<p>You will now write a new top-level component called <code>Game</code> to display a list of past moves. That's where you will place the <code>history</code> state that contains the entire game history.</p> <p>Placing the <code>history</code> state into the <code>Game</code> component will let you remove the <code>squares</code> state from its child <code>Board</code> component. Just like you \"lifted state up\" from the <code>Square</code> component into the <code>Board</code> component, you will now lift it up from the <code>Board</code> into the top-level <code>Game</code> component. This gives the <code>Game</code> component full control over the <code>Board</code>'s data and lets it instruct the <code>Board</code> to render previous turns from the <code>history</code>.</p> <p>First, add a <code>Game</code> component with <code>export default</code>. Have it render the <code>Board</code> component and some markup:</p> <pre><code>function Board() {\n// ...\n}\n\nexport default function Game() {\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board /&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{/*TODO*/}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Note that you are removing the <code>export default</code> keywords before the <code>function Board() {</code> declaration and adding them before the <code>function Game() {</code> declaration. This tells your <code>index.js</code> file to use the <code>Game</code> component as the top-level component instead of your <code>Board</code> component. The additional <code>div</code>s returned by the <code>Game</code> component are making room for the game information you'll add to the board later.</p> <p>Add some state to the <code>Game</code> component to track which player is next and the history of moves:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\n// ...\n</code></pre> <p>Notice how <code>[Array(9).fill(null)]</code> is an array with a single item, which itself is an array of 9 <code>null</code>s.</p> <p>To render the squares for the current move, you'll want to read the last squares array from the <code>history</code>. You don't need <code>useState</code> for this--you already have enough information to calculate it during rendering:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n// ...\n</code></pre> <p>Next, create a <code>handlePlay</code> function inside the <code>Game</code> component that will be called by the <code>Board</code> component to update the game. Pass <code>xIsNext</code>, <code>currentSquares</code> and <code>handlePlay</code> as props to the <code>Board</code> component:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n\nfunction handlePlay(nextSquares) {\n// TODO\n}\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} /&gt;\n//...\n)\n}\n</code></pre> <p>Let's make the <code>Board</code> component fully controlled by the props it receives. Change the <code>Board</code> component to take three props: <code>xIsNext</code>, <code>squares</code>, and a new <code>onPlay</code> function that <code>Board</code> can call with the updated squares array when a player makes a move. Next, remove the first two lines of the <code>Board</code> function that call <code>useState</code>:</p> <pre><code>function Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\n//...\n}\n// ...\n}\n</code></pre> <p>Now replace the <code>setSquares</code> and <code>setXIsNext</code> calls in <code>handleClick</code> in the <code>Board</code> component with a single call to your new <code>onPlay</code> function so the <code>Game</code> component can update the <code>Board</code> when the user clicks a square:</p> <pre><code>function Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n//...\n}\n</code></pre> <p>The <code>Board</code> component is fully controlled by the props passed to it by the <code>Game</code> component. You need to implement the <code>handlePlay</code> function in the <code>Game</code> component to get the game working again.</p> <p>What should <code>handlePlay</code> do when called? Remember that Board used to call <code>setSquares</code> with an updated array; now it passes the updated <code>squares</code> array to <code>onPlay</code>.</p> <p>The <code>handlePlay</code> function needs to update <code>Game</code>'s state to trigger a re-render, but you don't have a <code>setSquares</code> function that you can call any more--you're now using the <code>history</code> state variable to store this information. You'll want to update <code>history</code> by appending the updated <code>squares</code> array as a new history entry. You also want to toggle <code>xIsNext</code>, just as Board used to do:</p> <pre><code>export default function Game() {\n//...\nfunction handlePlay(nextSquares) {\nsetHistory([...history, nextSquares]);\nsetXIsNext(!xIsNext);\n}\n//...\n}\n</code></pre> <p>Here, <code>[...history, nextSquares]</code> creates a new array that contains all the items in <code>history</code>, followed by <code>nextSquares</code>. (You can read the <code>...history</code> spread syntax as \"enumerate all the items in <code>history</code>\".)</p> <p>For example, if <code>history</code> is <code>[[null,null,null], [\"X\",null,null]]</code> and <code>nextSquares</code> is <code>[\"X\",null,\"O\"]</code>, then the new <code>[...history, nextSquares]</code> array will be <code>[[null,null,null], [\"X\",null,null], [\"X\",null,\"O\"]]</code>.</p> <p>At this point, you've moved the state to live in the <code>Game</code> component, and the UI should be fully working, just as it was before the refactor. Here is what the code should look like at this point:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nexport default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n\nfunction handlePlay(nextSquares) {\nsetHistory([...history, nextSquares]);\nsetXIsNext(!xIsNext);\n}\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{/*TODO*/}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#showing-the-past-moves","title":"Showing the past moves","text":"<p>Since you are recording the tic-tac-toe game's history, you can now display a list of past moves to the player.</p> <p>React elements like <code>&lt;button&gt;</code> are regular JavaScript objects; you can pass them around in your application. To render multiple items in React, you can use an array of React elements.</p> <p>You already have an array of <code>history</code> moves in state, so now you need to transform it to an array of React elements. In JavaScript, to transform one array into another, you can use the array <code>map</code> method:</p> <pre><code>[1, 2, 3].map((x) =&gt; x * 2); // [2, 4, 6]\n</code></pre> <p>You'll use <code>map</code> to transform your <code>history</code> of moves into React elements representing buttons on the screen, and display a list of buttons to \"jump\" to past moves. Let's <code>map</code> over the <code>history</code> in the Game component:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n\nfunction handlePlay(nextSquares) {\nsetHistory([...history, nextSquares]);\nsetXIsNext(!xIsNext);\n}\n\nfunction jumpTo(nextMove) {\n// TODO\n}\n\nconst moves = history.map((squares, move) =&gt; {\nlet description;\nif (move &gt; 0) {\ndescription = \"Go to move #\" + move;\n} else {\ndescription = \"Go to game start\";\n}\nreturn (\n&lt;li&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{moves}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>You can see what your code should look like below. Note that you should see an error in the developer tools console that says: <code>Warning: Each child in an array or iterator should have a unique \"key\" prop. Check the render method of `Game`.</code> You'll fix this error in the next section.</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nexport default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n\nfunction handlePlay(nextSquares) {\nsetHistory([...history, nextSquares]);\nsetXIsNext(!xIsNext);\n}\n\nfunction jumpTo(nextMove) {\n// TODO\n}\n\nconst moves = history.map((squares, move) =&gt; {\nlet description;\nif (move &gt; 0) {\ndescription = \"Go to move #\" + move;\n} else {\ndescription = \"Go to game start\";\n}\nreturn (\n&lt;li&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{moves}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p>As you iterate through <code>history</code> array inside the function you passed to <code>map</code>, the <code>squares</code> argument goes through each element of <code>history</code>, and the <code>move</code> argument goes through each array index: <code>0</code>, <code>1</code>, <code>2</code>, \u2026. (In most cases, you'd need the actual array elements, but to render a list of moves you will only need indexes.)</p> <p>For each move in the tic-tac-toe game's history, you create a list item <code>&lt;li&gt;</code> which contains a button <code>&lt;button&gt;</code>. The button has an <code>on_click</code> handler which calls a function called <code>jumpTo</code> (that you haven't implemented yet).</p> <p>For now, you should see a list of the moves that occurred in the game and an error in the developer tools console. Let's discuss what the \"key\" error means.</p>"},{"location":"learn/tutorial-tic-tac-toe/#picking-a-key","title":"Picking a key","text":"<p>When you render a list, React stores some information about each rendered list item. When you update a list, React needs to determine what has changed. You could have added, removed, re-arranged, or updated the list's items.</p> <p>Imagine transitioning from</p> <pre><code>&lt;li&gt;Alexa: 7 tasks left&lt;/li&gt;\n&lt;li&gt;Ben: 5 tasks left&lt;/li&gt;\n</code></pre> <p>to</p> <pre><code>&lt;li&gt;Ben: 9 tasks left&lt;/li&gt;\n&lt;li&gt;Claudia: 8 tasks left&lt;/li&gt;\n&lt;li&gt;Alexa: 5 tasks left&lt;/li&gt;\n</code></pre> <p>In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Ben's ordering and inserted Claudia between Alexa and Ben. However, React is a computer program and can't know what you intended, so you need to specify a key property for each list item to differentiate each list item from its siblings. If your data was from a database, Alexa, Ben, and Claudia's database IDs could be used as keys.</p> <pre><code>&lt;li key={user.id}&gt;\n{user.name}: {user.taskCount} tasks left\n&lt;/li&gt;\n</code></pre> <p>When a list is re-rendered, React takes each list item's key and searches the previous list's items for a matching key. If the current list has a key that didn't exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved.</p> <p>Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a component's key changes, the component will be destroyed and re-created with a new state.</p> <p><code>key</code> is a special and reserved property in React. When an element is created, React extracts the <code>key</code> property and stores the key directly on the returned element. Even though <code>key</code> may look like it is passed as props, React automatically uses <code>key</code> to decide which components to update. There's no way for a component to ask what <code>key</code> its parent specified.</p> <p>It's strongly recommended that you assign proper keys whenever you build dynamic lists. If you don't have an appropriate key, you may want to consider restructuring your data so that you do.</p> <p>If no key is specified, React will report an error and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a list's items or inserting/removing list items. Explicitly passing <code>key={i}</code> silences the error but has the same problems as array indices and is not recommended in most cases.</p> <p>Keys do not need to be globally unique; they only need to be unique between components and their siblings.</p>"},{"location":"learn/tutorial-tic-tac-toe/#implementing-time-travel","title":"Implementing time travel","text":"<p>In the tic-tac-toe game's history, each past move has a unique ID associated with it: it's the sequential number of the move. Moves will never be re-ordered, deleted, or inserted in the middle, so it's safe to use the move index as a key.</p> <p>In the <code>Game</code> function, you can add the key as <code>&lt;li key={move}&gt;</code>, and if you reload the rendered game, React's \"key\" error should disappear:</p> <pre><code>const moves = history.map((squares, move) =&gt; {\n//...\nreturn (\n&lt;li key={move}&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n</code></pre> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nexport default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst currentSquares = history[history.length - 1];\n\nfunction handlePlay(nextSquares) {\nsetHistory([...history, nextSquares]);\nsetXIsNext(!xIsNext);\n}\n\nfunction jumpTo(nextMove) {\n// TODO\n}\n\nconst moves = history.map((squares, move) =&gt; {\nlet description;\nif (move &gt; 0) {\ndescription = \"Go to move #\" + move;\n} else {\ndescription = \"Go to game start\";\n}\nreturn (\n&lt;li key={move}&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{moves}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p>Before you can implement <code>jumpTo</code>, you need the <code>Game</code> component to keep track of which step the user is currently viewing. To do this, define a new state variable called <code>currentMove</code>, defaulting to <code>0</code>:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst [currentMove, setCurrentMove] = useState(0);\nconst currentSquares = history[history.length - 1];\n//...\n}\n</code></pre> <p>Next, update the <code>jumpTo</code> function inside <code>Game</code> to update that <code>currentMove</code>. You'll also set <code>xIsNext</code> to <code>true</code> if the number that you're changing <code>currentMove</code> to is even.</p> <pre><code>export default function Game() {\n// ...\nfunction jumpTo(nextMove) {\nsetCurrentMove(nextMove);\nsetXIsNext(nextMove % 2 === 0);\n}\n//...\n}\n</code></pre> <p>You will now make two changes to the <code>Game</code>'s <code>handlePlay</code> function which is called when you click on a square.</p> <ul> <li>If you \"go back in time\" and then make a new move from that point, you only want to keep the history up to that point. Instead of adding <code>nextSquares</code> after all items (<code>...</code> spread syntax) in <code>history</code>, you'll add it after all items in <code>history.slice(0, currentMove + 1)</code> so that you're only keeping that portion of the old history.</li> <li>Each time a move is made, you need to update <code>currentMove</code> to point to the latest history entry.</li> </ul> <pre><code>function handlePlay(nextSquares) {\nconst nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\nsetHistory(nextHistory);\nsetCurrentMove(nextHistory.length - 1);\nsetXIsNext(!xIsNext);\n}\n</code></pre> <p>Finally, you will modify the <code>Game</code> component to render the currently selected move, instead of always rendering the final move:</p> <pre><code>export default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst [currentMove, setCurrentMove] = useState(0);\nconst currentSquares = history[currentMove];\n\n// ...\n}\n</code></pre> <p>If you click on any step in the game's history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred.</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nexport default function Game() {\nconst [xIsNext, setXIsNext] = useState(true);\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst [currentMove, setCurrentMove] = useState(0);\nconst currentSquares = history[currentMove];\n\nfunction handlePlay(nextSquares) {\nconst nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\nsetHistory(nextHistory);\nsetCurrentMove(nextHistory.length - 1);\nsetXIsNext(!xIsNext);\n}\n\nfunction jumpTo(nextMove) {\nsetCurrentMove(nextMove);\nsetXIsNext(nextMove % 2 === 0);\n}\n\nconst moves = history.map((squares, move) =&gt; {\nlet description;\nif (move &gt; 0) {\ndescription = \"Go to move #\" + move;\n} else {\ndescription = \"Go to game start\";\n}\nreturn (\n&lt;li key={move}&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{moves}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre>"},{"location":"learn/tutorial-tic-tac-toe/#final-cleanup","title":"Final cleanup","text":"<p>If you look at the code very closely, you may notice that <code>xIsNext === true</code> when <code>currentMove</code> is even and <code>xIsNext === false</code> when <code>currentMove</code> is odd. In other words, if you know the value of <code>currentMove</code>, then you can always figure out what <code>xIsNext</code> should be.</p> <p>There's no reason for you to store both of these in state. In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand. Change <code>Game</code> so that it doesn't store <code>xIsNext</code> as a separate state variable and instead figures it out based on the <code>currentMove</code>:</p> <pre><code>export default function Game() {\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst [currentMove, setCurrentMove] = useState(0);\nconst xIsNext = currentMove % 2 === 0;\nconst currentSquares = history[currentMove];\n\nfunction handlePlay(nextSquares) {\nconst nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\nsetHistory(nextHistory);\nsetCurrentMove(nextHistory.length - 1);\n}\n\nfunction jumpTo(nextMove) {\nsetCurrentMove(nextMove);\n}\n// ...\n}\n</code></pre> <p>You no longer need the <code>xIsNext</code> state declaration or the calls to <code>setXIsNext</code>. Now, there's no chance for <code>xIsNext</code> to get out of sync with <code>currentMove</code>, even if you make a mistake while coding the components.</p>"},{"location":"learn/tutorial-tic-tac-toe/#wrapping-up","title":"Wrapping up","text":"<p>Congratulations! You've created a tic-tac-toe game that:</p> <ul> <li>Lets you play tic-tac-toe,</li> <li>Indicates when a player has won the game,</li> <li>Stores a game's history as a game progresses,</li> <li>Allows players to review a game's history and see previous versions of a game's board.</li> </ul> <p>Nice work! We hope you now feel like you have a decent grasp of how React works.</p> <p>Check out the final result here:</p> <pre><code>import { useState } from \"react\";\n\nfunction Square({ value, onSquareClick }) {\nreturn (\n&lt;button className=\"square\" on_click={onSquareClick}&gt;\n{value}\n&lt;/button&gt;\n);\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\nfunction handleClick(i) {\nif (calculateWinner(squares) || squares[i]) {\nreturn;\n}\nconst nextSquares = squares.slice();\nif (xIsNext) {\nnextSquares[i] = \"X\";\n} else {\nnextSquares[i] = \"O\";\n}\nonPlay(nextSquares);\n}\n\nconst winner = calculateWinner(squares);\nlet status;\nif (winner) {\nstatus = \"Winner: \" + winner;\n} else {\nstatus = \"Next player: \" + (xIsNext ? \"X\" : \"O\");\n}\n\nreturn (\n&lt;&gt;\n&lt;div className=\"status\"&gt;{status}&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[0]}\nonSquareClick={() =&gt; handleClick(0)}\n/&gt;\n&lt;Square\nvalue={squares[1]}\nonSquareClick={() =&gt; handleClick(1)}\n/&gt;\n&lt;Square\nvalue={squares[2]}\nonSquareClick={() =&gt; handleClick(2)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[3]}\nonSquareClick={() =&gt; handleClick(3)}\n/&gt;\n&lt;Square\nvalue={squares[4]}\nonSquareClick={() =&gt; handleClick(4)}\n/&gt;\n&lt;Square\nvalue={squares[5]}\nonSquareClick={() =&gt; handleClick(5)}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"board-row\"&gt;\n&lt;Square\nvalue={squares[6]}\nonSquareClick={() =&gt; handleClick(6)}\n/&gt;\n&lt;Square\nvalue={squares[7]}\nonSquareClick={() =&gt; handleClick(7)}\n/&gt;\n&lt;Square\nvalue={squares[8]}\nonSquareClick={() =&gt; handleClick(8)}\n/&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n\nexport default function Game() {\nconst [history, setHistory] = useState([Array(9).fill(null)]);\nconst [currentMove, setCurrentMove] = useState(0);\nconst xIsNext = currentMove % 2 === 0;\nconst currentSquares = history[currentMove];\n\nfunction handlePlay(nextSquares) {\nconst nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\nsetHistory(nextHistory);\nsetCurrentMove(nextHistory.length - 1);\n}\n\nfunction jumpTo(nextMove) {\nsetCurrentMove(nextMove);\n}\n\nconst moves = history.map((squares, move) =&gt; {\nlet description;\nif (move &gt; 0) {\ndescription = \"Go to move #\" + move;\n} else {\ndescription = \"Go to game start\";\n}\nreturn (\n&lt;li key={move}&gt;\n&lt;button on_click={() =&gt; jumpTo(move)}&gt;{description}&lt;/button&gt;\n&lt;/li&gt;\n);\n});\n\nreturn (\n&lt;div className=\"game\"&gt;\n&lt;div className=\"game-board\"&gt;\n&lt;Board\nxIsNext={xIsNext}\nsquares={currentSquares}\nonPlay={handlePlay}\n/&gt;\n&lt;/div&gt;\n&lt;div className=\"game-info\"&gt;\n&lt;ol&gt;{moves}&lt;/ol&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n}\n\nfunction calculateWinner(squares) {\nconst lines = [\n[0, 1, 2],\n[3, 4, 5],\n[6, 7, 8],\n[0, 3, 6],\n[1, 4, 7],\n[2, 5, 8],\n[0, 4, 8],\n[2, 4, 6],\n];\nfor (let i = 0; i &lt; lines.length; i++) {\nconst [a, b, c] = lines[i];\nif (\nsquares[a] &amp;&amp;\nsquares[a] === squares[b] &amp;&amp;\nsquares[a] === squares[c]\n) {\nreturn squares[a];\n}\n}\nreturn null;\n}\n</code></pre> <pre><code>* {\nbox-sizing: border-box;\n}\n\nbody {\nfont-family: sans-serif;\nmargin: 20px;\npadding: 0;\n}\n\n.square {\nbackground: #fff;\nborder: 1px solid #999;\nfloat: left;\nfont-size: 24px;\nfont-weight: bold;\nline-height: 34px;\nheight: 34px;\nmargin-right: -1px;\nmargin-top: -1px;\npadding: 0;\ntext-align: center;\nwidth: 34px;\n}\n\n.board-row:after {\nclear: both;\ncontent: \"\";\ndisplay: table;\n}\n\n.status {\nmargin-bottom: 10px;\n}\n.game {\ndisplay: flex;\nflex-direction: row;\n}\n\n.game-info {\nmargin-left: 20px;\n}\n</code></pre> <p>If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty:</p> <ol> <li>For the current move only, show \"You are at move #...\" instead of a button.</li> <li>Rewrite <code>Board</code> to use two loops to make the squares instead of hardcoding them.</li> <li>Add a toggle button that lets you sort the moves in either ascending or descending order.</li> <li>When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw).</li> <li>Display the location for each move in the format (row, col) in the move history list.</li> </ol> <p>Throughout this tutorial, you've touched on React concepts including elements, components, props, and state. Now that you've seen how these concepts work when building a game, check out Thinking in React to see how the same React concepts work when build an app's UI.</p>"},{"location":"learn/updating-arrays-in-state/","title":"Updating Arrays in State \ud83d\udea7","text":""},{"location":"learn/updating-arrays-in-state/#overview","title":"Overview","text":"<p>  Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.  </p> <p>You will learn</p> <ul> <li>How to add, remove, or change items in an array in React state</li> <li>How to update an object inside of an array</li> <li>How to make array copying less repetitive with Immer</li> </ul>"},{"location":"learn/updating-arrays-in-state/#updating-arrays-without-mutation","title":"Updating arrays without mutation","text":"<p>In JavaScript, arrays are just another kind of object. Like with objects, you should treat arrays in React state as read-only. This means that you shouldn't reassign items inside an array like <code>arr[0] = 'bird'</code>, and you also shouldn't use methods that mutate the array, such as <code>push()</code> and <code>pop()</code>.</p> <p>Instead, every time you want to update an array, you'll want to pass a new array to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods like <code>filter()</code> and <code>map()</code>. Then you can set your state to the resulting new array.</p> <p>Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:</p> avoid (mutates the array) prefer (returns a new array) adding <code>push</code>, <code>unshift</code> <code>concat</code>, <code>[...arr]</code> spread syntax (example) removing <code>pop</code>, <code>shift</code>, <code>splice</code> <code>filter</code>, <code>slice</code> (example) replacing <code>splice</code>, <code>arr[i] = ...</code> assignment <code>map</code> (example) sorting <code>reverse</code>, <code>sort</code> copy the array first (example) <p>Alternatively, you can use Immer which lets you use methods from both columns.</p> <p> <p>Unfortunately, <code>slice</code> and <code>splice</code> are named similarly but are very different:</p> <ul> <li><code>slice</code> lets you copy an array or a part of it.</li> <li><code>splice</code> mutates the array (to insert or delete items).</li> </ul> <p>In React, you will be using <code>slice</code> (no <code>p</code>!) a lot more often because you don't want to mutate objects or arrays in state. Updating Objects explains what mutation is and why it's not recommended for state.</p> <p></p>"},{"location":"learn/updating-arrays-in-state/#adding-to-an-array","title":"Adding to an array","text":"<p><code>push()</code> will mutate an array, which you don't want:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 0;\n\nexport default function List() {\nconst [name, setName] = useState(\"\");\nconst [artists, setArtists] = useState([]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Inspiring sculptors:&lt;/h1&gt;\n&lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;\n&lt;button\non_click={() =&gt; {\nartists.push({\nid: nextId++,\nname: name,\n});\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{artists.map((artist) =&gt; (\n&lt;li key={artist.id}&gt;{artist.name}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-left: 5px;\n}\n</code></pre> <p>Instead, create a new array which contains the existing items and a new item at the end. There are multiple ways to do this, but the easiest one is to use the <code>...</code> array spread syntax:</p> <pre><code>setArtists(\n// Replace the state\n[\n// with a new array\n...artists, // that contains all the old items\n{ id: nextId++, name: name }, // and one new item at the end\n]\n);\n</code></pre> <p>Now it works correctly:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 0;\n\nexport default function List() {\nconst [name, setName] = useState(\"\");\nconst [artists, setArtists] = useState([]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Inspiring sculptors:&lt;/h1&gt;\n&lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;\n&lt;button\non_click={() =&gt; {\nsetArtists([...artists, { id: nextId++, name: name }]);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{artists.map((artist) =&gt; (\n&lt;li key={artist.id}&gt;{artist.name}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-left: 5px;\n}\n</code></pre> <p>The array spread syntax also lets you prepend an item by placing it before the original <code>...artists</code>:</p> <pre><code>setArtists([\n{ id: nextId++, name: name },\n...artists, // Put old items at the end\n]);\n</code></pre> <p>In this way, spread can do the job of both <code>push()</code> by adding to the end of an array and <code>unshift()</code> by adding to the beginning of an array. Try it in the sandbox above!</p>"},{"location":"learn/updating-arrays-in-state/#removing-from-an-array","title":"Removing from an array","text":"<p>The easiest way to remove an item from an array is to filter it out. In other words, you will produce a new array that will not contain that item. To do this, use the <code>filter</code> method, for example:</p> <pre><code>import { useState } from \"react\";\n\nlet initialArtists = [\n{ id: 0, name: \"Marta Colvin Andrade\" },\n{ id: 1, name: \"Lamidi Olonade Fakeye\" },\n{ id: 2, name: \"Louise Nevelson\" },\n];\n\nexport default function List() {\nconst [artists, setArtists] = useState(initialArtists);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Inspiring sculptors:&lt;/h1&gt;\n&lt;ul&gt;\n{artists.map((artist) =&gt; (\n&lt;li key={artist.id}&gt;\n{artist.name}{\" \"}\n&lt;button\non_click={() =&gt; {\nsetArtists(\nartists.filter((a) =&gt; a.id !== artist.id)\n);\n}}\n&gt;\nDelete\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Click the \"Delete\" button a few times, and look at its click handler.</p> <pre><code>setArtists(artists.filter((a) =&gt; a.id !== artist.id));\n</code></pre> <p>Here, <code>artists.filter(a =&gt; a.id !== artist.id)</code> means \"create an array that consists of those <code>artists</code> whose IDs are different from <code>artist.id</code>\". In other words, each artist's \"Delete\" button will filter that artist out of the array, and then request a re-render with the resulting array. Note that <code>filter</code> does not modify the original array.</p>"},{"location":"learn/updating-arrays-in-state/#transforming-an-array","title":"Transforming an array","text":"<p>If you want to change some or all items of the array, you can use <code>map()</code> to create a new array. The function you will pass to <code>map</code> can decide what to do with each item, based on its data or its index (or both).</p> <p>In this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data using <code>map()</code>:</p> <pre><code>import { useState } from \"react\";\n\nlet initialShapes = [\n{ id: 0, type: \"circle\", x: 50, y: 100 },\n{ id: 1, type: \"square\", x: 150, y: 100 },\n{ id: 2, type: \"circle\", x: 250, y: 100 },\n];\n\nexport default function ShapeEditor() {\nconst [shapes, setShapes] = useState(initialShapes);\n\nfunction handleClick() {\nconst nextShapes = shapes.map((shape) =&gt; {\nif (shape.type === \"square\") {\n// No change\nreturn shape;\n} else {\n// Return a new circle 50px below\nreturn {\n...shape,\ny: shape.y + 50,\n};\n}\n});\n// Re-render with the new array\nsetShapes(nextShapes);\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Move circles down!&lt;/button&gt;\n{shapes.map((shape) =&gt; (\n&lt;div\nkey={shape.id}\nstyle={{\nbackground: \"purple\",\nposition: \"absolute\",\nleft: shape.x,\ntop: shape.y,\nborderRadius: shape.type === \"circle\" ? \"50%\" : \"\",\nwidth: 20,\nheight: 20,\n}}\n/&gt;\n))}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 300px;\n}\n</code></pre>"},{"location":"learn/updating-arrays-in-state/#replacing-items-in-an-array","title":"Replacing items in an array","text":"<p>It is particularly common to want to replace one or more items in an array. Assignments like <code>arr[0] = 'bird'</code> are mutating the original array, so instead you'll want to use <code>map</code> for this as well.</p> <p>To replace an item, create a new array with <code>map</code>. Inside your <code>map</code> call, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:</p> <pre><code>import { useState } from \"react\";\n\nlet initialCounters = [0, 0, 0];\n\nexport default function CounterList() {\nconst [counters, setCounters] = useState(initialCounters);\n\nfunction handleIncrementClick(index) {\nconst nextCounters = counters.map((c, i) =&gt; {\nif (i === index) {\n// Increment the clicked counter\nreturn c + 1;\n} else {\n// The rest haven't changed\nreturn c;\n}\n});\nsetCounters(nextCounters);\n}\n\nreturn (\n&lt;ul&gt;\n{counters.map((counter, i) =&gt; (\n&lt;li key={i}&gt;\n{counter}\n&lt;button\non_click={() =&gt; {\nhandleIncrementClick(i);\n}}\n&gt;\n+1\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre>"},{"location":"learn/updating-arrays-in-state/#inserting-into-an-array","title":"Inserting into an array","text":"<p>Sometimes, you may want to insert an item at a particular position that's neither at the beginning nor at the end. To do this, you can use the <code>...</code> array spread syntax together with the <code>slice()</code> method. The <code>slice()</code> method lets you cut a \"slice\" of the array. To insert an item, you will create an array that spreads the slice before the insertion point, then the new item, and then the rest of the original array.</p> <p>In this example, the Insert button always inserts at the index <code>1</code>:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 3;\nconst initialArtists = [\n{ id: 0, name: \"Marta Colvin Andrade\" },\n{ id: 1, name: \"Lamidi Olonade Fakeye\" },\n{ id: 2, name: \"Louise Nevelson\" },\n];\n\nexport default function List() {\nconst [name, setName] = useState(\"\");\nconst [artists, setArtists] = useState(initialArtists);\n\nfunction handleClick() {\nconst insertAt = 1; // Could be any index\nconst nextArtists = [\n// Items before the insertion point:\n...artists.slice(0, insertAt),\n// New item:\n{ id: nextId++, name: name },\n// Items after the insertion point:\n...artists.slice(insertAt),\n];\nsetArtists(nextArtists);\nsetName(\"\");\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Inspiring sculptors:&lt;/h1&gt;\n&lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;\n&lt;button on_click={handleClick}&gt;Insert&lt;/button&gt;\n&lt;ul&gt;\n{artists.map((artist) =&gt; (\n&lt;li key={artist.id}&gt;{artist.name}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-left: 5px;\n}\n</code></pre>"},{"location":"learn/updating-arrays-in-state/#making-other-changes-to-an-array","title":"Making other changes to an array","text":"<p>There are some things you can't do with the spread syntax and non-mutating methods like <code>map()</code> and <code>filter()</code> alone. For example, you may want to reverse or sort an array. The JavaScript <code>reverse()</code> and <code>sort()</code> methods are mutating the original array, so you can't use them directly.</p> <p>However, you can copy the array first, and then make changes to it.</p> <p>For example:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 3;\nconst initialList = [\n{ id: 0, title: \"Big Bellies\" },\n{ id: 1, title: \"Lunar Landscape\" },\n{ id: 2, title: \"Terracotta Army\" },\n];\n\nexport default function List() {\nconst [list, setList] = useState(initialList);\n\nfunction handleClick() {\nconst nextList = [...list];\nnextList.reverse();\nsetList(nextList);\n}\n\nreturn (\n&lt;&gt;\n&lt;button on_click={handleClick}&gt;Reverse&lt;/button&gt;\n&lt;ul&gt;\n{list.map((artwork) =&gt; (\n&lt;li key={artwork.id}&gt;{artwork.title}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p>Here, you use the <code>[...list]</code> spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods like <code>nextList.reverse()</code> or <code>nextList.sort()</code>, or even assign individual items with <code>nextList[0] = \"something\"</code>.</p> <p>However, even if you copy an array, you can't mutate existing items inside of it directly. This is because copying is shallow--the new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem.</p> <pre><code>const nextList = [...list];\nnextList[0].seen = true; // Problem: mutates list[0]\nsetList(nextList);\n</code></pre> <p>Although <code>nextList</code> and <code>list</code> are two different arrays, <code>nextList[0]</code> and <code>list[0]</code> point to the same object. So by changing <code>nextList[0].seen</code>, you are also changing <code>list[0].seen</code>. This is a state mutation, which you should avoid! You can solve this issue in a similar way to updating nested JavaScript objects--by copying individual items you want to change instead of mutating them. Here's how.</p>"},{"location":"learn/updating-arrays-in-state/#updating-objects-inside-arrays","title":"Updating objects inside arrays","text":"<p>Objects are not really located \"inside\" arrays. They might appear to be \"inside\" in code, but each object in an array is a separate value, to which the array \"points\". This is why you need to be careful when changing nested fields like <code>list[0]</code>. Another person's artwork list may point to the same element of the array!</p> <p>When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level. Let's see how this works.</p> <p>In this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 3;\nconst initialList = [\n{ id: 0, title: \"Big Bellies\", seen: false },\n{ id: 1, title: \"Lunar Landscape\", seen: false },\n{ id: 2, title: \"Terracotta Army\", seen: true },\n];\n\nexport default function BucketList() {\nconst [myList, setMyList] = useState(initialList);\nconst [yourList, setYourList] = useState(initialList);\n\nfunction handleToggleMyList(artworkId, nextSeen) {\nconst myNextList = [...myList];\nconst artwork = myNextList.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen;\nsetMyList(myNextList);\n}\n\nfunction handleToggleYourList(artworkId, nextSeen) {\nconst yourNextList = [...yourList];\nconst artwork = yourNextList.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen;\nsetYourList(yourNextList);\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Art Bucket List&lt;/h1&gt;\n&lt;h2&gt;My list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt;\n&lt;h2&gt;Your list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction ItemList({ artworks, onToggle }) {\nreturn (\n&lt;ul&gt;\n{artworks.map((artwork) =&gt; (\n&lt;li key={artwork.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={artwork.seen}\nonChange={(e) =&gt; {\nonToggle(artwork.id, e.target.checked);\n}}\n/&gt;\n{artwork.title}\n&lt;/label&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <p>The problem is in code like this:</p> <pre><code>const myNextList = [...myList];\nconst artwork = myNextList.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen; // Problem: mutates an existing item\nsetMyList(myNextList);\n</code></pre> <p>Although the <code>myNextList</code> array itself is new, the items themselves are the same as in the original <code>myList</code> array. So changing <code>artwork.seen</code> changes the original artwork item. That artwork item is also in <code>yourList</code>, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state.</p> <p>You can use <code>map</code> to substitute an old item with its updated version without mutation.</p> <pre><code>setMyList(\nmyList.map((artwork) =&gt; {\nif (artwork.id === artworkId) {\n// Create a *new* object with changes\nreturn { ...artwork, seen: nextSeen };\n} else {\n// No changes\nreturn artwork;\n}\n})\n);\n</code></pre> <p>Here, <code>...</code> is the object spread syntax used to create a copy of an object.</p> <p>With this approach, none of the existing state items are being mutated, and the bug is fixed:</p> <pre><code>import { useState } from \"react\";\n\nlet nextId = 3;\nconst initialList = [\n{ id: 0, title: \"Big Bellies\", seen: false },\n{ id: 1, title: \"Lunar Landscape\", seen: false },\n{ id: 2, title: \"Terracotta Army\", seen: true },\n];\n\nexport default function BucketList() {\nconst [myList, setMyList] = useState(initialList);\nconst [yourList, setYourList] = useState(initialList);\n\nfunction handleToggleMyList(artworkId, nextSeen) {\nsetMyList(\nmyList.map((artwork) =&gt; {\nif (artwork.id === artworkId) {\n// Create a *new* object with changes\nreturn { ...artwork, seen: nextSeen };\n} else {\n// No changes\nreturn artwork;\n}\n})\n);\n}\n\nfunction handleToggleYourList(artworkId, nextSeen) {\nsetYourList(\nyourList.map((artwork) =&gt; {\nif (artwork.id === artworkId) {\n// Create a *new* object with changes\nreturn { ...artwork, seen: nextSeen };\n} else {\n// No changes\nreturn artwork;\n}\n})\n);\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Art Bucket List&lt;/h1&gt;\n&lt;h2&gt;My list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt;\n&lt;h2&gt;Your list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction ItemList({ artworks, onToggle }) {\nreturn (\n&lt;ul&gt;\n{artworks.map((artwork) =&gt; (\n&lt;li key={artwork.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={artwork.seen}\nonChange={(e) =&gt; {\nonToggle(artwork.id, e.target.checked);\n}}\n/&gt;\n{artwork.title}\n&lt;/label&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <p>In general, you should only mutate objects that you have just created. If you were inserting a new artwork, you could mutate it, but if you're dealing with something that's already in state, you need to make a copy.</p>"},{"location":"learn/updating-arrays-in-state/#write-concise-update-logic-with-immer","title":"Write concise update logic with Immer","text":"<p>Updating nested arrays without mutation can get a little bit repetitive. Just as with objects:</p> <ul> <li>Generally, you shouldn't need to update state more than a couple of levels deep. If your state objects are very deep, you might want to restructure them differently so that they are flat.</li> <li>If you don't want to change your state structure, you might prefer to use Immer, which lets you write using the convenient but mutating syntax and takes care of producing the copies for you.</li> </ul> <p>Here is the Art Bucket List example rewritten with Immer:</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\n\nlet nextId = 3;\nconst initialList = [\n{ id: 0, title: \"Big Bellies\", seen: false },\n{ id: 1, title: \"Lunar Landscape\", seen: false },\n{ id: 2, title: \"Terracotta Army\", seen: true },\n];\n\nexport default function BucketList() {\nconst [myList, updateMyList] = useImmer(initialList);\nconst [yourList, updateYourList] = useImmer(initialList);\n\nfunction handleToggleMyList(id, nextSeen) {\nupdateMyList((draft) =&gt; {\nconst artwork = draft.find((a) =&gt; a.id === id);\nartwork.seen = nextSeen;\n});\n}\n\nfunction handleToggleYourList(artworkId, nextSeen) {\nupdateYourList((draft) =&gt; {\nconst artwork = draft.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen;\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Art Bucket List&lt;/h1&gt;\n&lt;h2&gt;My list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt;\n&lt;h2&gt;Your list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction ItemList({ artworks, onToggle }) {\nreturn (\n&lt;ul&gt;\n{artworks.map((artwork) =&gt; (\n&lt;li key={artwork.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={artwork.seen}\nonChange={(e) =&gt; {\nonToggle(artwork.id, e.target.checked);\n}}\n/&gt;\n{artwork.title}\n&lt;/label&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p>Note how with Immer, mutation like <code>artwork.seen = nextSeen</code> is now okay:</p> <pre><code>updateMyTodos((draft) =&gt; {\nconst artwork = draft.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen;\n});\n</code></pre> <p>This is because you're not mutating the original state, but you're mutating a special <code>draft</code> object provided by Immer. Similarly, you can apply mutating methods like <code>push()</code> and <code>pop()</code> to the content of the <code>draft</code>.</p> <p>Behind the scenes, Immer always constructs the next state from scratch according to the changes that you've done to the <code>draft</code>. This keeps your event handlers very concise without ever mutating state.</p> <p> <ul> <li>You can put arrays into state, but you can't change them.</li> <li>Instead of mutating an array, create a new version of it, and update the state to it.</li> <li>You can use the <code>[...arr, newItem]</code> array spread syntax to create arrays with new items.</li> <li>You can use <code>filter()</code> and <code>map()</code> to create new arrays with filtered or transformed items.</li> <li>You can use Immer to keep your code concise.</li> </ul> <p></p> <p>"},{"location":"learn/updating-arrays-in-state/#update-an-item-in-the-shopping-cart","title":"Update an item in the shopping cart","text":"<p>Fill in the <code>handleIncreaseClick</code> logic so that pressing \"+\" increases the corresponding number:</p> <pre><code>import { useState } from \"react\";\n\nconst initialProducts = [\n{\nid: 0,\nname: \"Baklava\",\ncount: 1,\n},\n{\nid: 1,\nname: \"Cheese\",\ncount: 5,\n},\n{\nid: 2,\nname: \"Spaghetti\",\ncount: 2,\n},\n];\n\nexport default function ShoppingCart() {\nconst [products, setProducts] = useState(initialProducts);\n\nfunction handleIncreaseClick(productId) {}\n\nreturn (\n&lt;ul&gt;\n{products.map((product) =&gt; (\n&lt;li key={product.id}&gt;\n{product.name} (&lt;b&gt;{product.count}&lt;/b&gt;)\n&lt;button\non_click={() =&gt; {\nhandleIncreaseClick(product.id);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p> <p>You can use the <code>map</code> function to create a new array, and then use the <code>...</code> object spread syntax to create a copy of the changed object for the new array:</p> <pre><code>import { useState } from \"react\";\n\nconst initialProducts = [\n{\nid: 0,\nname: \"Baklava\",\ncount: 1,\n},\n{\nid: 1,\nname: \"Cheese\",\ncount: 5,\n},\n{\nid: 2,\nname: \"Spaghetti\",\ncount: 2,\n},\n];\n\nexport default function ShoppingCart() {\nconst [products, setProducts] = useState(initialProducts);\n\nfunction handleIncreaseClick(productId) {\nsetProducts(\nproducts.map((product) =&gt; {\nif (product.id === productId) {\nreturn {\n...product,\ncount: product.count + 1,\n};\n} else {\nreturn product;\n}\n})\n);\n}\n\nreturn (\n&lt;ul&gt;\n{products.map((product) =&gt; (\n&lt;li key={product.id}&gt;\n{product.name} (&lt;b&gt;{product.count}&lt;/b&gt;)\n&lt;button\non_click={() =&gt; {\nhandleIncreaseClick(product.id);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p></p>"},{"location":"learn/updating-arrays-in-state/#remove-an-item-from-the-shopping-cart","title":"Remove an item from the shopping cart","text":"<p>This shopping cart has a working \"+\" button, but the \"\u2013\" button doesn't do anything. You need to add an event handler to it so that pressing it decreases the <code>count</code> of the corresponding product. If you press \"\u2013\" when the count is 1, the product should automatically get removed from the cart. Make sure it never shows 0.</p> <pre><code>import { useState } from \"react\";\n\nconst initialProducts = [\n{\nid: 0,\nname: \"Baklava\",\ncount: 1,\n},\n{\nid: 1,\nname: \"Cheese\",\ncount: 5,\n},\n{\nid: 2,\nname: \"Spaghetti\",\ncount: 2,\n},\n];\n\nexport default function ShoppingCart() {\nconst [products, setProducts] = useState(initialProducts);\n\nfunction handleIncreaseClick(productId) {\nsetProducts(\nproducts.map((product) =&gt; {\nif (product.id === productId) {\nreturn {\n...product,\ncount: product.count + 1,\n};\n} else {\nreturn product;\n}\n})\n);\n}\n\nreturn (\n&lt;ul&gt;\n{products.map((product) =&gt; (\n&lt;li key={product.id}&gt;\n{product.name} (&lt;b&gt;{product.count}&lt;/b&gt;)\n&lt;button\non_click={() =&gt; {\nhandleIncreaseClick(product.id);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;button&gt;\u2013&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p> <p>You can first use <code>map</code> to produce a new array, and then <code>filter</code> to remove products with a <code>count</code> set to <code>0</code>:</p> <pre><code>import { useState } from \"react\";\n\nconst initialProducts = [\n{\nid: 0,\nname: \"Baklava\",\ncount: 1,\n},\n{\nid: 1,\nname: \"Cheese\",\ncount: 5,\n},\n{\nid: 2,\nname: \"Spaghetti\",\ncount: 2,\n},\n];\n\nexport default function ShoppingCart() {\nconst [products, setProducts] = useState(initialProducts);\n\nfunction handleIncreaseClick(productId) {\nsetProducts(\nproducts.map((product) =&gt; {\nif (product.id === productId) {\nreturn {\n...product,\ncount: product.count + 1,\n};\n} else {\nreturn product;\n}\n})\n);\n}\n\nfunction handleDecreaseClick(productId) {\nlet nextProducts = products.map((product) =&gt; {\nif (product.id === productId) {\nreturn {\n...product,\ncount: product.count - 1,\n};\n} else {\nreturn product;\n}\n});\nnextProducts = nextProducts.filter((p) =&gt; p.count &gt; 0);\nsetProducts(nextProducts);\n}\n\nreturn (\n&lt;ul&gt;\n{products.map((product) =&gt; (\n&lt;li key={product.id}&gt;\n{product.name} (&lt;b&gt;{product.count}&lt;/b&gt;)\n&lt;button\non_click={() =&gt; {\nhandleIncreaseClick(product.id);\n}}\n&gt;\n+\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nhandleDecreaseClick(product.id);\n}}\n&gt;\n\u2013\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p></p>"},{"location":"learn/updating-arrays-in-state/#fix-the-mutations-using-non-mutative-methods","title":"Fix the mutations using non-mutative methods","text":"<p>In this example, all of the event handlers in <code>App.js</code> use mutation. As a result, editing and deleting todos doesn't work. Rewrite <code>handleAddTodo</code>, <code>handleChangeTodo</code>, and <code>handleDeleteTodo</code> to use the non-mutative methods:</p> <pre><code>import { useState } from \"react\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAddTodo(title) {\ntodos.push({\nid: nextId++,\ntitle: title,\ndone: false,\n});\n}\n\nfunction handleChangeTodo(nextTodo) {\nconst todo = todos.find((t) =&gt; t.id === nextTodo.id);\ntodo.title = nextTodo.title;\ntodo.done = nextTodo.done;\n}\n\nfunction handleDeleteTodo(todoId) {\nconst index = todos.findIndex((t) =&gt; t.id === todoId);\ntodos.splice(index, 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button on_click={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p> <p>In <code>handleAddTodo</code>, you can use the array spread syntax. In <code>handleChangeTodo</code>, you can create a new array with <code>map</code>. In <code>handleDeleteTodo</code>, you can create a new array with <code>filter</code>. Now the list works correctly:</p> <pre><code>import { useState } from \"react\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAddTodo(title) {\nsetTodos([\n...todos,\n{\nid: nextId++,\ntitle: title,\ndone: false,\n},\n]);\n}\n\nfunction handleChangeTodo(nextTodo) {\nsetTodos(\ntodos.map((t) =&gt; {\nif (t.id === nextTodo.id) {\nreturn nextTodo;\n} else {\nreturn t;\n}\n})\n);\n}\n\nfunction handleDeleteTodo(todoId) {\nsetTodos(todos.filter((t) =&gt; t.id !== todoId));\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button on_click={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p></p>"},{"location":"learn/updating-arrays-in-state/#fix-the-mutations-using-immer","title":"Fix the mutations using Immer","text":"<p>This is the same example as in the previous challenge. This time, fix the mutations by using Immer. For your convenience, <code>useImmer</code> is already imported, so you need to change the <code>todos</code> state variable to use it.</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAddTodo(title) {\ntodos.push({\nid: nextId++,\ntitle: title,\ndone: false,\n});\n}\n\nfunction handleChangeTodo(nextTodo) {\nconst todo = todos.find((t) =&gt; t.id === nextTodo.id);\ntodo.title = nextTodo.title;\ntodo.done = nextTodo.done;\n}\n\nfunction handleDeleteTodo(todoId) {\nconst index = todos.findIndex((t) =&gt; t.id === todoId);\ntodos.splice(index, 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button on_click={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p> <p>With Immer, you can write code in the mutative fashion, as long as you're only mutating parts of the <code>draft</code> that Immer gives you. Here, all mutations are performed on the <code>draft</code> so the code works:</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, updateTodos] = useImmer(initialTodos);\n\nfunction handleAddTodo(title) {\nupdateTodos((draft) =&gt; {\ndraft.push({\nid: nextId++,\ntitle: title,\ndone: false,\n});\n});\n}\n\nfunction handleChangeTodo(nextTodo) {\nupdateTodos((draft) =&gt; {\nconst todo = draft.find((t) =&gt; t.id === nextTodo.id);\ntodo.title = nextTodo.title;\ntodo.done = nextTodo.done;\n});\n}\n\nfunction handleDeleteTodo(todoId) {\nupdateTodos((draft) =&gt; {\nconst index = draft.findIndex((t) =&gt; t.id === todoId);\ndraft.splice(index, 1);\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button on_click={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p>You can also mix and match the mutative and non-mutative approaches with Immer.</p> <p>For example, in this version <code>handleAddTodo</code> is implemented by mutating the Immer <code>draft</code>, while <code>handleChangeTodo</code> and <code>handleDeleteTodo</code> use the non-mutative <code>map</code> and <code>filter</code> methods:</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, updateTodos] = useImmer(initialTodos);\n\nfunction handleAddTodo(title) {\nupdateTodos((draft) =&gt; {\ndraft.push({\nid: nextId++,\ntitle: title,\ndone: false,\n});\n});\n}\n\nfunction handleChangeTodo(nextTodo) {\nupdateTodos(\ntodos.map((todo) =&gt; {\nif (todo.id === nextTodo.id) {\nreturn nextTodo;\n} else {\nreturn todo;\n}\n})\n);\n}\n\nfunction handleDeleteTodo(todoId) {\nupdateTodos(todos.filter((t) =&gt; t.id !== todoId));\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\non_click={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button on_click={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button on_click={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button on_click={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p>With Immer, you can pick the style that feels the most natural for each separate case.</p> <p></p> <p></p>"},{"location":"learn/updating-objects-in-state/","title":"Updating Objects in State \ud83d\udea7","text":""},{"location":"learn/updating-objects-in-state/#overview","title":"Overview","text":"<p>  State can hold any kind of JavaScript value, including objects. But you shouldn't change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.  </p> <p>You will learn</p> <ul> <li>How to correctly update an object in React state</li> <li>How to update a nested object without mutating it</li> <li>What immutability is, and how not to break it</li> <li>How to make object copying less repetitive with Immer</li> </ul>"},{"location":"learn/updating-objects-in-state/#whats-a-mutation","title":"What's a mutation?","text":"<p>You can store any kind of JavaScript value in state.</p> <pre><code>const [x, setX] = useState(0);\n</code></pre> <p>So far you've been working with numbers, strings, and booleans. These kinds of JavaScript values are \"immutable\", meaning unchangeable or \"read-only\". You can trigger a re-render to replace a value:</p> <pre><code>setX(5);\n</code></pre> <p>The <code>x</code> state changed from <code>0</code> to <code>5</code>, but the number <code>0</code> itself did not change. It's not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.</p> <p>Now consider an object in state:</p> <pre><code>const [position, setPosition] = useState({ x: 0, y: 0 });\n</code></pre> <p>Technically, it is possible to change the contents of the object itself. This is called a mutation:</p> <pre><code>position.x = 5;\n</code></pre> <p>However, although objects in React state are technically mutable, you should treat them as if they were immutable--like numbers, booleans, and strings. Instead of mutating them, you should always replace them.</p>"},{"location":"learn/updating-objects-in-state/#treat-state-as-read-only","title":"Treat state as read-only","text":"<p>In other words, you should treat any JavaScript object that you put into state as read-only.</p> <p>This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:</p> <pre><code>import { useState } from \"react\";\nexport default function MovingDot() {\nconst [position, setPosition] = useState({\nx: 0,\ny: 0,\n});\nreturn (\n&lt;div\nonPointerMove={(e) =&gt; {\nposition.x = e.clientX;\nposition.y = e.clientY;\n}}\nstyle={{\nposition: \"relative\",\nwidth: \"100vw\",\nheight: \"100vh\",\n}}\n&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"red\",\nborderRadius: \"50%\",\ntransform: `translate(${position.x}px, ${position.y}px)`,\nleft: -10,\ntop: -10,\nwidth: 20,\nheight: 20,\n}}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n</code></pre> <p>The problem is with this bit of code.</p> <pre><code>onPointerMove={e =&gt; {\nposition.x = e.clientX;\nposition.y = e.clientY;\n}}\n</code></pre> <p>This code modifies the object assigned to <code>position</code> from the previous render. But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It's like trying to change the order after you've already eaten the meal. While mutating state can work in some cases, we don't recommend it. You should treat the state value you have access to in a render as read-only.</p> <p>To actually trigger a re-render in this case, create a new object and pass it to the state setting function:</p> <pre><code>onPointerMove={e =&gt; {\nsetPosition({\nx: e.clientX,\ny: e.clientY\n});\n}}\n</code></pre> <p>With <code>setPosition</code>, you're telling React:</p> <ul> <li>Replace <code>position</code> with this new object</li> <li>And render this component again</li> </ul> <p>Notice how the red dot now follows your pointer when you touch or hover over the preview area:</p> <pre><code>import { useState } from \"react\";\nexport default function MovingDot() {\nconst [position, setPosition] = useState({\nx: 0,\ny: 0,\n});\nreturn (\n&lt;div\nonPointerMove={(e) =&gt; {\nsetPosition({\nx: e.clientX,\ny: e.clientY,\n});\n}}\nstyle={{\nposition: \"relative\",\nwidth: \"100vw\",\nheight: \"100vh\",\n}}\n&gt;\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"red\",\nborderRadius: \"50%\",\ntransform: `translate(${position.x}px, ${position.y}px)`,\nleft: -10,\ntop: -10,\nwidth: 20,\nheight: 20,\n}}\n/&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>body {\nmargin: 0;\npadding: 0;\nheight: 250px;\n}\n</code></pre> <p>"},{"location":"learn/updating-objects-in-state/#local-mutation-is-fine","title":"Local mutation is fine","text":"<p>Code like this is a problem because it modifies an existing object in state:</p> <pre><code>position.x = e.clientX;\nposition.y = e.clientY;\n</code></pre> <p>But code like this is absolutely fine because you're mutating a fresh object you have just created:</p> <pre><code>const nextPosition = {};\nnextPosition.x = e.clientX;\nnextPosition.y = e.clientY;\nsetPosition(nextPosition);\n</code></pre> <p>In fact, it is completely equivalent to writing this:</p> <pre><code>setPosition({\nx: e.clientX,\ny: e.clientY,\n});\n</code></pre> <p>Mutation is only a problem when you change existing objects that are already in state. Mutating an object you've just created is okay because no other code references it yet. Changing it isn't going to accidentally impact something that depends on it. This is called a \"local mutation\". You can even do local mutation while rendering. Very convenient and completely okay!</p> <p></p>"},{"location":"learn/updating-objects-in-state/#copying-objects-with-the-spread-syntax","title":"Copying objects with the spread syntax","text":"<p>In the previous example, the <code>position</code> object is always created fresh from the current cursor position. But often, you will want to include existing data as a part of the new object you're creating. For example, you may want to update only one field in a form, but keep the previous values for all other fields.</p> <p>These input fields don't work because the <code>onChange</code> handlers mutate the state:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [person, setPerson] = useState({\nfirstName: \"Barbara\",\nlastName: \"Hepworth\",\nemail: \"bhepworth@sculpture.com\",\n});\n\nfunction handleFirstNameChange(e) {\nperson.firstName = e.target.value;\n}\n\nfunction handleLastNameChange(e) {\nperson.lastName = e.target.value;\n}\n\nfunction handleEmailChange(e) {\nperson.email = e.target.value;\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nvalue={person.firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nvalue={person.lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:\n&lt;input value={person.email} onChange={handleEmailChange} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\n{person.firstName} {person.lastName} ({person.email})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\n</code></pre> <p>For example, this line mutates the state from a past render:</p> <pre><code>person.firstName = e.target.value;\n</code></pre> <p>The reliable way to get the behavior you're looking for is to create a new object and pass it to <code>setPerson</code>. But here, you want to also copy the existing data into it because only one of the fields has changed:</p> <pre><code>setPerson({\nfirstName: e.target.value, // New first name from the input\nlastName: person.lastName,\nemail: person.email,\n});\n</code></pre> <p>You can use the <code>...</code> object spread syntax so that you don't need to copy every property separately.</p> <pre><code>setPerson({\n...person, // Copy the old fields\nfirstName: e.target.value, // But override this one\n});\n</code></pre> <p>Now the form works!</p> <p>Notice how you didn't declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient--as long as you update it correctly!</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [person, setPerson] = useState({\nfirstName: \"Barbara\",\nlastName: \"Hepworth\",\nemail: \"bhepworth@sculpture.com\",\n});\n\nfunction handleFirstNameChange(e) {\nsetPerson({\n...person,\nfirstName: e.target.value,\n});\n}\n\nfunction handleLastNameChange(e) {\nsetPerson({\n...person,\nlastName: e.target.value,\n});\n}\n\nfunction handleEmailChange(e) {\nsetPerson({\n...person,\nemail: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nvalue={person.firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nvalue={person.lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:\n&lt;input value={person.email} onChange={handleEmailChange} /&gt;\n&lt;/label&gt;\n&lt;p&gt;\n{person.firstName} {person.lastName} ({person.email})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\n</code></pre> <p>Note that the <code>...</code> spread syntax is \"shallow\"--it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you'll have to use it more than once.</p> <p>"},{"location":"learn/updating-objects-in-state/#using-a-single-event-handler-for-multiple-fields","title":"Using a single event handler for multiple fields","text":"<p>You can also use the <code>[</code> and <code>]</code> braces inside your object definition to specify a property with dynamic name. Here is the same example, but with a single event handler instead of three different ones:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [person, setPerson] = useState({\nfirstName: \"Barbara\",\nlastName: \"Hepworth\",\nemail: \"bhepworth@sculpture.com\",\n});\n\nfunction handleChange(e) {\nsetPerson({\n...person,\n[e.target.name]: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nname=\"firstName\"\nvalue={person.firstName}\nonChange={handleChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nname=\"lastName\"\nvalue={person.lastName}\nonChange={handleChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:\n&lt;input\nname=\"email\"\nvalue={person.email}\nonChange={handleChange}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\n{person.firstName} {person.lastName} ({person.email})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\n</code></pre> <p>Here, <code>e.target.name</code> refers to the <code>name</code> property given to the <code>&lt;input&gt;</code> DOM element.</p> <p></p>"},{"location":"learn/updating-objects-in-state/#updating-a-nested-object","title":"Updating a nested object","text":"<p>Consider a nested object structure like this:</p> <pre><code>const [person, setPerson] = useState({\nname: \"Niki de Saint Phalle\",\nartwork: {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n},\n});\n</code></pre> <p>If you wanted to update <code>person.artwork.city</code>, it's clear how to do it with mutation:</p> <pre><code>person.artwork.city = \"New Delhi\";\n</code></pre> <p>But in React, you treat state as immutable! In order to change <code>city</code>, you would first need to produce the new <code>artwork</code> object (pre-populated with data from the previous one), and then produce the new <code>person</code> object which points at the new <code>artwork</code>:</p> <pre><code>const nextArtwork = { ...person.artwork, city: \"New Delhi\" };\nconst nextPerson = { ...person, artwork: nextArtwork };\nsetPerson(nextPerson);\n</code></pre> <p>Or, written as a single function call:</p> <pre><code>setPerson({\n...person, // Copy other fields\nartwork: {\n// but replace the artwork\n...person.artwork, // with the same one\ncity: \"New Delhi\", // but in New Delhi!\n},\n});\n</code></pre> <p>This gets a bit wordy, but it works fine for many cases:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [person, setPerson] = useState({\nname: \"Niki de Saint Phalle\",\nartwork: {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n},\n});\n\nfunction handleNameChange(e) {\nsetPerson({\n...person,\nname: e.target.value,\n});\n}\n\nfunction handleTitleChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\ntitle: e.target.value,\n},\n});\n}\n\nfunction handleCityChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\ncity: e.target.value,\n},\n});\n}\n\nfunction handleImageChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\nimage: e.target.value,\n},\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nName:\n&lt;input value={person.name} onChange={handleNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nTitle:\n&lt;input\nvalue={person.artwork.title}\nonChange={handleTitleChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input\nvalue={person.artwork.city}\nonChange={handleCityChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nImage:\n&lt;input\nvalue={person.artwork.image}\nonChange={handleImageChange}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\n&lt;i&gt;{person.artwork.title}&lt;/i&gt;\n{\" by \"}\n{person.name}\n&lt;br /&gt;\n(located in {person.artwork.city})\n&lt;/p&gt;\n&lt;img src={person.artwork.image} alt={person.artwork.title} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\nimg {\nwidth: 200px;\nheight: 200px;\n}\n</code></pre> <p>"},{"location":"learn/updating-objects-in-state/#objects-are-not-really-nested","title":"Objects are not really nested","text":"<p>An object like this appears \"nested\" in code:</p> <pre><code>let obj = {\nname: \"Niki de Saint Phalle\",\nartwork: {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n},\n};\n</code></pre> <p>However, \"nesting\" is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a \"nested\" object. You are really looking at two different objects:</p> <pre><code>let obj1 = {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\n\nlet obj2 = {\nname: \"Niki de Saint Phalle\",\nartwork: obj1,\n};\n</code></pre> <p>The <code>obj1</code> object is not \"inside\" <code>obj2</code>. For example, <code>obj3</code> could \"point\" at <code>obj1</code> too:</p> <pre><code>let obj1 = {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\n\nlet obj2 = {\nname: \"Niki de Saint Phalle\",\nartwork: obj1,\n};\n\nlet obj3 = {\nname: \"Copycat\",\nartwork: obj1,\n};\n</code></pre> <p>If you were to mutate <code>obj3.artwork.city</code>, it would affect both <code>obj2.artwork.city</code> and <code>obj1.city</code>. This is because <code>obj3.artwork</code>, <code>obj2.artwork</code>, and <code>obj1</code> are the same object. This is difficult to see when you think of objects as \"nested\". Instead, they are separate objects \"pointing\" at each other with properties.</p> <p></p>"},{"location":"learn/updating-objects-in-state/#write-concise-update-logic-with-immer","title":"Write concise update logic with Immer","text":"<p>If your state is deeply nested, you might want to consider flattening it. But, if you don't want to change your state structure, you might prefer a shortcut to nested spreads. Immer is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are \"breaking the rules\" and mutating an object:</p> <pre><code>updatePerson((draft) =&gt; {\ndraft.artwork.city = \"Lagos\";\n});\n</code></pre> <p>But unlike a regular mutation, it doesn't overwrite the past state!</p> <p>"},{"location":"learn/updating-objects-in-state/#how-does-immer-work","title":"How does Immer work?","text":"<p>The <code>draft</code> provided by Immer is a special type of object, called a Proxy, that \"records\" what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of the <code>draft</code> have been changed, and produces a completely new object that contains your edits.</p> <p></p> <p>To try Immer:</p> <ol> <li>Run <code>npm install use-immer</code> to add Immer as a dependency</li> <li>Then replace <code>import { useState } from 'react'</code> with <code>import { useImmer } from 'use-immer'</code></li> </ol> <p>Here is the above example converted to Immer:</p> <pre><code>import { useImmer } from \"use-immer\";\n\nexport default function Form() {\nconst [person, updatePerson] = useImmer({\nname: \"Niki de Saint Phalle\",\nartwork: {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n},\n});\n\nfunction handleNameChange(e) {\nupdatePerson((draft) =&gt; {\ndraft.name = e.target.value;\n});\n}\n\nfunction handleTitleChange(e) {\nupdatePerson((draft) =&gt; {\ndraft.artwork.title = e.target.value;\n});\n}\n\nfunction handleCityChange(e) {\nupdatePerson((draft) =&gt; {\ndraft.artwork.city = e.target.value;\n});\n}\n\nfunction handleImageChange(e) {\nupdatePerson((draft) =&gt; {\ndraft.artwork.image = e.target.value;\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nName:\n&lt;input value={person.name} onChange={handleNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nTitle:\n&lt;input\nvalue={person.artwork.title}\nonChange={handleTitleChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input\nvalue={person.artwork.city}\nonChange={handleCityChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nImage:\n&lt;input\nvalue={person.artwork.image}\nonChange={handleImageChange}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\n&lt;i&gt;{person.artwork.title}&lt;/i&gt;\n{\" by \"}\n{person.name}\n&lt;br /&gt;\n(located in {person.artwork.city})\n&lt;/p&gt;\n&lt;img src={person.artwork.image} alt={person.artwork.title} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\nimg {\nwidth: 200px;\nheight: 200px;\n}\n</code></pre> <p>Notice how much more concise the event handlers have become. You can mix and match <code>useState</code> and <code>useImmer</code> in a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there's nesting in your state, and copying objects leads to repetitive code.</p> <p>"},{"location":"learn/updating-objects-in-state/#why-is-mutating-state-not-recommended-in-react","title":"Why is mutating state not recommended in React?","text":"<p>There are a few reasons:</p> <ul> <li>Debugging: If you use <code>console.log</code> and don't mutate state, your past logs won't get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.</li> <li>Optimizations: Common React optimization strategies rely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. If <code>prevObj === obj</code>, you can be sure that nothing could have changed inside of it.</li> <li>New Features: The new React features we're building rely on state being treated like a snapshot. If you're mutating past versions of state, that may prevent you from using the new features.</li> <li>Requirement Changes: Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.</li> <li>Simpler Implementation: Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many \"reactive\" solutions do. This is also why React lets you put any object into state--no matter how large--without additional performance or correctness pitfalls.</li> </ul> <p>In practice, you can often \"get away\" with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!</p> <p></p> <p> <ul> <li>Treat all state in React as immutable.</li> <li>When you store objects in state, mutating them will not trigger renders and will change the state in previous render \"snapshots\".</li> <li>Instead of mutating an object, create a new version of it, and trigger a re-render by setting state to it.</li> <li>You can use the <code>{...obj, something: 'newValue'}</code> object spread syntax to create copies of objects.</li> <li>Spread syntax is shallow: it only copies one level deep.</li> <li>To update a nested object, you need to create copies all the way up from the place you're updating.</li> <li>To reduce repetitive copying code, use Immer.</li> </ul> <p></p> <p>"},{"location":"learn/updating-objects-in-state/#fix-incorrect-state-updates","title":"Fix incorrect state updates","text":"<p>This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly \"caught up\" with your changes. Finally, edit the last name, and notice that the score has disappeared completely.</p> <p>Your task is to fix all of these bugs. As you fix them, explain why each of them happens.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Scoreboard() {\nconst [player, setPlayer] = useState({\nfirstName: \"Ranjani\",\nlastName: \"Shettar\",\nscore: 10,\n});\n\nfunction handlePlusClick() {\nplayer.score++;\n}\n\nfunction handleFirstNameChange(e) {\nsetPlayer({\n...player,\nfirstName: e.target.value,\n});\n}\n\nfunction handleLastNameChange(e) {\nsetPlayer({\nlastName: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nScore: &lt;b&gt;{player.score}&lt;/b&gt;{\" \"}\n&lt;button on_click={handlePlusClick}&gt;+1&lt;/button&gt;\n&lt;/label&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nvalue={player.firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nvalue={player.lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-bottom: 10px;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\n</code></pre> <p> <p>Here is a version with both bugs fixed:</p> <pre><code>import { useState } from \"react\";\n\nexport default function Scoreboard() {\nconst [player, setPlayer] = useState({\nfirstName: \"Ranjani\",\nlastName: \"Shettar\",\nscore: 10,\n});\n\nfunction handlePlusClick() {\nsetPlayer({\n...player,\nscore: player.score + 1,\n});\n}\n\nfunction handleFirstNameChange(e) {\nsetPlayer({\n...player,\nfirstName: e.target.value,\n});\n}\n\nfunction handleLastNameChange(e) {\nsetPlayer({\n...player,\nlastName: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nScore: &lt;b&gt;{player.score}&lt;/b&gt;{\" \"}\n&lt;button on_click={handlePlusClick}&gt;+1&lt;/button&gt;\n&lt;/label&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nvalue={player.firstName}\nonChange={handleFirstNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nvalue={player.lastName}\nonChange={handleLastNameChange}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\n</code></pre> <p>The problem with <code>handlePlusClick</code> was that it mutated the <code>player</code> object. As a result, React did not know that there's a reason to re-render, and did not update the score on the screen. This is why, when you edited the first name, the state got updated, triggering a re-render which also updated the score on the screen.</p> <p>The problem with <code>handleLastNameChange</code> was that it did not copy the existing <code>...player</code> fields into the new object. This is why the score got lost after you edited the last name.</p> <p></p>"},{"location":"learn/updating-objects-in-state/#find-and-fix-the-mutation","title":"Find and fix the mutation","text":"<p>There is a draggable box on a static background. You can change the box's color using the select input.</p> <p>But there is a bug. If you move the box first, and then change its color, the background (which isn't supposed to move!) will \"jump\" to the box position. But this should not happen: the <code>Background</code>'s <code>position</code> prop is set to <code>initialPosition</code>, which is <code>{ x: 0, y: 0 }</code>. Why is the background moving after the color change?</p> <p>Find the bug and fix it.</p> <p> <p>If something unexpected changes, there is a mutation. Find the mutation in <code>App.js</code> and fix it.</p> <p></p> <pre><code>import { useState } from \"react\";\nimport Background from \"./Background.js\";\nimport Box from \"./Box.js\";\n\nconst initialPosition = {\nx: 0,\ny: 0,\n};\n\nexport default function Canvas() {\nconst [shape, setShape] = useState({\ncolor: \"orange\",\nposition: initialPosition,\n});\n\nfunction handleMove(dx, dy) {\nshape.position.x += dx;\nshape.position.y += dy;\n}\n\nfunction handleColorChange(e) {\nsetShape({\n...shape,\ncolor: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;select value={shape.color} onChange={handleColorChange}&gt;\n&lt;option value=\"orange\"&gt;orange&lt;/option&gt;\n&lt;option value=\"lightpink\"&gt;lightpink&lt;/option&gt;\n&lt;option value=\"aliceblue\"&gt;aliceblue&lt;/option&gt;\n&lt;/select&gt;\n&lt;Background position={initialPosition} /&gt;\n&lt;Box\ncolor={shape.color}\nposition={shape.position}\nonMove={handleMove}\n&gt;\nDrag me!\n&lt;/Box&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Box({ children, color, position, onMove }) {\nconst [lastCoordinates, setLastCoordinates] = useState(null);\n\nfunction handlePointerDown(e) {\ne.target.setPointerCapture(e.pointerId);\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\n}\n\nfunction handlePointerMove(e) {\nif (lastCoordinates) {\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\nconst dx = e.clientX - lastCoordinates.x;\nconst dy = e.clientY - lastCoordinates.y;\nonMove(dx, dy);\n}\n}\n\nfunction handlePointerUp(e) {\nsetLastCoordinates(null);\n}\n\nreturn (\n&lt;div\nonPointerDown={handlePointerDown}\nonPointerMove={handlePointerMove}\nonPointerUp={handlePointerUp}\nstyle={{\nwidth: 100,\nheight: 100,\ncursor: \"grab\",\nbackgroundColor: color,\nposition: \"absolute\",\nborder: \"1px solid black\",\ndisplay: \"flex\",\njustifyContent: \"center\",\nalignItems: \"center\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n        )`,\n}}\n&gt;\n{children}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export default function Background({ position }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n      )`,\nwidth: 250,\nheight: 250,\nbackgroundColor: \"rgba(200, 200, 0, 0.2)\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 280px;\n}\nselect {\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>The problem was in the mutation inside <code>handleMove</code>. It mutated <code>shape.position</code>, but that's the same object that <code>initialPosition</code> points at. This is why both the shape and the background move. (It's a mutation, so the change doesn't reflect on the screen until an unrelated update--the color change--triggers a re-render.)</p> <p>The fix is to remove the mutation from <code>handleMove</code>, and use the spread syntax to copy the shape. Note that <code>+=</code> is a mutation, so you need to rewrite it to use a regular <code>+</code> operation.</p> <pre><code>import { useState } from \"react\";\nimport Background from \"./Background.js\";\nimport Box from \"./Box.js\";\n\nconst initialPosition = {\nx: 0,\ny: 0,\n};\n\nexport default function Canvas() {\nconst [shape, setShape] = useState({\ncolor: \"orange\",\nposition: initialPosition,\n});\n\nfunction handleMove(dx, dy) {\nsetShape({\n...shape,\nposition: {\nx: shape.position.x + dx,\ny: shape.position.y + dy,\n},\n});\n}\n\nfunction handleColorChange(e) {\nsetShape({\n...shape,\ncolor: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;select value={shape.color} onChange={handleColorChange}&gt;\n&lt;option value=\"orange\"&gt;orange&lt;/option&gt;\n&lt;option value=\"lightpink\"&gt;lightpink&lt;/option&gt;\n&lt;option value=\"aliceblue\"&gt;aliceblue&lt;/option&gt;\n&lt;/select&gt;\n&lt;Background position={initialPosition} /&gt;\n&lt;Box\ncolor={shape.color}\nposition={shape.position}\nonMove={handleMove}\n&gt;\nDrag me!\n&lt;/Box&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Box({ children, color, position, onMove }) {\nconst [lastCoordinates, setLastCoordinates] = useState(null);\n\nfunction handlePointerDown(e) {\ne.target.setPointerCapture(e.pointerId);\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\n}\n\nfunction handlePointerMove(e) {\nif (lastCoordinates) {\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\nconst dx = e.clientX - lastCoordinates.x;\nconst dy = e.clientY - lastCoordinates.y;\nonMove(dx, dy);\n}\n}\n\nfunction handlePointerUp(e) {\nsetLastCoordinates(null);\n}\n\nreturn (\n&lt;div\nonPointerDown={handlePointerDown}\nonPointerMove={handlePointerMove}\nonPointerUp={handlePointerUp}\nstyle={{\nwidth: 100,\nheight: 100,\ncursor: \"grab\",\nbackgroundColor: color,\nposition: \"absolute\",\nborder: \"1px solid black\",\ndisplay: \"flex\",\njustifyContent: \"center\",\nalignItems: \"center\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n        )`,\n}}\n&gt;\n{children}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export default function Background({ position }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n      )`,\nwidth: 250,\nheight: 250,\nbackgroundColor: \"rgba(200, 200, 0, 0.2)\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 280px;\n}\nselect {\nmargin-bottom: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/updating-objects-in-state/#update-an-object-with-immer","title":"Update an object with Immer","text":"<p>This is the same buggy example as in the previous challenge. This time, fix the mutation by using Immer. For your convenience, <code>useImmer</code> is already imported, so you need to change the <code>shape</code> state variable to use it.</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\nimport Background from \"./Background.js\";\nimport Box from \"./Box.js\";\n\nconst initialPosition = {\nx: 0,\ny: 0,\n};\n\nexport default function Canvas() {\nconst [shape, setShape] = useState({\ncolor: \"orange\",\nposition: initialPosition,\n});\n\nfunction handleMove(dx, dy) {\nshape.position.x += dx;\nshape.position.y += dy;\n}\n\nfunction handleColorChange(e) {\nsetShape({\n...shape,\ncolor: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;select value={shape.color} onChange={handleColorChange}&gt;\n&lt;option value=\"orange\"&gt;orange&lt;/option&gt;\n&lt;option value=\"lightpink\"&gt;lightpink&lt;/option&gt;\n&lt;option value=\"aliceblue\"&gt;aliceblue&lt;/option&gt;\n&lt;/select&gt;\n&lt;Background position={initialPosition} /&gt;\n&lt;Box\ncolor={shape.color}\nposition={shape.position}\nonMove={handleMove}\n&gt;\nDrag me!\n&lt;/Box&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Box({ children, color, position, onMove }) {\nconst [lastCoordinates, setLastCoordinates] = useState(null);\n\nfunction handlePointerDown(e) {\ne.target.setPointerCapture(e.pointerId);\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\n}\n\nfunction handlePointerMove(e) {\nif (lastCoordinates) {\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\nconst dx = e.clientX - lastCoordinates.x;\nconst dy = e.clientY - lastCoordinates.y;\nonMove(dx, dy);\n}\n}\n\nfunction handlePointerUp(e) {\nsetLastCoordinates(null);\n}\n\nreturn (\n&lt;div\nonPointerDown={handlePointerDown}\nonPointerMove={handlePointerMove}\nonPointerUp={handlePointerUp}\nstyle={{\nwidth: 100,\nheight: 100,\ncursor: \"grab\",\nbackgroundColor: color,\nposition: \"absolute\",\nborder: \"1px solid black\",\ndisplay: \"flex\",\njustifyContent: \"center\",\nalignItems: \"center\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n        )`,\n}}\n&gt;\n{children}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export default function Background({ position }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n      )`,\nwidth: 250,\nheight: 250,\nbackgroundColor: \"rgba(200, 200, 0, 0.2)\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 280px;\n}\nselect {\nmargin-bottom: 10px;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p> <p>This is the solution rewritten with Immer. Notice how the event handlers are written in a mutating fashion, but the bug does not occur. This is because under the hood, Immer never mutates the existing objects.</p> <pre><code>import { useImmer } from \"use-immer\";\nimport Background from \"./Background.js\";\nimport Box from \"./Box.js\";\n\nconst initialPosition = {\nx: 0,\ny: 0,\n};\n\nexport default function Canvas() {\nconst [shape, updateShape] = useImmer({\ncolor: \"orange\",\nposition: initialPosition,\n});\n\nfunction handleMove(dx, dy) {\nupdateShape((draft) =&gt; {\ndraft.position.x += dx;\ndraft.position.y += dy;\n});\n}\n\nfunction handleColorChange(e) {\nupdateShape((draft) =&gt; {\ndraft.color = e.target.value;\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;select value={shape.color} onChange={handleColorChange}&gt;\n&lt;option value=\"orange\"&gt;orange&lt;/option&gt;\n&lt;option value=\"lightpink\"&gt;lightpink&lt;/option&gt;\n&lt;option value=\"aliceblue\"&gt;aliceblue&lt;/option&gt;\n&lt;/select&gt;\n&lt;Background position={initialPosition} /&gt;\n&lt;Box\ncolor={shape.color}\nposition={shape.position}\nonMove={handleMove}\n&gt;\nDrag me!\n&lt;/Box&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function Box({ children, color, position, onMove }) {\nconst [lastCoordinates, setLastCoordinates] = useState(null);\n\nfunction handlePointerDown(e) {\ne.target.setPointerCapture(e.pointerId);\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\n}\n\nfunction handlePointerMove(e) {\nif (lastCoordinates) {\nsetLastCoordinates({\nx: e.clientX,\ny: e.clientY,\n});\nconst dx = e.clientX - lastCoordinates.x;\nconst dy = e.clientY - lastCoordinates.y;\nonMove(dx, dy);\n}\n}\n\nfunction handlePointerUp(e) {\nsetLastCoordinates(null);\n}\n\nreturn (\n&lt;div\nonPointerDown={handlePointerDown}\nonPointerMove={handlePointerMove}\nonPointerUp={handlePointerUp}\nstyle={{\nwidth: 100,\nheight: 100,\ncursor: \"grab\",\nbackgroundColor: color,\nposition: \"absolute\",\nborder: \"1px solid black\",\ndisplay: \"flex\",\njustifyContent: \"center\",\nalignItems: \"center\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n        )`,\n}}\n&gt;\n{children}\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export default function Background({ position }) {\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\ntransform: `translate(\n${position.x}px,\n${position.y}px\n      )`,\nwidth: 250,\nheight: 250,\nbackgroundColor: \"rgba(200, 200, 0, 0.2)\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nheight: 280px;\n}\nselect {\nmargin-bottom: 10px;\n}\n</code></pre> <pre><code>{\n\"dependencies\": {\n\"immer\": \"1.7.3\",\n\"react\": \"latest\",\n\"react-dom\": \"latest\",\n\"react-scripts\": \"latest\",\n\"use-immer\": \"0.5.1\"\n},\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test --env=jsdom\",\n\"eject\": \"react-scripts eject\"\n}\n}\n</code></pre> <p></p> <p></p>"},{"location":"learn/writing-markup-with-psx/","title":"Writing markup with psx","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p> <p>See this issue for more details.</p>"},{"location":"learn/you-might-not-need-an-effect/","title":"You Might Not Need an Effect \ud83d\udea7","text":""},{"location":"learn/you-might-not-need-an-effect/#overview","title":"Overview","text":"<p>  Effects are an escape hatch from the React paradigm. They let you \"step outside\" of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component's state when some props or state change), you shouldn't need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.  </p> <p>You will learn</p> <ul> <li>Why and how to remove unnecessary Effects from your components</li> <li>How to cache expensive computations without Effects</li> <li>How to reset and adjust component state without Effects</li> <li>How to share logic between event handlers</li> <li>Which logic should be moved to event handlers</li> <li>How to notify parent components about changes</li> </ul>"},{"location":"learn/you-might-not-need-an-effect/#how-to-remove-unnecessary-effects","title":"How to remove unnecessary Effects","text":"<p>There are two common cases in which you don't need Effects:</p> <ul> <li>You don't need Effects to transform data for rendering. For example, let's say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will \"commit\" these changes to the DOM, updating the screen. Then React will run your Effects. If your Effect also immediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.</li> <li>You don't need Effects to handle user events. For example, let's say you want to send an <code>/api/buy</code> POST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don't know what the user did (for example, which button was clicked). This is why you'll usually handle user events in the corresponding event handlers.</li> </ul> <p>You do need Effects to synchronize with external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modern frameworks provide more efficient built-in data fetching mechanisms than writing Effects directly in your components.</p> <p>To help you gain the right intuition, let's look at some common concrete examples!</p>"},{"location":"learn/you-might-not-need-an-effect/#updating-state-based-on-props-or-state","title":"Updating state based on props or state","text":"<p>Suppose you have a component with two state variables: <code>firstName</code> and <code>lastName</code>. You want to calculate a <code>fullName</code> from them by concatenating them. Moreover, you'd like <code>fullName</code> to update whenever <code>firstName</code> or <code>lastName</code> change. Your first instinct might be to add a <code>fullName</code> state variable and update it in an Effect:</p> <pre><code>function Form() {\nconst [firstName, setFirstName] = useState(\"Taylor\");\nconst [lastName, setLastName] = useState(\"Swift\");\n\n// \ud83d\udd34 Avoid: redundant state and unnecessary Effect\nconst [fullName, setFullName] = useState(\"\");\nuseEffect(() =&gt; {\nsetFullName(firstName + \" \" + lastName);\n}, [firstName, lastName]);\n// ...\n}\n</code></pre> <p>This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for <code>fullName</code>, then immediately re-renders with the updated value. Remove the state variable and the Effect:</p> <pre><code>function Form() {\nconst [firstName, setFirstName] = useState(\"Taylor\");\nconst [lastName, setLastName] = useState(\"Swift\");\n// \u2705 Good: calculated during rendering\nconst fullName = firstName + \" \" + lastName;\n// ...\n}\n</code></pre> <p>When something can be calculated from the existing props or state, don't put it in state. Instead, calculate it during rendering. This makes your code faster (you avoid the extra \"cascading\" updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you, Thinking in React explains what should go into state.</p>"},{"location":"learn/you-might-not-need-an-effect/#caching-expensive-calculations","title":"Caching expensive calculations","text":"<p>This component computes <code>visibleTodos</code> by taking the <code>todos</code> it receives by props and filtering them according to the <code>filter</code> prop. You might feel tempted to store the result in state and update it from an Effect:</p> <pre><code>function TodoList({ todos, filter }) {\nconst [newTodo, setNewTodo] = useState(\"\");\n\n// \ud83d\udd34 Avoid: redundant state and unnecessary Effect\nconst [visibleTodos, setVisibleTodos] = useState([]);\nuseEffect(() =&gt; {\nsetVisibleTodos(getFilteredTodos(todos, filter));\n}, [todos, filter]);\n\n// ...\n}\n</code></pre> <p>Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:</p> <pre><code>function TodoList({ todos, filter }) {\nconst [newTodo, setNewTodo] = useState(\"\");\n// \u2705 This is fine if getFilteredTodos() is not slow.\nconst visibleTodos = getFilteredTodos(todos, filter);\n// ...\n}\n</code></pre> <p>Usually, this code is fine! But maybe <code>getFilteredTodos()</code> is slow or you have a lot of <code>todos</code>. In that case you don't want to recalculate <code>getFilteredTodos()</code> if some unrelated state variable like <code>newTodo</code> has changed.</p> <p>You can cache (or \"memoize\") an expensive calculation by wrapping it in a <code>useMemo</code> Hook:</p> <pre><code>import { useMemo, useState } from \"react\";\n\nfunction TodoList({ todos, filter }) {\nconst [newTodo, setNewTodo] = useState(\"\");\nconst visibleTodos = useMemo(() =&gt; {\n// \u2705 Does not re-run unless todos or filter change\nreturn getFilteredTodos(todos, filter);\n}, [todos, filter]);\n// ...\n}\n</code></pre> <p>Or, written as a single line:</p> <pre><code>import { useMemo, useState } from \"react\";\n\nfunction TodoList({ todos, filter }) {\nconst [newTodo, setNewTodo] = useState(\"\");\n// \u2705 Does not re-run getFilteredTodos() unless todos or filter change\nconst visibleTodos = useMemo(\n() =&gt; getFilteredTodos(todos, filter),\n[todos, filter]\n);\n// ...\n}\n</code></pre> <p>This tells React that you don't want the inner function to re-run unless either <code>todos</code> or <code>filter</code> have changed. React will remember the return value of <code>getFilteredTodos()</code> during the initial render. During the next renders, it will check if <code>todos</code> or <code>filter</code> are different. If they're the same as last time, <code>useMemo</code> will return the last result it has stored. But if they are different, React will call the inner function again (and store its result).</p> <p>The function you wrap in <code>useMemo</code> runs during rendering, so this only works for pure calculations.</p> <p>"},{"location":"learn/you-might-not-need-an-effect/#how-to-tell-if-a-calculation-is-expensive","title":"How to tell if a calculation is expensive?","text":"<p>In general, unless you're creating or looping over thousands of objects, it's probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:</p> <pre><code>console.time(\"filter array\");\nconst visibleTodos = getFilteredTodos(todos, filter);\nconsole.timeEnd(\"filter array\");\n</code></pre> <p>Perform the interaction you're measuring (for example, typing into the input). You will then see logs like <code>filter array: 0.15ms</code> in your console. If the overall logged time adds up to a significant amount (say, <code>1ms</code> or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in <code>useMemo</code> to verify whether the total logged time has decreased for that interaction or not:</p> <pre><code>console.time(\"filter array\");\nconst visibleTodos = useMemo(() =&gt; {\nreturn getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed\n}, [todos, filter]);\nconsole.timeEnd(\"filter array\");\n</code></pre> <p><code>useMemo</code> won't make the first render faster. It only helps you skip unnecessary work on updates.</p> <p>Keep in mind that your machine is probably faster than your users' so it's a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.</p> <p>Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.</p> <p></p>"},{"location":"learn/you-might-not-need-an-effect/#resetting-all-state-when-a-prop-changes","title":"Resetting all state when a prop changes","text":"<p>This <code>ProfilePage</code> component receives a <code>userId</code> prop. The page contains a comment input, and you use a <code>comment</code> state variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, the <code>comment</code> state does not get reset. As a result, it's easy to accidentally post a comment on a wrong user's profile. To fix the issue, you want to clear out the <code>comment</code> state variable whenever the <code>userId</code> changes:</p> <pre><code>export default function ProfilePage({ userId }) {\nconst [comment, setComment] = useState(\"\");\n\n// \ud83d\udd34 Avoid: Resetting state on prop change in an Effect\nuseEffect(() =&gt; {\nsetComment(\"\");\n}, [userId]);\n// ...\n}\n</code></pre> <p>This is inefficient because <code>ProfilePage</code> and its children will first render with the stale value, and then render again. It is also complicated because you'd need to do this in every component that has some state inside <code>ProfilePage</code>. For example, if the comment UI is nested, you'd want to clear out nested comment state too.</p> <p>Instead, you can tell React that each user's profile is conceptually a different profile by giving it an explicit key. Split your component in two and pass a <code>key</code> attribute from the outer component to the inner one:</p> <pre><code>export default function ProfilePage({ userId }) {\nreturn &lt;Profile userId={userId} key={userId} /&gt;;\n}\n\nfunction Profile({ userId }) {\n// \u2705 This and any other state below will reset on key change automatically\nconst [comment, setComment] = useState(\"\");\n// ...\n}\n</code></pre> <p>Normally, React preserves the state when the same component is rendered in the same spot. By passing <code>userId</code> as a <code>key</code> to the <code>Profile</code> component, you're asking React to treat two <code>Profile</code> components with different <code>userId</code> as two different components that should not share any state. Whenever the key (which you've set to <code>userId</code>) changes, React will recreate the DOM and reset the state of the <code>Profile</code> component and all of its children. Now the <code>comment</code> field will clear out automatically when navigating between profiles.</p> <p>Note that in this example, only the outer <code>ProfilePage</code> component is exported and visible to other files in the project. Components rendering <code>ProfilePage</code> don't need to pass the key to it: they pass <code>userId</code> as a regular prop. The fact <code>ProfilePage</code> passes it as a <code>key</code> to the inner <code>Profile</code> component is an implementation detail.</p>"},{"location":"learn/you-might-not-need-an-effect/#adjusting-some-state-when-a-prop-changes","title":"Adjusting some state when a prop changes","text":"<p>Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.</p> <p>This <code>List</code> component receives a list of <code>items</code> as a prop, and maintains the selected item in the <code>selection</code> state variable. You want to reset the <code>selection</code> to <code>null</code> whenever the <code>items</code> prop receives a different array:</p> <pre><code>function List({ items }) {\nconst [isReverse, setIsReverse] = useState(false);\nconst [selection, setSelection] = useState(null);\n\n// \ud83d\udd34 Avoid: Adjusting state on prop change in an Effect\nuseEffect(() =&gt; {\nsetSelection(null);\n}, [items]);\n// ...\n}\n</code></pre> <p>This, too, is not ideal. Every time the <code>items</code> change, the <code>List</code> and its child components will render with a stale <code>selection</code> value at first. Then React will update the DOM and run the Effects. Finally, the <code>setSelection(null)</code> call will cause another re-render of the <code>List</code> and its child components, restarting this whole process again.</p> <p>Start by deleting the Effect. Instead, adjust the state directly during rendering:</p> <pre><code>function List({ items }) {\nconst [isReverse, setIsReverse] = useState(false);\nconst [selection, setSelection] = useState(null);\n\n// Better: Adjust the state while rendering\nconst [prevItems, setPrevItems] = useState(items);\nif (items !== prevItems) {\nsetPrevItems(items);\nsetSelection(null);\n}\n// ...\n}\n</code></pre> <p>Storing information from previous renders like this can be hard to understand, but it\u2019s better than updating the same state in an Effect. In the above example, <code>setSelection</code> is called directly during a render. React will re-render the <code>List</code> immediately after it exits with a <code>return</code> statement. React has not rendered the <code>List</code> children or updated the DOM yet, so this lets the <code>List</code> children skip rendering the stale <code>selection</code> value.</p> <p>When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the same component's state during a render. If you update another component's state during a render, you'll see an error. A condition like <code>items !== prevItems</code> is necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to keep components pure.</p> <p>Although this pattern is more efficient than an Effect, most components shouldn't need it either. No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you can reset all state with a key or calculate everything during rendering instead. For example, instead of storing (and resetting) the selected item, you can store the selected item ID:</p> <pre><code>function List({ items }) {\nconst [isReverse, setIsReverse] = useState(false);\nconst [selectedId, setSelectedId] = useState(null);\n// \u2705 Best: Calculate everything during rendering\nconst selection = items.find((item) =&gt; item.id === selectedId) ?? null;\n// ...\n}\n</code></pre> <p>Now there is no need to \"adjust\" the state at all. If the item with the selected ID is in the list, it remains selected. If it's not, the <code>selection</code> calculated during rendering will be <code>null</code> because no matching item was found. This behavior is different, but arguably better because most changes to <code>items</code> preserve the selection.</p>"},{"location":"learn/you-might-not-need-an-effect/#sharing-logic-between-event-handlers","title":"Sharing logic between event handlers","text":"<p>Let's say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. Calling <code>showNotification()</code> in both buttons' click handlers feels repetitive so you might be tempted to place this logic in an Effect:</p> <pre><code>function ProductPage({ product, addToCart }) {\n// \ud83d\udd34 Avoid: Event-specific logic inside an Effect\nuseEffect(() =&gt; {\nif (product.isInCart) {\nshowNotification(`Added ${product.name} to the shopping cart!`);\n}\n}, [product]);\n\nfunction handleBuyClick() {\naddToCart(product);\n}\n\nfunction handleCheckoutClick() {\naddToCart(product);\nnavigateTo(\"/checkout\");\n}\n// ...\n}\n</code></pre> <p>This Effect is unnecessary. It will also most likely cause bugs. For example, let's say that your app \"remembers\" the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product's page. This is because <code>product.isInCart</code> will already be <code>true</code> on the page load, so the Effect above will call <code>showNotification()</code>.</p> <p>When you're not sure whether some code should be in an Effect or in an event handler, ask yourself why this code needs to run. Use Effects only for code that should run because the component was displayed to the user. In this example, the notification should appear because the user pressed the button, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:</p> <pre><code>function ProductPage({ product, addToCart }) {\n// \u2705 Good: Event-specific logic is called from event handlers\nfunction buyProduct() {\naddToCart(product);\nshowNotification(`Added ${product.name} to the shopping cart!`);\n}\n\nfunction handleBuyClick() {\nbuyProduct();\n}\n\nfunction handleCheckoutClick() {\nbuyProduct();\nnavigateTo(\"/checkout\");\n}\n// ...\n}\n</code></pre> <p>This both removes the unnecessary Effect and fixes the bug.</p>"},{"location":"learn/you-might-not-need-an-effect/#sending-a-post-request","title":"Sending a POST request","text":"<p>This <code>Form</code> component sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the <code>/api/register</code> endpoint:</p> <pre><code>function Form() {\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\n\n// \u2705 Good: This logic should run because the component was displayed\nuseEffect(() =&gt; {\npost(\"/analytics/event\", { eventName: \"visit_form\" });\n}, []);\n\n// \ud83d\udd34 Avoid: Event-specific logic inside an Effect\nconst [jsonToSubmit, setJsonToSubmit] = useState(null);\nuseEffect(() =&gt; {\nif (jsonToSubmit !== null) {\npost(\"/api/register\", jsonToSubmit);\n}\n}, [jsonToSubmit]);\n\nfunction handleSubmit(e) {\ne.preventDefault();\nsetJsonToSubmit({ firstName, lastName });\n}\n// ...\n}\n</code></pre> <p>Let's apply the same criteria as in the example before.</p> <p>The analytics POST request should remain in an Effect. This is because the reason to send the analytics event is that the form was displayed. (It would fire twice in development, but see here for how to deal with that.)</p> <p>However, the <code>/api/register</code> POST request is not caused by the form being displayed. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happen on that particular interaction. Delete the second Effect and move that POST request into the event handler:</p> <pre><code>function Form() {\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\n\n// \u2705 Good: This logic runs because the component was displayed\nuseEffect(() =&gt; {\npost(\"/analytics/event\", { eventName: \"visit_form\" });\n}, []);\n\nfunction handleSubmit(e) {\ne.preventDefault();\n// \u2705 Good: Event-specific logic is in the event handler\npost(\"/api/register\", { firstName, lastName });\n}\n// ...\n}\n</code></pre> <p>When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer is what kind of logic it is from the user's perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it's caused by the user seeing the component on the screen, keep it in the Effect.</p>"},{"location":"learn/you-might-not-need-an-effect/#chains-of-computations","title":"Chains of computations","text":"<p>Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:</p> <pre><code>function Game() {\nconst [card, setCard] = useState(null);\nconst [goldCardCount, setGoldCardCount] = useState(0);\nconst [round, setRound] = useState(1);\nconst [isGameOver, setIsGameOver] = useState(false);\n\n// \ud83d\udd34 Avoid: Chains of Effects that adjust the state solely to trigger each other\nuseEffect(() =&gt; {\nif (card !== null &amp;&amp; card.gold) {\nsetGoldCardCount(c =&gt; c + 1);\n}\n}, [card]);\n\nuseEffect(() =&gt; {\nif (goldCardCount &gt; 3) {\nsetRound(r =&gt; r + 1)\nsetGoldCardCount(0);\n}\n}, [goldCardCount]);\n\nuseEffect(() =&gt; {\nif (round &gt; 5) {\nsetIsGameOver(true);\n}\n}, [round]);\n\nuseEffect(() =&gt; {\nalert('Good game!');\n}, [isGameOver]);\n\nfunction handlePlaceCard(nextCard) {\nif (isGameOver) {\nthrow Error('Game already ended.');\n} else {\nsetCard(nextCard);\n}\n}\n\n// ...\n</code></pre> <p>There are two problems with this code.</p> <p>One problem is that it is very inefficient: the component (and its children) have to re-render between each <code>set</code> call in the chain. In the example above, in the worst case (<code>setCard</code> \u2192 render \u2192 <code>setGoldCardCount</code> \u2192 render \u2192 <code>setRound</code> \u2192 render \u2192 <code>setIsGameOver</code> \u2192 render) there are three unnecessary re-renders of the tree below.</p> <p>Even if it weren't slow, as your code evolves, you will run into cases where the \"chain\" you wrote doesn't fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You'd do it by updating each state variable to a value from the past. However, setting the <code>card</code> state to a value from the past would trigger the Effect chain again and change the data you're showing. Such code is often rigid and fragile.</p> <p>In this case, it's better to calculate what you can during rendering, and adjust the state in the event handler:</p> <pre><code>function Game() {\nconst [card, setCard] = useState(null);\nconst [goldCardCount, setGoldCardCount] = useState(0);\nconst [round, setRound] = useState(1);\n\n// \u2705 Calculate what you can during rendering\nconst isGameOver = round &gt; 5;\n\nfunction handlePlaceCard(nextCard) {\nif (isGameOver) {\nthrow Error('Game already ended.');\n}\n\n// \u2705 Calculate all the next state in the event handler\nsetCard(nextCard);\nif (nextCard.gold) {\nif (goldCardCount &lt;= 3) {\nsetGoldCardCount(goldCardCount + 1);\n} else {\nsetGoldCardCount(0);\nsetRound(round + 1);\nif (round === 5) {\nalert('Good game!');\n}\n}\n}\n}\n\n// ...\n</code></pre> <p>This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can extract a function and call it from those handlers.</p> <p>Remember that inside event handlers, state behaves like a snapshot. For example, even after you call <code>setRound(round + 1)</code>, the <code>round</code> variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like <code>const nextRound = round + 1</code>.</p> <p>In some cases, you can't calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.</p>"},{"location":"learn/you-might-not-need-an-effect/#initializing-the-application","title":"Initializing the application","text":"<p>Some logic should only run once when the app loads.</p> <p>You might be tempted to place it in an Effect in the top-level component:</p> <pre><code>function App() {\n// \ud83d\udd34 Avoid: Effects with logic that should only ever run once\nuseEffect(() =&gt; {\nloadDataFromLocalStorage();\ncheckAuthToken();\n}, []);\n// ...\n}\n</code></pre> <p>However, you'll quickly discover that it runs twice in development. This can cause issues--for example, maybe it invalidates the authentication token because the function wasn't designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level <code>App</code> component.</p> <p>Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run once per app load rather than once per component mount, add a top-level variable to track whether it has already executed:</p> <pre><code>let didInit = false;\n\nfunction App() {\nuseEffect(() =&gt; {\nif (!didInit) {\ndidInit = true;\n// \u2705 Only runs once per app load\nloadDataFromLocalStorage();\ncheckAuthToken();\n}\n}, []);\n// ...\n}\n</code></pre> <p>You can also run it during module initialization and before the app renders:</p> <pre><code>if (typeof window !== \"undefined\") {\n// Check if we're running in the browser.\n// \u2705 Only runs once per app load\ncheckAuthToken();\nloadDataFromLocalStorage();\n}\n\nfunction App() {\n// ...\n}\n</code></pre> <p>Code at the top level runs once when your component is imported--even if it doesn't end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don't overuse this pattern. Keep app-wide initialization logic to root component modules like <code>App.js</code> or in your application's entry point.</p>"},{"location":"learn/you-might-not-need-an-effect/#notifying-parent-components-about-state-changes","title":"Notifying parent components about state changes","text":"<p>Let's say you're writing a <code>Toggle</code> component with an internal <code>isOn</code> state which can be either <code>true</code> or <code>false</code>. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the <code>Toggle</code> internal state changes, so you expose an <code>onChange</code> event and call it from an Effect:</p> <pre><code>function Toggle({ onChange }) {\nconst [isOn, setIsOn] = useState(false);\n\n// \ud83d\udd34 Avoid: The onChange handler runs too late\nuseEffect(() =&gt; {\nonChange(isOn);\n}, [isOn, onChange]);\n\nfunction handleClick() {\nsetIsOn(!isOn);\n}\n\nfunction handleDragEnd(e) {\nif (isCloserToRightEdge(e)) {\nsetIsOn(true);\n} else {\nsetIsOn(false);\n}\n}\n\n// ...\n}\n</code></pre> <p>Like earlier, this is not ideal. The <code>Toggle</code> updates its state first, and React updates the screen. Then React runs the Effect, which calls the <code>onChange</code> function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.</p> <p>Delete the Effect and instead update the state of both components within the same event handler:</p> <pre><code>function Toggle({ onChange }) {\nconst [isOn, setIsOn] = useState(false);\n\nfunction updateToggle(nextIsOn) {\n// \u2705 Good: Perform all updates during the event that caused them\nsetIsOn(nextIsOn);\nonChange(nextIsOn);\n}\n\nfunction handleClick() {\nupdateToggle(!isOn);\n}\n\nfunction handleDragEnd(e) {\nif (isCloserToRightEdge(e)) {\nupdateToggle(true);\n} else {\nupdateToggle(false);\n}\n}\n\n// ...\n}\n</code></pre> <p>With this approach, both the <code>Toggle</code> component and its parent component update their state during the event. React batches updates from different components together, so there will only be one render pass.</p> <p>You might also be able to remove the state altogether, and instead receive <code>isOn</code> from the parent component:</p> <pre><code>// \u2705 Also good: the component is fully controlled by its parent\nfunction Toggle({ isOn, onChange }) {\nfunction handleClick() {\nonChange(!isOn);\n}\n\nfunction handleDragEnd(e) {\nif (isCloserToRightEdge(e)) {\nonChange(true);\n} else {\nonChange(false);\n}\n}\n\n// ...\n}\n</code></pre> <p>\"Lifting state up\" lets the parent component fully control the <code>Toggle</code> by toggling the parent's own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!</p>"},{"location":"learn/you-might-not-need-an-effect/#passing-data-to-the-parent","title":"Passing data to the parent","text":"<p>This <code>Child</code> component fetches some data and then passes it to the <code>Parent</code> component in an Effect:</p> <pre><code>function Parent() {\nconst [data, setData] = useState(null);\n// ...\nreturn &lt;Child onFetched={setData} /&gt;;\n}\n\nfunction Child({ onFetched }) {\nconst data = useSomeAPI();\n// \ud83d\udd34 Avoid: Passing data to the parent in an Effect\nuseEffect(() =&gt; {\nif (data) {\nonFetched(data);\n}\n}, [onFetched, data]);\n// ...\n}\n</code></pre> <p>In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child instead:</p> <pre><code>function Parent() {\nconst data = useSomeAPI();\n// ...\n// \u2705 Good: Passing data down to the child\nreturn &lt;Child data={data} /&gt;;\n}\n\nfunction Child({ data }) {\n// ...\n}\n</code></pre> <p>This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>"},{"location":"learn/you-might-not-need-an-effect/#subscribing-to-an-external-store","title":"Subscribing to an external store","text":"<p>Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React's knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:</p> <pre><code>function useOnlineStatus() {\n// Not ideal: Manual store subscription in an Effect\nconst [isOnline, setIsOnline] = useState(true);\nuseEffect(() =&gt; {\nfunction updateState() {\nsetIsOnline(navigator.onLine);\n}\n\nupdateState();\n\nwindow.addEventListener(\"online\", updateState);\nwindow.addEventListener(\"offline\", updateState);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", updateState);\nwindow.removeEventListener(\"offline\", updateState);\n};\n}, []);\nreturn isOnline;\n}\n\nfunction ChatIndicator() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n</code></pre> <p>Here, the component subscribes to an external data store (in this case, the browser <code>navigator.onLine</code> API). Since this API does not exist on the server (so it can't be used for the initial HTML), initially the state is set to <code>true</code>. Whenever the value of that data store changes in the browser, the component updates its state.</p> <p>Although it's common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to <code>useSyncExternalStore</code>:</p> <pre><code>function subscribe(callback) {\nwindow.addEventListener(\"online\", callback);\nwindow.addEventListener(\"offline\", callback);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", callback);\nwindow.removeEventListener(\"offline\", callback);\n};\n}\n\nfunction useOnlineStatus() {\n// \u2705 Good: Subscribing to an external store with a built-in Hook\nreturn useSyncExternalStore(\nsubscribe, // React won't resubscribe for as long as you pass the same function\n() =&gt; navigator.onLine, // How to get the value on the client\n() =&gt; true // How to get the value on the server\n);\n}\n\nfunction ChatIndicator() {\nconst isOnline = useOnlineStatus();\n// ...\n}\n</code></pre> <p>This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you'll write a custom Hook like <code>useOnlineStatus()</code> above so that you don't need to repeat this code in the individual components. Read more about subscribing to external stores from React components.</p>"},{"location":"learn/you-might-not-need-an-effect/#fetching-data","title":"Fetching data","text":"<p>Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:</p> <pre><code>function SearchResults({ query }) {\nconst [results, setResults] = useState([]);\nconst [page, setPage] = useState(1);\n\nuseEffect(() =&gt; {\n// \ud83d\udd34 Avoid: Fetching without cleanup logic\nfetchResults(query, page).then((json) =&gt; {\nsetResults(json);\n});\n}, [query, page]);\n\nfunction handleNextPageClick() {\nsetPage(page + 1);\n}\n// ...\n}\n</code></pre> <p>You don't need to move this fetch to an event handler.</p> <p>This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it's not the typing event that's the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.</p> <p>It doesn't matter where <code>page</code> and <code>query</code> come from. While this component is visible, you want to keep <code>results</code> synchronized with data from the network for the current <code>page</code> and <code>query</code>. This is why it's an Effect.</p> <p>However, the code above has a bug. Imagine you type <code>\"hello\"</code> fast. Then the <code>query</code> will change from <code>\"h\"</code>, to <code>\"he\"</code>, <code>\"hel\"</code>, <code>\"hell\"</code>, and <code>\"hello\"</code>. This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the <code>\"hell\"</code> response may arrive after the <code>\"hello\"</code> response. Since it will call <code>setResults()</code> last, you will be displaying the wrong search results. This is called a \"race condition\": two different requests \"raced\" against each other and came in a different order than you expected.</p> <p>To fix the race condition, you need to add a cleanup function to ignore stale responses:</p> <pre><code>function SearchResults({ query }) {\nconst [results, setResults] = useState([]);\nconst [page, setPage] = useState(1);\nuseEffect(() =&gt; {\nlet ignore = false;\nfetchResults(query, page).then((json) =&gt; {\nif (!ignore) {\nsetResults(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [query, page]);\n\nfunction handleNextPageClick() {\nsetPage(page + 1);\n}\n// ...\n}\n</code></pre> <p>This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.</p> <p>Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).</p> <p>These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern frameworks provide more efficient built-in data fetching mechanisms than fetching data in Effects.</p> <p>If you don't use a framework (and don't want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:</p> <pre><code>function SearchResults({ query }) {\nconst [page, setPage] = useState(1);\nconst params = new URLSearchParams({ query, page });\nconst results = useData(`/api/search?${params}`);\n\nfunction handleNextPageClick() {\nsetPage(page + 1);\n}\n// ...\n}\n\nfunction useData(url) {\nconst [data, setData] = useState(null);\nuseEffect(() =&gt; {\nlet ignore = false;\nfetch(url)\n.then((response) =&gt; response.json())\n.then((json) =&gt; {\nif (!ignore) {\nsetData(json);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [url]);\nreturn data;\n}\n</code></pre> <p>You'll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. Although this alone won't be as efficient as using a framework's built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.</p> <p>In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like <code>useData</code> above. The fewer raw <code>useEffect</code> calls you have in your components, the easier you will find to maintain your application.</p> <p> <ul> <li>If you can calculate something during render, you don't need an Effect.</li> <li>To cache expensive calculations, add <code>useMemo</code> instead of <code>useEffect</code>.</li> <li>To reset the state of an entire component tree, pass a different <code>key</code> to it.</li> <li>To reset a particular bit of state in response to a prop change, set it during rendering.</li> <li>Code that runs because a component was displayed should be in Effects, the rest should be in events.</li> <li>If you need to update the state of several components, it's better to do it during a single event.</li> <li>Whenever you try to synchronize state variables in different components, consider lifting state up.</li> <li>You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.</li> </ul> <p></p> <p>"},{"location":"learn/you-might-not-need-an-effect/#transform-data-without-effects","title":"Transform data without Effects","text":"<p>The <code>TodoList</code> below displays a list of todos. When the \"Show only active todos\" checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed.</p> <p>Simplify this component by removing all the unnecessary state and Effects.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { initialTodos, createTodo } from \"./todos.js\";\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(initialTodos);\nconst [showActive, setShowActive] = useState(false);\nconst [activeTodos, setActiveTodos] = useState([]);\nconst [visibleTodos, setVisibleTodos] = useState([]);\nconst [footer, setFooter] = useState(null);\n\nuseEffect(() =&gt; {\nsetActiveTodos(todos.filter((todo) =&gt; !todo.completed));\n}, [todos]);\n\nuseEffect(() =&gt; {\nsetVisibleTodos(showActive ? activeTodos : todos);\n}, [showActive, todos, activeTodos]);\n\nuseEffect(() =&gt; {\nsetFooter(&lt;footer&gt;{activeTodos.length} todos left&lt;/footer&gt;);\n}, [activeTodos]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showActive}\nonChange={(e) =&gt; setShowActive(e.target.checked)}\n/&gt;\nShow only active todos\n&lt;/label&gt;\n&lt;NewTodo onAdd={(newTodo) =&gt; setTodos([...todos, newTodo])} /&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n{footer}\n&lt;/&gt;\n);\n}\n\nfunction NewTodo({ onAdd }) {\nconst [text, setText] = useState(\"\");\n\nfunction handleAddClick() {\nsetText(\"\");\nonAdd(createTodo(text));\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleAddClick}&gt;Add&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>let nextId = 0;\n\nexport function createTodo(text, completed = false) {\nreturn {\nid: nextId++,\ntext,\ncompleted,\n};\n}\n\nexport const initialTodos = [\ncreateTodo(\"Get apples\", true),\ncreateTodo(\"Get oranges\", true),\ncreateTodo(\"Get carrots\"),\n];\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-top: 10px;\n}\n</code></pre> <p> <p>If you can calculate something during rendering, you don't need state or an Effect that updates it.</p> <p></p> <p> <p>There are only two essential pieces of state in this example: the list of <code>todos</code> and the <code>showActive</code> state variable which represents whether the checkbox is ticked. All of the other state variables are redundant and can be calculated during rendering instead. This includes the <code>footer</code> which you can move directly into the surrounding JSX.</p> <p>Your result should end up looking like this:</p> <pre><code>import { useState } from \"react\";\nimport { initialTodos, createTodo } from \"./todos.js\";\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(initialTodos);\nconst [showActive, setShowActive] = useState(false);\nconst activeTodos = todos.filter((todo) =&gt; !todo.completed);\nconst visibleTodos = showActive ? activeTodos : todos;\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showActive}\nonChange={(e) =&gt; setShowActive(e.target.checked)}\n/&gt;\nShow only active todos\n&lt;/label&gt;\n&lt;NewTodo onAdd={(newTodo) =&gt; setTodos([...todos, newTodo])} /&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;footer&gt;{activeTodos.length} todos left&lt;/footer&gt;\n&lt;/&gt;\n);\n}\n\nfunction NewTodo({ onAdd }) {\nconst [text, setText] = useState(\"\");\n\nfunction handleAddClick() {\nsetText(\"\");\nonAdd(createTodo(text));\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleAddClick}&gt;Add&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>let nextId = 0;\n\nexport function createTodo(text, completed = false) {\nreturn {\nid: nextId++,\ntext,\ncompleted,\n};\n}\n\nexport const initialTodos = [\ncreateTodo(\"Get apples\", true),\ncreateTodo(\"Get oranges\", true),\ncreateTodo(\"Get carrots\"),\n];\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-top: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/you-might-not-need-an-effect/#cache-a-calculation-without-effects","title":"Cache a calculation without Effects","text":"<p>In this example, filtering the todos was extracted into a separate function called <code>getVisibleTodos()</code>. This function contains a <code>console.log()</code> call inside of it which helps you notice when it's being called. Toggle \"Show only active todos\" and notice that it causes <code>getVisibleTodos()</code> to re-run. This is expected because visible todos change when you toggle which ones to display.</p> <p>Your task is to remove the Effect that recomputes the <code>visibleTodos</code> list in the <code>TodoList</code> component. However, you need to make sure that <code>getVisibleTodos()</code> does not re-run (and so does not print any logs) when you type into the input.</p> <p> <p>One solution is to add a <code>useMemo</code> call to cache the visible todos. There is also another, less obvious solution.</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\nimport { initialTodos, createTodo, getVisibleTodos } from \"./todos.js\";\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(initialTodos);\nconst [showActive, setShowActive] = useState(false);\nconst [text, setText] = useState(\"\");\nconst [visibleTodos, setVisibleTodos] = useState([]);\n\nuseEffect(() =&gt; {\nsetVisibleTodos(getVisibleTodos(todos, showActive));\n}, [todos, showActive]);\n\nfunction handleAddClick() {\nsetText(\"\");\nsetTodos([...todos, createTodo(text)]);\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showActive}\nonChange={(e) =&gt; setShowActive(e.target.checked)}\n/&gt;\nShow only active todos\n&lt;/label&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleAddClick}&gt;Add&lt;/button&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>let nextId = 0;\nlet calls = 0;\n\nexport function getVisibleTodos(todos, showActive) {\nconsole.log(`getVisibleTodos() was called ${++calls} times`);\nconst activeTodos = todos.filter((todo) =&gt; !todo.completed);\nconst visibleTodos = showActive ? activeTodos : todos;\nreturn visibleTodos;\n}\n\nexport function createTodo(text, completed = false) {\nreturn {\nid: nextId++,\ntext,\ncompleted,\n};\n}\n\nexport const initialTodos = [\ncreateTodo(\"Get apples\", true),\ncreateTodo(\"Get oranges\", true),\ncreateTodo(\"Get carrots\"),\n];\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-top: 10px;\n}\n</code></pre> <p> <p>Remove the state variable and the Effect, and instead add a <code>useMemo</code> call to cache the result of calling <code>getVisibleTodos()</code>:</p> <pre><code>import { useState, useMemo } from \"react\";\nimport { initialTodos, createTodo, getVisibleTodos } from \"./todos.js\";\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(initialTodos);\nconst [showActive, setShowActive] = useState(false);\nconst [text, setText] = useState(\"\");\nconst visibleTodos = useMemo(\n() =&gt; getVisibleTodos(todos, showActive),\n[todos, showActive]\n);\n\nfunction handleAddClick() {\nsetText(\"\");\nsetTodos([...todos, createTodo(text)]);\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showActive}\nonChange={(e) =&gt; setShowActive(e.target.checked)}\n/&gt;\nShow only active todos\n&lt;/label&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleAddClick}&gt;Add&lt;/button&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>let nextId = 0;\nlet calls = 0;\n\nexport function getVisibleTodos(todos, showActive) {\nconsole.log(`getVisibleTodos() was called ${++calls} times`);\nconst activeTodos = todos.filter((todo) =&gt; !todo.completed);\nconst visibleTodos = showActive ? activeTodos : todos;\nreturn visibleTodos;\n}\n\nexport function createTodo(text, completed = false) {\nreturn {\nid: nextId++,\ntext,\ncompleted,\n};\n}\n\nexport const initialTodos = [\ncreateTodo(\"Get apples\", true),\ncreateTodo(\"Get oranges\", true),\ncreateTodo(\"Get carrots\"),\n];\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-top: 10px;\n}\n</code></pre> <p>With this change, <code>getVisibleTodos()</code> will be called only if <code>todos</code> or <code>showActive</code> change. Typing into the input only changes the <code>text</code> state variable, so it does not trigger a call to <code>getVisibleTodos()</code>.</p> <p>There is also another solution which does not need <code>useMemo</code>. Since the <code>text</code> state variable can't possibly affect the list of todos, you can extract the <code>NewTodo</code> form into a separate component, and move the <code>text</code> state variable inside of it:</p> <pre><code>import { useState, useMemo } from \"react\";\nimport { initialTodos, createTodo, getVisibleTodos } from \"./todos.js\";\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(initialTodos);\nconst [showActive, setShowActive] = useState(false);\nconst visibleTodos = getVisibleTodos(todos, showActive);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={showActive}\nonChange={(e) =&gt; setShowActive(e.target.checked)}\n/&gt;\nShow only active todos\n&lt;/label&gt;\n&lt;NewTodo onAdd={(newTodo) =&gt; setTodos([...todos, newTodo])} /&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n\nfunction NewTodo({ onAdd }) {\nconst [text, setText] = useState(\"\");\n\nfunction handleAddClick() {\nsetText(\"\");\nonAdd(createTodo(text));\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button on_click={handleAddClick}&gt;Add&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>let nextId = 0;\nlet calls = 0;\n\nexport function getVisibleTodos(todos, showActive) {\nconsole.log(`getVisibleTodos() was called ${++calls} times`);\nconst activeTodos = todos.filter((todo) =&gt; !todo.completed);\nconst visibleTodos = showActive ? activeTodos : todos;\nreturn visibleTodos;\n}\n\nexport function createTodo(text, completed = false) {\nreturn {\nid: nextId++,\ntext,\ncompleted,\n};\n}\n\nexport const initialTodos = [\ncreateTodo(\"Get apples\", true),\ncreateTodo(\"Get oranges\", true),\ncreateTodo(\"Get carrots\"),\n];\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-top: 10px;\n}\n</code></pre> <p>This approach satisfies the requirements too. When you type into the input, only the <code>text</code> state variable updates. Since the <code>text</code> state variable is in the child <code>NewTodo</code> component, the parent <code>TodoList</code> component won't get re-rendered. This is why <code>getVisibleTodos()</code> doesn't get called when you type. (It would still be called if the <code>TodoList</code> re-renders for another reason.)</p> <p></p>"},{"location":"learn/you-might-not-need-an-effect/#reset-state-without-effects","title":"Reset state without Effects","text":"<p>This <code>EditContact</code> component receives a contact object shaped like <code>{ id, name, email }</code> as the <code>savedContact</code> prop. Try editing the name and email input fields. When you press Save, the contact's button above the form updates to the edited name. When you press Reset, any pending changes in the form are discarded. Play around with this UI to get a feel for it.</p> <p>When you select a contact with the buttons at the top, the form resets to reflect that contact's details. This is done with an Effect inside <code>EditContact.js</code>. Remove this Effect. Find another way to reset the form when <code>savedContact.id</code> changes.</p> <pre><code>import { useState } from \"react\";\nimport ContactList from \"./ContactList.js\";\nimport EditContact from \"./EditContact.js\";\n\nexport default function ContactManager() {\nconst [contacts, setContacts] = useState(initialContacts);\nconst [selectedId, setSelectedId] = useState(0);\nconst selectedContact = contacts.find((c) =&gt; c.id === selectedId);\n\nfunction handleSave(updatedData) {\nconst nextContacts = contacts.map((c) =&gt; {\nif (c.id === updatedData.id) {\nreturn updatedData;\n} else {\nreturn c;\n}\n});\nsetContacts(nextContacts);\n}\n\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={selectedId}\nonSelect={(id) =&gt; setSelectedId(id)}\n/&gt;\n&lt;hr /&gt;\n&lt;EditContact savedContact={selectedContact} onSave={handleSave} /&gt;\n&lt;/div&gt;\n);\n}\n\nconst initialContacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, onSelect }) {\nreturn (\n&lt;section&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact.id);\n}}\n&gt;\n{contact.id === selectedId ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function EditContact({ savedContact, onSave }) {\nconst [name, setName] = useState(savedContact.name);\nconst [email, setEmail] = useState(savedContact.email);\n\nuseEffect(() =&gt; {\nsetName(savedContact.name);\nsetEmail(savedContact.email);\n}, [savedContact]);\n\nreturn (\n&lt;section&gt;\n&lt;label&gt;\nName:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:{\" \"}\n&lt;input\ntype=\"email\"\nvalue={email}\nonChange={(e) =&gt; setEmail(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;button\non_click={() =&gt; {\nconst updatedData = {\nid: savedContact.id,\nname: name,\nemail: email,\n};\nonSave(updatedData);\n}}\n&gt;\nSave\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nsetName(savedContact.name);\nsetEmail(savedContact.email);\n}}\n&gt;\nReset\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\ndisplay: inline-block;\n}\nli button {\npadding: 10px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p> <p>It would be nice if there was a way to tell React that when <code>savedContact.id</code> is different, the <code>EditContact</code> form is conceptually a different contact's form and should not preserve state. Do you recall any such way?</p> <p></p> <p> <p>Split the <code>EditContact</code> component in two. Move all the form state into the inner <code>EditForm</code> component. Export the outer <code>EditContact</code> component, and make it pass <code>savedContact.id</code> as the <code>key</code> to the inner <code>EditContact</code> component. As a result, the inner <code>EditForm</code> component resets all of the form state and recreates the DOM whenever you select a different contact.</p> <pre><code>import { useState } from \"react\";\nimport ContactList from \"./ContactList.js\";\nimport EditContact from \"./EditContact.js\";\n\nexport default function ContactManager() {\nconst [contacts, setContacts] = useState(initialContacts);\nconst [selectedId, setSelectedId] = useState(0);\nconst selectedContact = contacts.find((c) =&gt; c.id === selectedId);\n\nfunction handleSave(updatedData) {\nconst nextContacts = contacts.map((c) =&gt; {\nif (c.id === updatedData.id) {\nreturn updatedData;\n} else {\nreturn c;\n}\n});\nsetContacts(nextContacts);\n}\n\nreturn (\n&lt;div&gt;\n&lt;ContactList\ncontacts={contacts}\nselectedId={selectedId}\nonSelect={(id) =&gt; setSelectedId(id)}\n/&gt;\n&lt;hr /&gt;\n&lt;EditContact savedContact={selectedContact} onSave={handleSave} /&gt;\n&lt;/div&gt;\n);\n}\n\nconst initialContacts = [\n{ id: 0, name: \"Taylor\", email: \"taylor@mail.com\" },\n{ id: 1, name: \"Alice\", email: \"alice@mail.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@mail.com\" },\n];\n</code></pre> <pre><code>export default function ContactList({ contacts, selectedId, onSelect }) {\nreturn (\n&lt;section&gt;\n&lt;ul&gt;\n{contacts.map((contact) =&gt; (\n&lt;li key={contact.id}&gt;\n&lt;button\non_click={() =&gt; {\nonSelect(contact.id);\n}}\n&gt;\n{contact.id === selectedId ? (\n&lt;b&gt;{contact.name}&lt;/b&gt;\n) : (\ncontact.name\n)}\n&lt;/button&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function EditContact(props) {\nreturn &lt;EditForm {...props} key={props.savedContact.id} /&gt;;\n}\n\nfunction EditForm({ savedContact, onSave }) {\nconst [name, setName] = useState(savedContact.name);\nconst [email, setEmail] = useState(savedContact.email);\n\nreturn (\n&lt;section&gt;\n&lt;label&gt;\nName:{\" \"}\n&lt;input\ntype=\"text\"\nvalue={name}\nonChange={(e) =&gt; setName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:{\" \"}\n&lt;input\ntype=\"email\"\nvalue={email}\nonChange={(e) =&gt; setEmail(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;button\non_click={() =&gt; {\nconst updatedData = {\nid: savedContact.id,\nname: name,\nemail: email,\n};\nonSave(updatedData);\n}}\n&gt;\nSave\n&lt;/button&gt;\n&lt;button\non_click={() =&gt; {\nsetName(savedContact.name);\nsetEmail(savedContact.email);\n}}\n&gt;\nReset\n&lt;/button&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>ul,\nli {\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nli {\ndisplay: inline-block;\n}\nli button {\npadding: 10px;\n}\nlabel {\ndisplay: block;\nmargin: 10px 0;\n}\nbutton {\nmargin-right: 10px;\nmargin-bottom: 10px;\n}\n</code></pre> <p></p>"},{"location":"learn/you-might-not-need-an-effect/#submit-a-form-without-effects","title":"Submit a form without Effects","text":"<p>This <code>Form</code> component lets you send a message to a friend. When you submit the form, the <code>showForm</code> state variable is set to <code>false</code>. This triggers an Effect calling <code>sendMessage(message)</code>, which sends the message (you can see it in the console). After the message is sent, you see a \"Thank you\" dialog with an \"Open chat\" button that lets you get back to the form.</p> <p>Your app's users are sending way too many messages. To make chatting a little bit more difficult, you've decided to show the \"Thank you\" dialog first rather than the form. Change the <code>showForm</code> state variable to initialize to <code>false</code> instead of <code>true</code>. As soon as you make that change, the console will show that an empty message was sent. Something in this logic is wrong!</p> <p>What's the root cause of this problem? And how can you fix it?</p> <p> <p>Should the message be sent because the user saw the \"Thank you\" dialog? Or is it the other way around?</p> <p></p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Form() {\nconst [showForm, setShowForm] = useState(true);\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nif (!showForm) {\nsendMessage(message);\n}\n}, [showForm, message]);\n\nfunction handleSubmit(e) {\ne.preventDefault();\nsetShowForm(false);\n}\n\nif (!showForm) {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Thanks for using our services!&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetMessage(\"\");\nsetShowForm(true);\n}}\n&gt;\nOpen chat\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button type=\"submit\" disabled={message === \"\"}&gt;\nSend\n&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n\nfunction sendMessage(message) {\nconsole.log(\"Sending message: \" + message);\n}\n</code></pre> <pre><code>label,\ntextarea {\nmargin-bottom: 10px;\ndisplay: block;\n}\n</code></pre> <p> <p>The <code>showForm</code> state variable determines whether to show the form or the \"Thank you\" dialog. However, you aren't sending the message because the \"Thank you\" dialog was displayed. You want to send the message because the user has submitted the form. Delete the misleading Effect and move the <code>sendMessage</code> call inside the <code>handleSubmit</code> event handler:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Form() {\nconst [showForm, setShowForm] = useState(true);\nconst [message, setMessage] = useState(\"\");\n\nfunction handleSubmit(e) {\ne.preventDefault();\nsetShowForm(false);\nsendMessage(message);\n}\n\nif (!showForm) {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Thanks for using our services!&lt;/h1&gt;\n&lt;button\non_click={() =&gt; {\nsetMessage(\"\");\nsetShowForm(true);\n}}\n&gt;\nOpen chat\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;textarea\nplaceholder=\"Message\"\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;button type=\"submit\" disabled={message === \"\"}&gt;\nSend\n&lt;/button&gt;\n&lt;/form&gt;\n);\n}\n\nfunction sendMessage(message) {\nconsole.log(\"Sending message: \" + message);\n}\n</code></pre> <pre><code>label,\ntextarea {\nmargin-bottom: 10px;\ndisplay: block;\n}\n</code></pre> <p>Notice how in this version, only submitting the form (which is an event) causes the message to be sent. It works equally well regardless of whether <code>showForm</code> is initially set to <code>true</code> or <code>false</code>. (Set it to <code>false</code> and notice no extra console messages.)</p> <p></p> <p></p>"},{"location":"learn/your-first-component/","title":"Your First Component \ud83d\udea7","text":""},{"location":"learn/your-first-component/#overview","title":"Overview","text":"<p> Components are one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!  </p> <p>You will learn</p> <ul> <li>What a component is</li> <li>What role components play in a React application</li> <li>How to write your first React component</li> </ul>"},{"location":"learn/your-first-component/#components-ui-building-blocks","title":"Components: UI building blocks","text":"<p>On the Web, HTML lets us create rich structured documents with its built-in set of tags like <code>&lt;h1&gt;</code> and <code>&lt;li&gt;</code>:</p> <pre><code>&lt;article&gt;\n    &lt;h1&gt;My First Component&lt;/h1&gt;\n    &lt;ol&gt;\n        &lt;li&gt;Components: UI Building Blocks&lt;/li&gt;\n        &lt;li&gt;Defining a Component&lt;/li&gt;\n        &lt;li&gt;Using a Component&lt;/li&gt;\n    &lt;/ol&gt;\n&lt;/article&gt;\n</code></pre> <p>This markup represents this article <code>&lt;article&gt;</code>, its heading <code>&lt;h1&gt;</code>, and an (abbreviated) table of contents as an ordered list <code>&lt;ol&gt;</code>. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown\u2014every piece of UI you see on the Web.</p> <p>React lets you combine your markup, CSS, and JavaScript into custom \"components\", reusable UI elements for your app. The table of contents code you saw above could be turned into a <code>&lt;TableOfContents /&gt;</code> component you could render on every page. Under the hood, it still uses the same HTML tags like <code>&lt;article&gt;</code>, <code>&lt;h1&gt;</code>, etc.</p> <p>Just like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you're reading is made out of React components:</p> <pre><code>&lt;PageLayout&gt;\n&lt;NavigationHeader&gt;\n&lt;SearchBar /&gt;\n&lt;Link to=\"/docs\"&gt;Docs&lt;/Link&gt;\n&lt;/NavigationHeader&gt;\n&lt;Sidebar /&gt;\n&lt;PageContent&gt;\n&lt;TableOfContents /&gt;\n&lt;DocumentationText /&gt;\n&lt;/PageContent&gt;\n&lt;/PageLayout&gt;\n</code></pre> <p>As your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with <code>&lt;TableOfContents /&gt;</code>! You can even jumpstart your project with the thousands of components shared by the React open source community like Chakra UI and Material UI.</p>"},{"location":"learn/your-first-component/#defining-a-component","title":"Defining a component","text":"<p>Traditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology: a React component is a JavaScript function that you can sprinkle with markup. Here's what that looks like (you can edit the example below):</p> <pre><code>export default function Profile() {\nreturn (\n&lt;img src=\"https://i.imgur.com/MK3eW3Am.jpg\" alt=\"Katherine Johnson\" /&gt;\n);\n}\n</code></pre> <pre><code>img {\nheight: 200px;\n}\n</code></pre> <p>And here's how to build a component:</p>"},{"location":"learn/your-first-component/#step-1-export-the-component","title":"Step 1: Export the component","text":"<p>The <code>export default</code> prefix is a standard JavaScript syntax (not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing in Importing and Exporting Components!)</p>"},{"location":"learn/your-first-component/#step-2-define-the-function","title":"Step 2: Define the function","text":"<p>With <code>function Profile() { }</code> you define a JavaScript function with the name <code>Profile</code>.</p> <p> <p>React components are regular JavaScript functions, but their names must start with a capital letter or they won't work!</p> <p></p>"},{"location":"learn/your-first-component/#step-3-add-markup","title":"Step 3: Add markup","text":"<p>The component returns an <code>&lt;img /&gt;</code> tag with <code>src</code> and <code>alt</code> attributes. <code>&lt;img /&gt;</code> is written like HTML, but it is actually JavaScript under the hood! This syntax is called JSX, and it lets you embed markup inside JavaScript.</p> <p>Return statements can be written all on one line, as in this component:</p> <pre><code>return &lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;;\n</code></pre> <p>But if your markup isn't all on the same line as the <code>return</code> keyword, you must wrap it in a pair of parentheses:</p> <pre><code>return (\n&lt;div&gt;\n&lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n&lt;/div&gt;\n);\n</code></pre> <p> <p>Without parentheses, any code on the lines after <code>return</code> will be ignored!</p> <p></p>"},{"location":"learn/your-first-component/#using-a-component","title":"Using a component","text":"<p>Now that you've defined your <code>Profile</code> component, you can nest it inside other components. For example, you can export a <code>Gallery</code> component that uses multiple <code>Profile</code> components:</p> <pre><code>function Profile() {\nreturn (\n&lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n);\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre>"},{"location":"learn/your-first-component/#what-the-browser-sees","title":"What the browser sees","text":"<p>Notice the difference in casing:</p> <ul> <li><code>&lt;section&gt;</code> is lowercase, so React knows we refer to an HTML tag.</li> <li><code>&lt;Profile /&gt;</code> starts with a capital <code>P</code>, so React knows that we want to use our component called <code>Profile</code>.</li> </ul> <p>And <code>Profile</code> contains even more HTML: <code>&lt;img /&gt;</code>. In the end, this is what the browser sees:</p> <pre><code>&lt;section&gt;\n    &lt;h1&gt;Amazing scientists&lt;/h1&gt;\n    &lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n    &lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n    &lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt;\n&lt;/section&gt;\n</code></pre>"},{"location":"learn/your-first-component/#nesting-and-organizing-components","title":"Nesting and organizing components","text":"<p>Components are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always move <code>Profile</code> to a separate file. You will learn how to do this shortly on the page about imports.</p> <p>Because the <code>Profile</code> components are rendered inside <code>Gallery</code>\u2014even several times!\u2014we can say that <code>Gallery</code> is a parent component, rendering each <code>Profile</code> as a \"child\". This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like.</p> <p> <p>Components can render other components, but you must never nest their definitions:</p> <pre><code>export default function Gallery() {\n// \ud83d\udd34 Never define a component inside another component!\nfunction Profile() {\n// ...\n}\n// ...\n}\n</code></pre> <p>The snippet above is very slow and causes bugs. Instead, define every component at the top level:</p> <pre><code>export default function Gallery() {\n// ...\n}\n\n// \u2705 Declare components at the top level\nfunction Profile() {\n// ...\n}\n</code></pre> <p>When a child component needs some data from a parent, pass it by props instead of nesting definitions.</p> <p></p> <p>"},{"location":"learn/your-first-component/#components-all-the-way-down","title":"Components all the way down","text":"<p>Your React application begins at a \"root\" component. Usually, it is created automatically when you start a new project. For example, if you use CodeSandbox or Create React App, the root component is defined in <code>src/App.js</code>. If you use the framework Next.js, the root component is defined in <code>pages/index.js</code>. In these examples, you've been exporting root components.</p> <p>Most React apps use components all the way down. This means that you won't only use components for reusable pieces like buttons, but also for larger pieces like sidebars, lists, and ultimately, complete pages! Components are a handy way to organize UI code and markup, even if some of them are only used once.</p> <p>React-based frameworks take this a step further. Instead of using an empty HTML file and letting React \"take over\" managing the page with JavaScript, they also generate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.</p> <p>Still, many websites only use React to add interactivity to existing HTML pages. They have many root components instead of a single one for the entire page. You can use as much\u2014or as little\u2014React as you need.</p> <p></p> <p> <p>You've just gotten your first taste of React! Let's recap some key points.</p> <ul> <li>React lets you create components, reusable UI elements for your app.</li> <li>In a React app, every piece of UI is a component.</li> <li> <p>React components are regular JavaScript functions except:</p> <ol> <li>Their names always begin with a capital letter.</li> <li>They return JSX markup.</li> </ol> </li> </ul> <p></p> <p>"},{"location":"learn/your-first-component/#export-the-component","title":"Export the component","text":"<p>This sandbox doesn't work because the root component is not exported:</p> <pre><code>function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/lICfvbD.jpg\" alt=\"Aklilu Lemma\" /&gt;;\n}\n</code></pre> <pre><code>img {\nheight: 181px;\n}\n</code></pre> <p>Try to fix it yourself before looking at the solution!</p> <p> <p>Add <code>export default</code> before the function definition like so:</p> <pre><code>export default function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/lICfvbD.jpg\" alt=\"Aklilu Lemma\" /&gt;;\n}\n</code></pre> <pre><code>img {\nheight: 181px;\n}\n</code></pre> <p>You might be wondering why writing <code>export</code> alone is not enough to fix this example. You can learn the difference between <code>export</code> and <code>export default</code> in Importing and Exporting Components.</p> <p></p>"},{"location":"learn/your-first-component/#fix-the-return-statement","title":"Fix the return statement","text":"<p>Something isn't right about this <code>return</code> statement. Can you fix it?</p> <p> <p>You may get an \"Unexpected token\" error while trying to fix this. In that case, check that the semicolon appears after the closing parenthesis. Leaving a semicolon inside <code>return ( )</code> will cause an error.</p> <p></p> <pre><code>export default function Profile() {\nreturn;\n&lt;img src=\"https://i.imgur.com/jA8hHMpm.jpg\" alt=\"Katsuko Saruhashi\" /&gt;;\n}\n</code></pre> <pre><code>img {\nheight: 180px;\n}\n</code></pre> <p> <p>You can fix this component by moving the return statement to one line like so:</p> <pre><code>export default function Profile() {\nreturn (\n&lt;img src=\"https://i.imgur.com/jA8hHMpm.jpg\" alt=\"Katsuko Saruhashi\" /&gt;\n);\n}\n</code></pre> <pre><code>img {\nheight: 180px;\n}\n</code></pre> <p>Or by wrapping the returned JSX markup in parentheses that open right after <code>return</code>:</p> <pre><code>export default function Profile() {\nreturn (\n&lt;img src=\"https://i.imgur.com/jA8hHMpm.jpg\" alt=\"Katsuko Saruhashi\" /&gt;\n);\n}\n</code></pre> <pre><code>img {\nheight: 180px;\n}\n</code></pre> <p></p>"},{"location":"learn/your-first-component/#spot-the-mistake","title":"Spot the mistake","text":"<p>Something's wrong with how the <code>Profile</code> component is declared and used. Can you spot the mistake? (Try to remember how React distinguishes components from the regular HTML tags!)</p> <pre><code>function profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;profile /&gt;\n&lt;profile /&gt;\n&lt;profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\nheight: 90px;\n}\n</code></pre> <p> <p>React component names must start with a capital letter.</p> <p>Change <code>function profile()</code> to <code>function Profile()</code>, and then change every <code>&lt;profile /&gt;</code> to <code>&lt;Profile /&gt;</code>:</p> <pre><code>function Profile() {\nreturn &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt;;\n}\n\nexport default function Gallery() {\nreturn (\n&lt;section&gt;\n&lt;h1&gt;Amazing scientists&lt;/h1&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;Profile /&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>img {\nmargin: 0 10px 10px 0;\n}\n</code></pre> <p></p>"},{"location":"learn/your-first-component/#your-own-component","title":"Your own component","text":"<p>Write a component from scratch. You can give it any valid name and return any markup. If you're out of ideas, you can write a <code>Congratulations</code> component that shows <code>&lt;h1&gt;Good job!&lt;/h1&gt;</code>. Don't forget to export it!</p> <pre><code>// Write your component below!\n</code></pre> <p> <pre><code>export default function Congratulations() {\nreturn &lt;h1&gt;Good job!&lt;/h1&gt;;\n}\n</code></pre> <p></p> <p></p>"},{"location":"reference/common-props/","title":"Common Props \ud83d\udea7","text":""},{"location":"reference/common-props/#props","title":"Props","text":"<p>These special React props are supported for all built-in components:</p> <ul> <li> <p><code>children</code>: A React node (an element, a string, a number, a portal, an empty node like <code>null</code>, <code>undefined</code> and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the <code>children</code> prop implicitly by nesting tags like <code>&lt;div&gt;&lt;span /&gt;&lt;/div&gt;</code>.</p> </li> <li> <p><code>dangerouslySetInnerHTML</code>: An object of the form <code>{ __html: '&lt;p&gt;some html&lt;/p&gt;' }</code> with a raw HTML string inside. Overrides the <code>innerHTML</code> property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn't trusted (for example, if it's based on user data), you risk introducing an XSS vulnerability. Read more about using <code>dangerouslySetInnerHTML</code>.</p> </li> <li> <p><code>ref</code>: A ref object from <code>useRef</code> or <code>createRef</code>, or a <code>ref</code> callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs.</p> </li> <li> <p><code>suppressContentEditableWarning</code>: A boolean. If <code>true</code>, suppresses the warning that React shows for elements that both have <code>children</code> and <code>contentEditable={true}</code> (which normally do not work together). Use this if you're building a text input library that manages the <code>contentEditable</code> content manually.</p> </li> <li> <p><code>suppressHydrationWarning</code>: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set <code>suppressHydrationWarning</code> to <code>true</code>, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don't overuse it. Read about suppressing hydration errors.</p> </li> <li> <p><code>style</code>: An object with CSS styles, for example <code>{ fontWeight: 'bold', margin: 20 }</code>. Similarly to the DOM <code>style</code> property, the CSS property names need to be written as <code>camelCase</code>, for example <code>fontWeight</code> instead of <code>font-weight</code>. You can pass strings or numbers as values. If you pass a number, like <code>width: 100</code>, React will automatically append <code>px</code> (\"pixels\") to the value unless it's a unitless property. We recommend using <code>style</code> only for dynamic styles where you don't know the style values ahead of time. In other cases, applying plain CSS classes with <code>className</code> is more efficient. Read more about <code>className</code> and <code>style</code>.</p> </li> </ul> <p>These standard DOM props are also supported for all built-in components:</p> <ul> <li><code>accessKey</code>: A string. Specifies a keyboard shortcut for the element. Not generally recommended.</li> <li><code>aria-*</code>: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.</li> <li><code>autoCapitalize</code>: A string. Specifies whether and how the user input should be capitalized.</li> <li><code>className</code>: A string. Specifies the element's CSS class name. Read more about applying CSS styles.</li> <li><code>contentEditable</code>: A boolean. If <code>true</code>, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element with <code>contentEditable={true}</code> because React will not be able to update its content after user edits.</li> <li><code>data-*</code>: Data attributes let you attach some string data to the element, for example <code>data-fruit=\"banana\"</code>. In React, they are not commonly used because you would usually read data from props or state instead.</li> <li><code>dir</code>: Either <code>'ltr'</code> or <code>'rtl'</code>. Specifies the text direction of the element.</li> <li><code>draggable</code>: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API.</li> <li><code>enterKeyHint</code>: A string. Specifies which action to present for the enter key on virtual keyboards.</li> <li><code>htmlFor</code>: A string. For <code>&lt;label&gt;</code> and <code>&lt;output&gt;</code>, lets you associate the label with some control. Same as <code>for</code> HTML attribute. React uses the standard DOM property names (<code>htmlFor</code>) instead of HTML attribute names.</li> <li><code>hidden</code>: A boolean or a string. Specifies whether the element should be hidden.</li> <li><code>id</code>: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with <code>useId</code> to avoid clashes between multiple instances of the same component.</li> <li><code>is</code>: A string. If specified, the component will behave like a custom element.</li> <li><code>inputMode</code>: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).</li> <li><code>itemProp</code>: A string. Specifies which property the element represents for structured data crawlers.</li> <li><code>lang</code>: A string. Specifies the language of the element.</li> <li><code>onAnimationEnd</code>: An <code>AnimationEvent</code> handler function. Fires when a CSS animation completes.</li> <li><code>onAnimationEndCapture</code>: A version of <code>onAnimationEnd</code> that fires in the capture phase.</li> <li><code>onAnimationIteration</code>: An <code>AnimationEvent</code> handler function. Fires when an iteration of a CSS animation ends, and another one begins.</li> <li><code>onAnimationIterationCapture</code>: A version of <code>onAnimationIteration</code> that fires in the capture phase.</li> <li><code>onAnimationStart</code>: An <code>AnimationEvent</code> handler function. Fires when a CSS animation starts.</li> <li><code>onAnimationStartCapture</code>: <code>onAnimationStart</code>, but fires in the capture phase.</li> <li><code>onAuxClick</code>: A <code>MouseEvent</code> handler function. Fires when a non-primary pointer button was clicked.</li> <li><code>onAuxClickCapture</code>: A version of <code>onAuxClick</code> that fires in the capture phase.</li> <li><code>onBeforeInput</code>: An <code>InputEvent</code> handler function. Fires before the value of an editable element is modified. React does not yet use the native <code>beforeinput</code> event, and instead attempts to polyfill it using other events.</li> <li><code>onBeforeInputCapture</code>: A version of <code>onBeforeInput</code> that fires in the capture phase.</li> <li><code>onBlur</code>: A <code>FocusEvent</code> handler function. Fires when an element lost focus. Unlike the built-in browser <code>blur</code> event, in React the <code>onBlur</code> event bubbles.</li> <li><code>onBlurCapture</code>: A version of <code>onBlur</code> that fires in the capture phase.</li> <li><code>onClick</code>: A <code>MouseEvent</code> handler function. Fires when the primary button was clicked on the pointing device.</li> <li><code>onClickCapture</code>: A version of <code>onClick</code> that fires in the capture phase.</li> <li><code>onCompositionStart</code>: A <code>CompositionEvent</code> handler function. Fires when an input method editor starts a new composition session.</li> <li><code>onCompositionStartCapture</code>: A version of <code>onCompositionStart</code> that fires in the capture phase.</li> <li><code>onCompositionEnd</code>: A <code>CompositionEvent</code> handler function. Fires when an input method editor completes or cancels a composition session.</li> <li><code>onCompositionEndCapture</code>: A version of <code>onCompositionEnd</code> that fires in the capture phase.</li> <li><code>onCompositionUpdate</code>: A <code>CompositionEvent</code> handler function. Fires when an input method editor receives a new character.</li> <li><code>onCompositionUpdateCapture</code>: A version of <code>onCompositionUpdate</code> that fires in the capture phase.</li> <li><code>onContextMenu</code>: A <code>MouseEvent</code> handler function. Fires when the user tries to open a context menu.</li> <li><code>onContextMenuCapture</code>: A version of <code>onContextMenu</code> that fires in the capture phase.</li> <li><code>onCopy</code>: A <code>ClipboardEvent</code> handler function. Fires when the user tries to copy something into the clipboard.</li> <li><code>onCopyCapture</code>: A version of <code>onCopy</code> that fires in the capture phase.</li> <li><code>onCut</code>: A <code>ClipboardEvent</code> handler function. Fires when the user tries to cut something into the clipboard.</li> <li><code>onCutCapture</code>: A version of <code>onCut</code> that fires in the capture phase.</li> <li><code>onDoubleClick</code>: A <code>MouseEvent</code> handler function. Fires when the user clicks twice. Corresponds to the browser <code>dblclick</code> event.</li> <li><code>onDoubleClickCapture</code>: A version of <code>onDoubleClick</code> that fires in the capture phase.</li> <li><code>onDrag</code>: A <code>DragEvent</code> handler function. Fires while the user is dragging something.</li> <li><code>onDragCapture</code>: A version of <code>onDrag</code> that fires in the capture phase.</li> <li><code>onDragEnd</code>: A <code>DragEvent</code> handler function. Fires when the user stops dragging something.</li> <li><code>onDragEndCapture</code>: A version of <code>onDragEnd</code> that fires in the capture phase.</li> <li><code>onDragEnter</code>: A <code>DragEvent</code> handler function. Fires when the dragged content enters a valid drop target.</li> <li><code>onDragEnterCapture</code>: A version of <code>onDragEnter</code> that fires in the capture phase.</li> <li><code>onDragOver</code>: A <code>DragEvent</code> handler function. Fires on a valid drop target while the dragged content is dragged over it. You must call <code>e.preventDefault()</code> here to allow dropping.</li> <li><code>onDragOverCapture</code>: A version of <code>onDragOver</code> that fires in the capture phase.</li> <li><code>onDragStart</code>: A <code>DragEvent</code> handler function. Fires when the user starts dragging an element.</li> <li><code>onDragStartCapture</code>: A version of <code>onDragStart</code> that fires in the capture phase.</li> <li><code>onDrop</code>: A <code>DragEvent</code> handler function. Fires when something is dropped on a valid drop target.</li> <li><code>onDropCapture</code>: A version of <code>onDrop</code> that fires in the capture phase.</li> <li><code>onFocus</code>: A <code>FocusEvent</code> handler function. Fires when an element lost focus. Unlike the built-in browser <code>focus</code> event, in React the <code>onFocus</code> event bubbles.</li> <li><code>onFocusCapture</code>: A version of <code>onFocus</code> that fires in the capture phase.</li> <li><code>onGotPointerCapture</code>: A <code>PointerEvent</code> handler function. Fires when an element programmatically captures a pointer.</li> <li><code>onGotPointerCaptureCapture</code>: A version of <code>onGotPointerCapture</code> that fires in the capture phase.</li> <li><code>onKeyDown</code>: A <code>KeyboardEvent</code> handler function. Fires when a key is pressed.</li> <li><code>onKeyDownCapture</code>: A version of <code>onKeyDown</code> that fires in the capture phase.</li> <li><code>onKeyPress</code>: A <code>KeyboardEvent</code> handler function. Deprecated. Use <code>onKeyDown</code> or <code>onBeforeInput</code> instead.</li> <li><code>onKeyPressCapture</code>: A version of <code>onKeyPress</code> that fires in the capture phase.</li> <li><code>onKeyUp</code>: A <code>KeyboardEvent</code> handler function. Fires when a key is released.</li> <li><code>onKeyUpCapture</code>: A version of <code>onKeyUp</code> that fires in the capture phase.</li> <li><code>onLostPointerCapture</code>: A <code>PointerEvent</code> handler function. Fires when an element stops capturing a pointer.</li> <li><code>onLostPointerCaptureCapture</code>: A version of <code>onLostPointerCapture</code> that fires in the capture phase.</li> <li><code>onMouseDown</code>: A <code>MouseEvent</code> handler function. Fires when the pointer is pressed down.</li> <li><code>onMouseDownCapture</code>: A version of <code>onMouseDown</code> that fires in the capture phase.</li> <li><code>onMouseEnter</code>: A <code>MouseEvent</code> handler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, <code>onMouseLeave</code> and <code>onMouseEnter</code> propagate from the element being left to the one being entered.</li> <li><code>onMouseLeave</code>: A <code>MouseEvent</code> handler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, <code>onMouseLeave</code> and <code>onMouseEnter</code> propagate from the element being left to the one being entered.</li> <li><code>onMouseMove</code>: A <code>MouseEvent</code> handler function. Fires when the pointer changes coordinates.</li> <li><code>onMouseMoveCapture</code>: A version of <code>onMouseMove</code> that fires in the capture phase.</li> <li><code>onMouseOut</code>: A <code>MouseEvent</code> handler function. Fires when the pointer moves outside an element, or if it moves into a child element.</li> <li><code>onMouseOutCapture</code>: A version of <code>onMouseOut</code> that fires in the capture phase.</li> <li><code>onMouseUp</code>: A <code>MouseEvent</code> handler function. Fires when the pointer is released.</li> <li><code>onMouseUpCapture</code>: A version of <code>onMouseUp</code> that fires in the capture phase.</li> <li><code>onPointerCancel</code>: A <code>PointerEvent</code> handler function. Fires when the browser cancels a pointer interaction.</li> <li><code>onPointerCancelCapture</code>: A version of <code>onPointerCancel</code> that fires in the capture phase.</li> <li><code>onPointerDown</code>: A <code>PointerEvent</code> handler function. Fires when a pointer becomes active.</li> <li><code>onPointerDownCapture</code>: A version of <code>onPointerDown</code> that fires in the capture phase.</li> <li><code>onPointerEnter</code>: A <code>PointerEvent</code> handler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, <code>onPointerLeave</code> and <code>onPointerEnter</code> propagate from the element being left to the one being entered.</li> <li><code>onPointerLeave</code>: A <code>PointerEvent</code> handler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, <code>onPointerLeave</code> and <code>onPointerEnter</code> propagate from the element being left to the one being entered.</li> <li><code>onPointerMove</code>: A <code>PointerEvent</code> handler function. Fires when a pointer changes coordinates.</li> <li><code>onPointerMoveCapture</code>: A version of <code>onPointerMove</code> that fires in the capture phase.</li> <li><code>onPointerOut</code>: A <code>PointerEvent</code> handler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons.</li> <li><code>onPointerOutCapture</code>: A version of <code>onPointerOut</code> that fires in the capture phase.</li> <li><code>onPointerUp</code>: A <code>PointerEvent</code> handler function. Fires when a pointer is no longer active.</li> <li><code>onPointerUpCapture</code>: A version of <code>onPointerUp</code> that fires in the capture phase.</li> <li><code>onPaste</code>: A <code>ClipboardEvent</code> handler function. Fires when the user tries to paste something from the clipboard.</li> <li><code>onPasteCapture</code>: A version of <code>onPaste</code> that fires in the capture phase.</li> <li><code>onScroll</code>: An <code>Event</code> handler function. Fires when an element has been scrolled. This event does not bubble.</li> <li><code>onScrollCapture</code>: A version of <code>onScroll</code> that fires in the capture phase.</li> <li><code>onSelect</code>: An <code>Event</code> handler function. Fires after the selection inside an editable element like an input changes. React extends the <code>onSelect</code> event to work for <code>contentEditable={true}</code> elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).</li> <li><code>onSelectCapture</code>: A version of <code>onSelect</code> that fires in the capture phase.</li> <li><code>onTouchCancel</code>: A <code>TouchEvent</code> handler function. Fires when the browser cancels a touch interaction.</li> <li><code>onTouchCancelCapture</code>: A version of <code>onTouchCancel</code> that fires in the capture phase.</li> <li><code>onTouchEnd</code>: A <code>TouchEvent</code> handler function. Fires when one or more touch points are removed.</li> <li><code>onTouchEndCapture</code>: A version of <code>onTouchEnd</code> that fires in the capture phase.</li> <li><code>onTouchMove</code>: A <code>TouchEvent</code> handler function. Fires one or more touch points are moved.</li> <li><code>onTouchMoveCapture</code>: A version of <code>onTouchMove</code> that fires in the capture phase.</li> <li><code>onTouchStart</code>: A <code>TouchEvent</code> handler function. Fires when one or more touch points are placed.</li> <li><code>onTouchStartCapture</code>: A version of <code>onTouchStart</code> that fires in the capture phase.</li> <li><code>onTransitionEnd</code>: A <code>TransitionEvent</code> handler function. Fires when a CSS transition completes.</li> <li><code>onTransitionEndCapture</code>: A version of <code>onTransitionEnd</code> that fires in the capture phase.</li> <li><code>onWheel</code>: A <code>WheelEvent</code> handler function. Fires when the user rotates a wheel button.</li> <li><code>onWheelCapture</code>: A version of <code>onWheel</code> that fires in the capture phase.</li> <li><code>role</code>: A string. Specifies the element role explicitly for assistive technologies. nt.</li> <li><code>slot</code>: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example <code>&lt;Layout left={&lt;Sidebar /&gt;} right={&lt;Content /&gt;} /&gt;</code>.</li> <li><code>spellCheck</code>: A boolean or null. If explicitly set to <code>true</code> or <code>false</code>, enables or disables spellchecking.</li> <li><code>tabIndex</code>: A number. Overrides the default Tab button behavior. Avoid using values other than <code>-1</code> and <code>0</code>.</li> <li><code>title</code>: A string. Specifies the tooltip text for the element.</li> <li><code>translate</code>: Either <code>'yes'</code> or <code>'no'</code>. Passing <code>'no'</code> excludes the element content from being translated.</li> </ul> <p>You can also pass custom attributes as props, for example <code>mycustomprop=\"someValue\"</code>. This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with <code>on</code>. The value will be converted to a string. If you pass <code>null</code> or <code>undefined</code>, the custom attribute will be removed.</p> <p>These events fire only for the <code>&lt;form&gt;</code> elements:</p> <ul> <li><code>onReset</code>: An <code>Event</code> handler function. Fires when a form gets reset.</li> <li><code>onResetCapture</code>: A version of <code>onReset</code> that fires in the capture phase.</li> <li><code>onSubmit</code>: An <code>Event</code> handler function. Fires when a form gets submitted.</li> <li><code>onSubmitCapture</code>: A version of <code>onSubmit</code> that fires in the capture phase.</li> </ul> <p>These events fire only for the <code>&lt;dialog&gt;</code> elements. Unlike browser events, they bubble in React:</p> <ul> <li><code>onCancel</code>: An <code>Event</code> handler function. Fires when the user tries to dismiss the dialog.</li> <li><code>onCancelCapture</code>: A version of <code>onCancel</code> that fires in the capture phase. capture-phase-events)</li> <li><code>onClose</code>: An <code>Event</code> handler function. Fires when a dialog has been closed.</li> <li><code>onCloseCapture</code>: A version of <code>onClose</code> that fires in the capture phase.</li> </ul> <p>These events fire only for the <code>&lt;details&gt;</code> elements. Unlike browser events, they bubble in React:</p> <ul> <li><code>onToggle</code>: An <code>Event</code> handler function. Fires when the user toggles the details.</li> <li><code>onToggleCapture</code>: A version of <code>onToggle</code> that fires in the capture phase. capture-phase-events)</li> </ul> <p>These events fire for <code>&lt;img&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>, <code>&lt;link&gt;</code>, and SVG <code>&lt;image&gt;</code> elements. Unlike browser events, they bubble in React:</p> <ul> <li><code>onLoad</code>: An <code>Event</code> handler function. Fires when the resource has loaded.</li> <li><code>onLoadCapture</code>: A version of <code>onLoad</code> that fires in the capture phase.</li> <li><code>onError</code>: An <code>Event</code> handler function. Fires when the resource could not be loaded.</li> <li><code>onErrorCapture</code>: A version of <code>onError</code> that fires in the capture phase.</li> </ul> <p>These events fire for resources like <code>&lt;audio&gt;</code> and <code>&lt;video&gt;</code>. Unlike browser events, they bubble in React:</p> <ul> <li><code>onAbort</code>: An <code>Event</code> handler function. Fires when the resource has not fully loaded, but not due to an error.</li> <li><code>onAbortCapture</code>: A version of <code>onAbort</code> that fires in the capture phase.</li> <li><code>onCanPlay</code>: An <code>Event</code> handler function. Fires when there's enough data to start playing, but not enough to play to the end without buffering.</li> <li><code>onCanPlayCapture</code>: A version of <code>onCanPlay</code> that fires in the capture phase.</li> <li><code>onCanPlayThrough</code>: An <code>Event</code> handler function. Fires when there's enough data that it's likely possible to start playing without buffering until the end.</li> <li><code>onCanPlayThroughCapture</code>: A version of <code>onCanPlayThrough</code> that fires in the capture phase.</li> <li><code>onDurationChange</code>: An <code>Event</code> handler function. Fires when the media duration has updated.</li> <li><code>onDurationChangeCapture</code>: A version of <code>onDurationChange</code> that fires in the capture phase.</li> <li><code>onEmptied</code>: An <code>Event</code> handler function. Fires when the media has become empty.</li> <li><code>onEmptiedCapture</code>: A version of <code>onEmptied</code> that fires in the capture phase.</li> <li><code>onEncrypted</code>: An <code>Event</code> handler function. Fires when the browser encounters encrypted media.</li> <li><code>onEncryptedCapture</code>: A version of <code>onEncrypted</code> that fires in the capture phase.</li> <li><code>onEnded</code>: An <code>Event</code> handler function. Fires when the playback stops because there's nothing left to play.</li> <li><code>onEndedCapture</code>: A version of <code>onEnded</code> that fires in the capture phase.</li> <li><code>onError</code>: An <code>Event</code> handler function. Fires when the resource could not be loaded.</li> <li><code>onErrorCapture</code>: A version of <code>onError</code> that fires in the capture phase.</li> <li><code>onLoadedData</code>: An <code>Event</code> handler function. Fires when the current playback frame has loaded.</li> <li><code>onLoadedDataCapture</code>: A version of <code>onLoadedData</code> that fires in the capture phase.</li> <li><code>onLoadedMetadata</code>: An <code>Event</code> handler function. Fires when metadata has loaded.</li> <li><code>onLoadedMetadataCapture</code>: A version of <code>onLoadedMetadata</code> that fires in the capture phase.</li> <li><code>onLoadStart</code>: An <code>Event</code> handler function. Fires when the browser started loading the resource.</li> <li><code>onLoadStartCapture</code>: A version of <code>onLoadStart</code> that fires in the capture phase.</li> <li><code>onPause</code>: An <code>Event</code> handler function. Fires when the media was paused.</li> <li><code>onPauseCapture</code>: A version of <code>onPause</code> that fires in the capture phase.</li> <li><code>onPlay</code>: An <code>Event</code> handler function. Fires when the media is no longer paused.</li> <li><code>onPlayCapture</code>: A version of <code>onPlay</code> that fires in the capture phase.</li> <li><code>onPlaying</code>: An <code>Event</code> handler function. Fires when the media starts or restarts playing.</li> <li><code>onPlayingCapture</code>: A version of <code>onPlaying</code> that fires in the capture phase.</li> <li><code>onProgress</code>: An <code>Event</code> handler function. Fires periodically while the resource is loading.</li> <li><code>onProgressCapture</code>: A version of <code>onProgress</code> that fires in the capture phase.</li> <li><code>onRateChange</code>: An <code>Event</code> handler function. Fires when playback rate changes.</li> <li><code>onRateChangeCapture</code>: A version of <code>onRateChange</code> that fires in the capture phase.</li> <li><code>onResize</code>: An <code>Event</code> handler function. Fires when video changes size.</li> <li><code>onResizeCapture</code>: A version of <code>onResize</code> that fires in the capture phase.</li> <li><code>onSeeked</code>: An <code>Event</code> handler function. Fires when a seek operation completes.</li> <li><code>onSeekedCapture</code>: A version of <code>onSeeked</code> that fires in the capture phase.</li> <li><code>onSeeking</code>: An <code>Event</code> handler function. Fires when a seek operation starts.</li> <li><code>onSeekingCapture</code>: A version of <code>onSeeking</code> that fires in the capture phase.</li> <li><code>onStalled</code>: An <code>Event</code> handler function. Fires when the browser is waiting for data but it keeps not loading.</li> <li><code>onStalledCapture</code>: A version of <code>onStalled</code> that fires in the capture phase.</li> <li><code>onSuspend</code>: An <code>Event</code> handler function. Fires when loading the resource was suspended.</li> <li><code>onSuspendCapture</code>: A version of <code>onSuspend</code> that fires in the capture phase.</li> <li><code>onTimeUpdate</code>: An <code>Event</code> handler function. Fires when the current playback time updates.</li> <li><code>onTimeUpdateCapture</code>: A version of <code>onTimeUpdate</code> that fires in the capture phase.</li> <li><code>onVolumeChange</code>: An <code>Event</code> handler function. Fires when the volume has changed.</li> <li><code>onVolumeChangeCapture</code>: A version of <code>onVolumeChange</code> that fires in the capture phase.</li> <li><code>onWaiting</code>: An <code>Event</code> handler function. Fires when the playback stopped due to temporary lack of data.</li> <li><code>onWaitingCapture</code>: A version of <code>onWaiting</code> that fires in the capture phase.</li> </ul>"},{"location":"reference/common-props/#caveats","title":"Caveats","text":"<ul> <li>You cannot pass both <code>children</code> and <code>dangerouslySetInnerHTML</code> at the same time.</li> <li>Some events (like <code>onAbort</code> and <code>onLoad</code>) don't bubble in the browser, but bubble in React.</li> </ul>"},{"location":"reference/overview/","title":"Overview","text":"<p>  This section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.  </p> <p>The React reference documentation is broken down into functional subsections:</p>"},{"location":"reference/overview/#react","title":"React","text":"<p>Programmatic React features:</p> <ul> <li>Hooks - Use different React features from your components.</li> <li>Components - Built-in components that you can use in your JSX.</li> <li>APIs - APIs that are useful for defining components.</li> <li>Directives - Provide instructions to bundlers compatible with React Server Components.</li> </ul>"},{"location":"reference/overview/#react-dom","title":"React DOM","text":"<p>React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:</p> <ul> <li>Hooks - Hooks for web applications which run in the browser DOM environment.</li> <li>Components - React supports all of the browser built-in HTML and SVG components.</li> <li>APIs - The <code>react-dom</code> package contains methods supported only in web applications.</li> <li>Client APIs - The <code>react-dom/client</code> APIs let you render React components on the client (in the browser).</li> <li>Server APIs - The <code>react-dom/server</code> APIs let you render React components to HTML on the server.</li> </ul>"},{"location":"reference/overview/#rules-of-react","title":"Rules of React","text":"<p>React has idioms \u2014 or rules \u2014 for how to express patterns in a way that is easy to understand and yields high-quality applications:</p> <ul> <li>Components and Hooks must be pure \u2013 Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.</li> <li>React calls Components and Hooks \u2013 React is responsible for rendering components and hooks when necessary to optimize the user experience.</li> <li>Rules of Hooks \u2013 Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.</li> </ul>"},{"location":"reference/overview/#legacy-apis","title":"Legacy APIs","text":"<ul> <li>Legacy APIs - Exported from the <code>react</code> package, but not recommended for use in newly written code.</li> </ul>"},{"location":"reference/use-async-effect/","title":"Use Async Effect \ud83d\udea7","text":""},{"location":"reference/use-async-effect/#overview","title":"Overview","text":"<p> <code>useEffect</code> is a React Hook that lets you synchronize a component with an external system. <pre><code>useEffect(setup, dependencies?)\n</code></pre> </p>"},{"location":"reference/use-async-effect/#reference","title":"Reference","text":""},{"location":"reference/use-async-effect/#useeffectsetup-dependencies","title":"<code>useEffect(setup, dependencies?)</code>","text":"<p>Call <code>useEffect</code> at the top level of your component to declare an Effect:</p> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-async-effect/#parameters","title":"Parameters","text":"<ul> <li> <p><code>setup</code>: The function with your Effect's logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.</p> </li> <li> <p>optional <code>dependencies</code>: The list of all reactive values referenced inside of the <code>setup</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code>[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <code>Object.is</code> comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.</p> </li> </ul>"},{"location":"reference/use-async-effect/#returns","title":"Returns","text":"<p><code>useEffect</code> returns <code>undefined</code>.</p>"},{"location":"reference/use-async-effect/#caveats","title":"Caveats","text":"<ul> <li> <p><code>useEffect</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</p> </li> <li> <p>If you're not trying to synchronize with some external system, you probably don't need an Effect.</p> </li> <li> <p>When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic \"mirrors\" your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.</p> </li> <li> <p>If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.</p> </li> <li> <p>If your Effect wasn't caused by an interaction (like a click), React will let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace <code>useEffect</code> with <code>useLayoutEffect</code>.</p> </li> <li> <p>Even if your Effect was caused by an interaction (like a click), the browser may repaint the screen before processing the state updates inside your Effect. Usually, that's what you want. However, if you must block the browser from repainting the screen, you need to replace <code>useEffect</code> with <code>useLayoutEffect</code>.</p> </li> <li> <p>Effects only run on the client. They don't run during server rendering.</p> </li> </ul>"},{"location":"reference/use-async-effect/#usage","title":"Usage","text":""},{"location":"reference/use-async-effect/#connecting-to-an-external-system","title":"Connecting to an external system","text":"<p>Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren't controlled by React, so they are called external.</p> <p>To connect your component to some external system, call <code>useEffect</code> at the top level of your component:</p> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\n</code></pre> <p>You need to pass two arguments to <code>useEffect</code>:</p> <ol> <li>A setup function with setup code that connects to that system.<ul> <li>It should return a cleanup function with cleanup code that disconnects from that system.</li> </ul> </li> <li>A list of dependencies including every value from your component used inside of those functions.</li> </ol> <p>React calls your setup and cleanup functions whenever it's necessary, which may happen multiple times:</p> <ol> <li>Your setup code runs when your component is added to the page (mounts).</li> <li>After every re-render of your component where the dependencies have changed:<ul> <li>First, your cleanup code runs with the old props and state.</li> <li>Then, your setup code runs with the new props and state.</li> </ul> </li> <li>Your cleanup code runs one final time after your component is removed from the page (unmounts).</li> </ol> <p>Let's illustrate this sequence for the example above.</p> <p>When the <code>ChatRoom</code> component above gets added to the page, it will connect to the chat room with the initial <code>serverUrl</code> and <code>roomId</code>. If either <code>serverUrl</code> or <code>roomId</code> change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the <code>ChatRoom</code> component is removed from the page, your Effect will disconnect one last time.</p> <p>To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect's logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn't be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development). See common solutions.</p> <p>Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn't matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly \"mirrors\" the setup logic, your Effect is resilient to running setup and cleanup as often as needed.</p> <p> <p>An Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code that's not controlled by React, such as:</p> <ul> <li>A timer managed with <code>setInterval()</code> and <code>clearInterval()</code>.</li> <li>An event subscription using <code>window.addEventListener()</code> and <code>window.removeEventListener()</code>.</li> <li>A third-party animation library with an API like <code>animation.start()</code> and <code>animation.reset()</code>.</li> </ul> <p>If you're not connecting to any external system, you probably don't need an Effect.</p> <p></p> <p>"},{"location":"reference/use-async-effect/#connecting-to-a-chat-server","title":"Connecting to a chat server","text":"<p>In this example, the <code>ChatRoom</code> component uses an Effect to stay connected to an external system defined in <code>chat.js</code>. Press \"Open chat\" to make the <code>ChatRoom</code> component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the <code>roomId</code> and <code>serverUrl</code> using the dropdown and the input, and see how the Effect re-connects to the chat. Press \"Close chat\" to see the Effect disconnect one last time.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#listening-to-a-global-browser-event","title":"Listening to a global browser event","text":"<p>In this example, the external system is the browser DOM itself. Normally, you'd specify event listeners with JSX, but you can't listen to the global <code>window</code> object this way. An Effect lets you connect to the <code>window</code> object and listen to its events. Listening to the <code>pointermove</code> event lets you track the cursor (or finger) position and update the red dot to move with it.</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; {\nwindow.removeEventListener(\"pointermove\", handleMove);\n};\n}, []);\n\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#triggering-an-animation","title":"Triggering an animation","text":"<p>In this example, the external system is the animation library in <code>animation.js</code>. It provides a JavaScript class called <code>FadeInAnimation</code> that takes a DOM node as an argument and exposes <code>start()</code> and <code>stop()</code> methods to control the animation. This component uses a ref to access the underlying DOM node. The Effect reads the DOM node from the ref and automatically starts the animation for that node when the component appears.</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { FadeInAnimation } from \"./animation.js\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst animation = new FadeInAnimation(ref.current);\nanimation.start(1000);\nreturn () =&gt; {\nanimation.stop();\n};\n}, []);\n\nreturn (\n&lt;h1\nref={ref}\nstyle={{\nopacity: 0,\ncolor: \"white\",\npadding: 50,\ntextAlign: \"center\",\nfontSize: 50,\nbackgroundImage:\n\"radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)\",\n}}\n&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export class FadeInAnimation {\nconstructor(node) {\nthis.node = node;\n}\nstart(duration) {\nthis.duration = duration;\nif (this.duration === 0) {\n// Jump to end immediately\nthis.onProgress(1);\n} else {\nthis.onProgress(0);\n// Start animating\nthis.startTime = performance.now();\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonFrame() {\nconst timePassed = performance.now() - this.startTime;\nconst progress = Math.min(timePassed / this.duration, 1);\nthis.onProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonProgress(progress) {\nthis.node.style.opacity = progress;\n}\nstop() {\ncancelAnimationFrame(this.frameId);\nthis.startTime = null;\nthis.frameId = null;\nthis.duration = 0;\n}\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#controlling-a-modal-dialog","title":"Controlling a modal dialog","text":"<p>In this example, the external system is the browser DOM. The <code>ModalDialog</code> component renders a <code>&lt;dialog&gt;</code> element. It uses an Effect to synchronize the <code>isOpen</code> prop to the <code>showModal()</code> and <code>close()</code> method calls.</p> <pre><code>import { useState } from \"react\";\nimport ModalDialog from \"./ModalDialog.js\";\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(true)}&gt;Open dialog&lt;/button&gt;\n&lt;ModalDialog isOpen={show}&gt;\nHello there!\n&lt;br /&gt;\n&lt;button\nonClick={() =&gt; {\nsetShow(false);\n}}\n&gt;\nClose\n&lt;/button&gt;\n&lt;/ModalDialog&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function ModalDialog({ isOpen, children }) {\nconst ref = useRef();\n\nuseEffect(() =&gt; {\nif (!isOpen) {\nreturn;\n}\nconst dialog = ref.current;\ndialog.showModal();\nreturn () =&gt; {\ndialog.close();\n};\n}, [isOpen]);\n\nreturn &lt;dialog ref={ref}&gt;{children}&lt;/dialog&gt;;\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#tracking-element-visibility","title":"Tracking element visibility","text":"<p>In this example, the external system is again the browser DOM. The <code>App</code> component displays a long list, then a <code>Box</code> component, and then another long list. Scroll the list down. Notice that when the <code>Box</code> component appears in the viewport, the background color changes to black. To implement this, the <code>Box</code> component uses an Effect to manage an <code>IntersectionObserver</code>. This browser API notifies you when the DOM element is visible in the viewport.</p> <pre><code>import Box from \"./Box.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;/&gt;\n);\n}\n\nfunction LongSection() {\nconst items = [];\nfor (let i = 0; i &lt; 50; i++) {\nitems.push(&lt;li key={i}&gt;Item #{i} (keep scrolling)&lt;/li&gt;);\n}\nreturn &lt;ul&gt;{items}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>import { useRef, useEffect } from \"react\";\n\nexport default function Box() {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst div = ref.current;\nconst observer = new IntersectionObserver((entries) =&gt; {\nconst entry = entries[0];\nif (entry.isIntersecting) {\ndocument.body.style.backgroundColor = \"black\";\ndocument.body.style.color = \"white\";\n} else {\ndocument.body.style.backgroundColor = \"white\";\ndocument.body.style.color = \"black\";\n}\n});\nobserver.observe(div, {\nthreshold: 1.0,\n});\nreturn () =&gt; {\nobserver.disconnect();\n};\n}, []);\n\nreturn (\n&lt;div\nref={ref}\nstyle={{\nmargin: 20,\nheight: 100,\nwidth: 100,\nborder: \"2px solid black\",\nbackgroundColor: \"blue\",\n}}\n/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"reference/use-async-effect/#wrapping-effects-in-custom-hooks","title":"Wrapping Effects in custom Hooks","text":"<p>Effects are an \"escape hatch\": you use them when you need to \"step outside React\" and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it's usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.</p> <p>For example, this <code>useChatRoom</code> custom Hook \"hides\" the logic of your Effect behind a more declarative API:</p> <pre><code>function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <p>Then you can use it from any component like this:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl\n});\n// ...\n</code></pre> <p>There are also many excellent custom Hooks for every purpose available in the React ecosystem.</p> <p>Learn more about wrapping Effects in custom Hooks.</p> <p>"},{"location":"reference/use-async-effect/#custom-usechatroom-hook","title":"Custom <code>useChatRoom</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.</p> <pre><code>import { useState } from \"react\";\nimport { useChatRoom } from \"./useChatRoom.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#custom-usewindowlistener-hook","title":"Custom <code>useWindowListener</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.</p> <pre><code>import { useState } from \"react\";\nimport { useWindowListener } from \"./useWindowListener.js\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseWindowListener(\"pointermove\", (e) =&gt; {\nsetPosition({ x: e.clientX, y: e.clientY });\n});\n\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useWindowListener(eventType, listener) {\nuseEffect(() =&gt; {\nwindow.addEventListener(eventType, listener);\nreturn () =&gt; {\nwindow.removeEventListener(eventType, listener);\n};\n}, [eventType, listener]);\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#custom-useintersectionobserver-hook","title":"Custom <code>useIntersectionObserver</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is partially extracted to a custom Hook.</p> <pre><code>import Box from \"./Box.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;/&gt;\n);\n}\n\nfunction LongSection() {\nconst items = [];\nfor (let i = 0; i &lt; 50; i++) {\nitems.push(&lt;li key={i}&gt;Item #{i} (keep scrolling)&lt;/li&gt;);\n}\nreturn &lt;ul&gt;{items}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>import { useRef, useEffect } from \"react\";\nimport { useIntersectionObserver } from \"./useIntersectionObserver.js\";\n\nexport default function Box() {\nconst ref = useRef(null);\nconst isIntersecting = useIntersectionObserver(ref);\n\nuseEffect(() =&gt; {\nif (isIntersecting) {\ndocument.body.style.backgroundColor = \"black\";\ndocument.body.style.color = \"white\";\n} else {\ndocument.body.style.backgroundColor = \"white\";\ndocument.body.style.color = \"black\";\n}\n}, [isIntersecting]);\n\nreturn (\n&lt;div\nref={ref}\nstyle={{\nmargin: 20,\nheight: 100,\nwidth: 100,\nborder: \"2px solid black\",\nbackgroundColor: \"blue\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useIntersectionObserver(ref) {\nconst [isIntersecting, setIsIntersecting] = useState(false);\n\nuseEffect(() =&gt; {\nconst div = ref.current;\nconst observer = new IntersectionObserver((entries) =&gt; {\nconst entry = entries[0];\nsetIsIntersecting(entry.isIntersecting);\n});\nobserver.observe(div, {\nthreshold: 1.0,\n});\nreturn () =&gt; {\nobserver.disconnect();\n};\n}, [ref]);\n\nreturn isIntersecting;\n}\n</code></pre> <p></p>"},{"location":"reference/use-async-effect/#controlling-a-non-react-widget","title":"Controlling a non-React widget","text":"<p>Sometimes, you want to keep an external system synchronized to some prop or state of your component.</p> <p>For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a <code>MapWidget</code> class defined in <code>map-widget.js</code>. When you change the <code>zoomLevel</code> prop of the <code>Map</code> component, the Effect calls the <code>setZoom()</code> on the class instance to keep it synchronized:</p> <p>```json package.json hidden {     \"dependencies\": {         \"leaflet\": \"1.9.1\",         \"react\": \"latest\",         \"react-dom\": \"latest\",         \"react-scripts\": \"latest\",         \"remarkable\": \"2.0.1\"     },     \"scripts\": {         \"start\": \"react-scripts start\",         \"build\": \"react-scripts build\",         \"test\": \"react-scripts test --env=jsdom\",         \"eject\": \"react-scripts eject\"     } } <pre><code>```js\nimport { useState } from \"react\";\nimport Map from \"./Map.js\";\n\nexport default function App() {\n    const [zoomLevel, setZoomLevel] = useState(0);\n    return (\n        &lt;&gt;\n            Zoom level: {zoomLevel}x\n            &lt;button onClick={() =&gt; setZoomLevel(zoomLevel + 1)}&gt;+&lt;/button&gt;\n            &lt;button onClick={() =&gt; setZoomLevel(zoomLevel - 1)}&gt;-&lt;/button&gt;\n            &lt;hr /&gt;\n            &lt;Map zoomLevel={zoomLevel} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></p> <pre><code>import { useRef, useEffect } from \"react\";\nimport { MapWidget } from \"./map-widget.js\";\n\nexport default function Map({ zoomLevel }) {\nconst containerRef = useRef(null);\nconst mapRef = useRef(null);\n\nuseEffect(() =&gt; {\nif (mapRef.current === null) {\nmapRef.current = new MapWidget(containerRef.current);\n}\n\nconst map = mapRef.current;\nmap.setZoom(zoomLevel);\n}, [zoomLevel]);\n\nreturn &lt;div style={{ width: 200, height: 200 }} ref={containerRef} /&gt;;\n}\n</code></pre> <pre><code>import \"leaflet/dist/leaflet.css\";\nimport * as L from \"leaflet\";\n\nexport class MapWidget {\nconstructor(domNode) {\nthis.map = L.map(domNode, {\nzoomControl: false,\ndoubleClickZoom: false,\nboxZoom: false,\nkeyboard: false,\nscrollWheelZoom: false,\nzoomAnimation: false,\ntouchZoom: false,\nzoomSnap: 0.1,\n});\nL.tileLayer(\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\", {\nmaxZoom: 19,\nattribution: \"\u00a9 OpenStreetMap\",\n}).addTo(this.map);\nthis.map.setView([0, 0], 0);\n}\nsetZoom(level) {\nthis.map.setZoom(level);\n}\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p>In this example, a cleanup function is not needed because the <code>MapWidget</code> class manages only the DOM node that was passed to it. After the <code>Map</code> React component is removed from the tree, both the DOM node and the <code>MapWidget</code> class instance will be automatically garbage-collected by the browser JavaScript engine.</p>"},{"location":"reference/use-async-effect/#fetching-data-with-effects","title":"Fetching data with Effects","text":"<p>You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework's data fetching mechanism will be a lot more efficient than writing Effects manually.</p> <p>If you want to fetch data from an Effect manually, your code might look like this:</p> <pre><code>import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\nconst [person, setPerson] = useState('Alice');\nconst [bio, setBio] = useState(null);\n\nuseEffect(() =&gt; {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then(result =&gt; {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\n// ...\n</code></pre> <p>Note the <code>ignore</code> variable which is initialized to <code>false</code>, and is set to <code>true</code> during cleanup. This ensures your code doesn't suffer from \"race conditions\": network responses may arrive in a different order than you sent them.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\nuseEffect(() =&gt; {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then((result) =&gt; {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>You can also rewrite using the <code>async</code> / <code>await</code> syntax, but you still need to provide a cleanup function:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\nuseEffect(() =&gt; {\nasync function startFetching() {\nsetBio(null);\nconst result = await fetchBio(person);\nif (!ignore) {\nsetBio(result);\n}\n}\n\nlet ignore = false;\nstartFetching();\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It's easier to use a custom Hook--either your own or maintained by the community.</p> <p>"},{"location":"reference/use-async-effect/#what-are-good-alternatives-to-data-fetching-in-effects","title":"What are good alternatives to data fetching in Effects?","text":"<p>Writing <code>fetch</code> calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:</p> <ul> <li>Effects don't run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.</li> <li>Fetching directly in Effects makes it easy to create \"network waterfalls\". You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.</li> <li>Fetching directly in Effects usually means you don't preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.</li> <li>It's not very ergonomic. There's quite a bit of boilerplate code involved when writing <code>fetch</code> calls in a way that doesn't suffer from bugs like race conditions.</li> </ul> <p>This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:</p> <ul> <li>If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.</li> <li>Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).</li> </ul> <p>You can continue fetching data directly in Effects if neither of these approaches suit you.</p> <p></p>"},{"location":"reference/use-async-effect/#specifying-reactive-dependencies","title":"Specifying reactive dependencies","text":"<p>Notice that you can't \"choose\" the dependencies of your Effect. Every reactive value used by your Effect's code must be declared as a dependency. Your Effect's dependency list is determined by the surrounding code:</p> <pre><code>function ChatRoom({ roomId }) {\n// This is a reactive value\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); // This is a reactive value too\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [serverUrl, roomId]); // \u2705 So you must specify them as dependencies of your Effect\n// ...\n}\n</code></pre> <p>If either <code>serverUrl</code> or <code>roomId</code> change, your Effect will reconnect to the chat using the new values.</p> <p>Reactive values include props and all variables and functions declared directly inside of your component. Since <code>roomId</code> and <code>serverUrl</code> are reactive values, you can't remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \ud83d\udd34 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n// ...\n}\n</code></pre> <p>To remove a dependency, you need to \"prove\" to the linter that it doesn't need to be a dependency. For example, you can move <code>serverUrl</code> out of your component to prove that it's not reactive and won't change on re-renders:</p> <pre><code>const serverUrl = \"https://localhost:1234\"; // Not a reactive value anymore\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Now that <code>serverUrl</code> is not a reactive value (and can't change on a re-render), it doesn't need to be a dependency. If your Effect's code doesn't use any reactive values, its dependency list should be empty (<code>[]</code>):</p> <pre><code>const serverUrl = \"https://localhost:1234\"; // Not a reactive value anymore\nconst roomId = \"music\"; // Not a reactive value anymore\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>An Effect with empty dependencies doesn't re-run when any of your component's props or state change.</p> <p> <p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p> <pre><code>useEffect(() =&gt; {\n// ...\n// \ud83d\udd34 Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}, []);\n</code></pre> <p>When dependencies don't match the code, there is a high risk of introducing bugs. By suppressing the linter, you \"lie\" to React about the values your Effect depends on. Instead, prove they're unnecessary.</p> <p></p> <p>"},{"location":"reference/use-async-effect/#passing-a-dependency-array","title":"Passing a dependency array","text":"<p>If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}, [a, b]); // Runs again if a or b are different\n</code></pre> <p>In the below example, <code>serverUrl</code> and <code>roomId</code> are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since <code>message</code> isn't used in the Effect (and so it isn't a dependency), editing the message doesn't re-connect to the chat.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;{show ? \"Close chat\" : \"Open chat\"}&lt;/button&gt;\n&lt;/label&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\nmargin-bottom: 10px;\n}\nbutton {\nmargin-left: 5px;\n}\n</code></pre>"},{"location":"reference/use-async-effect/#passing-an-empty-dependency-array","title":"Passing an empty dependency array","text":"<p>If your Effect truly doesn't use any reactive values, it will only run after the initial render.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}, []); // Does not run again (except once in development)\n</code></pre> <p>Even with empty dependencies, setup and cleanup will run one extra time in development to help you find bugs.</p> <p>In this example, both <code>serverUrl</code> and <code>roomId</code> are hardcoded. Since they're declared outside the component, they are not reactive values, and so they aren't dependencies. The dependency list is empty, so the Effect doesn't re-run on re-renders.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\nconst roomId = \"music\";\n\nfunction ChatRoom() {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre>"},{"location":"reference/use-async-effect/#passing-no-dependency-array-at-all","title":"Passing no dependency array at all","text":"<p>If you pass no dependency array at all, your Effect runs after every single render (and re-render) of your component.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}); // Always runs again\n</code></pre> <p>In this example, the Effect re-runs when you change <code>serverUrl</code> and <code>roomId</code>, which is sensible. However, it also re-runs when you change the <code>message</code>, which is probably undesirable. This is why usually you'll specify the dependency array.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}); // No dependency array at all\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;{show ? \"Close chat\" : \"Open chat\"}&lt;/button&gt;\n&lt;/label&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\nmargin-bottom: 10px;\n}\nbutton {\nmargin-left: 5px;\n}\n</code></pre> <p></p>"},{"location":"reference/use-async-effect/#updating-state-based-on-previous-state-from-an-effect","title":"Updating state based on previous state from an Effect","text":"<p>When you want to update state based on previous state from an Effect, you might run into a problem:</p> <pre><code>function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconst intervalId = setInterval(() =&gt; {\nsetCount(count + 1); // You want to increment the counter every second...\n}, 1000);\nreturn () =&gt; clearInterval(intervalId);\n}, [count]); // \ud83d\udea9 ... but specifying `count` as a dependency always resets the interval.\n// ...\n}\n</code></pre> <p>Since <code>count</code> is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the <code>count</code> changes. This is not ideal.</p> <p>To fix this, pass the <code>c =&gt; c + 1</code> state updater to <code>setCount</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconst intervalId = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1); // \u2705 Pass a state updater\n}, 1000);\nreturn () =&gt; clearInterval(intervalId);\n}, []); // \u2705 Now count is not a dependency\n\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p>Now that you're passing <code>c =&gt; c + 1</code> instead of <code>count + 1</code>, your Effect no longer needs to depend on <code>count</code>. As a result of this fix, it won't need to cleanup and setup the interval again every time the <code>count</code> changes.</p>"},{"location":"reference/use-async-effect/#removing-unnecessary-object-dependencies","title":"Removing unnecessary object dependencies","text":"<p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code>options</code> object is different for every render:</p> <pre><code>const serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nconst options = { // \ud83d\udea9 This object is created from scratch on every re-render\nserverUrl: serverUrl,\nroomId: roomId\n};\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options); // It's used inside the Effect\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\n</code></pre> <p>Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Now that you create the <code>options</code> object inside the Effect, the Effect itself only depends on the <code>roomId</code> string.</p> <p>With this fix, typing into the input doesn't reconnect the chat. Unlike an object which gets re-created, a string like <code>roomId</code> doesn't change unless you set it to another value. Read more about removing dependencies.</p>"},{"location":"reference/use-async-effect/#removing-unnecessary-function-dependencies","title":"Removing unnecessary function dependencies","text":"<p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code>createOptions</code> function is different for every render:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nfunction createOptions() { // \ud83d\udea9 This function is created from scratch on every re-render\nreturn {\nserverUrl: serverUrl,\nroomId: roomId\n};\n}\n\nuseEffect(() =&gt; {\nconst options = createOptions(); // It's used inside the Effect\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [createOptions]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\n</code></pre> <p>By itself, creating a function from scratch on every re-render is not a problem. You don't need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.</p> <p>Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nfunction createOptions() {\nreturn {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n}\n\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Now that you define the <code>createOptions</code> function inside the Effect, the Effect itself only depends on the <code>roomId</code> string. With this fix, typing into the input doesn't reconnect the chat. Unlike a function which gets re-created, a string like <code>roomId</code> doesn't change unless you set it to another value. Read more about removing dependencies.</p>"},{"location":"reference/use-async-effect/#reading-the-latest-props-and-state-from-an-effect","title":"Reading the latest props and state from an Effect","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect \"reacts\" to every change of that value. For most dependencies, that's the behavior you want.</p> <p>However, sometimes you'll want to read the latest props and state from an Effect without \"reacting\" to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:</p> <pre><code>function Page({ url, shoppingCart }) {\nuseEffect(() =&gt; {\nlogVisit(url, shoppingCart.length);\n}, [url, shoppingCart]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>What if you want to log a new page visit after every <code>url</code> change, but not if only the <code>shoppingCart</code> changes? You can't exclude <code>shoppingCart</code> from dependencies without breaking the reactivity rules. However, you can express that you don't want a piece of code to \"react\" to changes even though it is called from inside an Effect. Declare an Effect Event with the <code>useEffectEvent</code> Hook, and move the code reading <code>shoppingCart</code> inside of it:</p> <pre><code>function Page({ url, shoppingCart }) {\nconst onVisit = useEffectEvent((visitedUrl) =&gt; {\nlogVisit(visitedUrl, shoppingCart.length);\n});\n\nuseEffect(() =&gt; {\nonVisit(url);\n}, [url]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading <code>shoppingCart</code> inside of <code>onVisit</code>, you ensure that <code>shoppingCart</code> won't re-run your Effect.</p> <p>Read more about how Effect Events let you separate reactive and non-reactive code.</p>"},{"location":"reference/use-async-effect/#displaying-different-content-on-the-server-and-the-client","title":"Displaying different content on the server and the client","text":"<p>If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.</p> <p>In rare cases, you might need to display different content on the client. For example, if your app reads some data from <code>localStorage</code>, it can't possibly do that on the server. Here is how you could implement this:</p> <pre><code>function MyComponent() {\nconst [didMount, setDidMount] = useState(false);\n\nuseEffect(() =&gt; {\nsetDidMount(true);\n}, []);\n\nif (didMount) {\n// ... return client-only JSX ...\n} else {\n// ... return initial JSX ...\n}\n}\n</code></pre> <p>While the app is loading, the user will see the initial render output. Then, when it's loaded and hydrated, your Effect will run and set <code>didMount</code> to <code>true</code>, triggering a re-render. This will switch to the client-only render output. Effects don't run on the server, so this is why <code>didMount</code> was <code>false</code> during the initial server render.</p> <p>Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time--potentially, many seconds--so you don't want to make jarring changes to your component's appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.</p>"},{"location":"reference/use-async-effect/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-async-effect/#my-effect-runs-twice-when-the-component-mounts","title":"My Effect runs twice when the component mounts","text":"<p>When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.</p> <p>This is a stress-test that verifies your Effect\u2019s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn\u2019t be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development).</p> <p>Read more about how this helps find bugs and how to fix your logic.</p>"},{"location":"reference/use-async-effect/#my-effect-runs-after-every-re-render","title":"My Effect runs after every re-render","text":"<p>First, check that you haven't forgotten to specify the dependency array:</p> <pre><code>useEffect(() =&gt; {\n// ...\n}); // \ud83d\udea9 No dependency array: re-runs after every render!\n</code></pre> <p>If you've specified the dependency array but your Effect still re-runs in a loop, it's because one of your dependencies is different on every re-render.</p> <p>You can debug this problem by manually logging your dependencies to the console:</p> <pre><code>useEffect(() =&gt; {\n// ..\n}, [serverUrl, roomId]);\n\nconsole.log([serverUrl, roomId]);\n</code></pre> <p>You can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as <code>temp1</code> and the second one got saved as <code>temp2</code>, you can then use the browser console to check whether each dependency in both arrays is the same:</p> <pre><code>Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n</code></pre> <p>When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:</p> <ul> <li>Updating state based on previous state from an Effect</li> <li>Removing unnecessary object dependencies</li> <li>Removing unnecessary function dependencies</li> <li>Reading the latest props and state from an Effect</li> </ul> <p>As a last resort (if these methods didn't help), wrap its creation with <code>useMemo</code> or <code>useCallback</code> (for functions).</p>"},{"location":"reference/use-async-effect/#my-effect-keeps-re-running-in-an-infinite-cycle","title":"My Effect keeps re-running in an infinite cycle","text":"<p>If your Effect runs in an infinite cycle, these two things must be true:</p> <ul> <li>Your Effect is updating some state.</li> <li>That state leads to a re-render, which causes the Effect's dependencies to change.</li> </ul> <p>Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application's data flow with it?</p> <p>If there is no external system, consider whether removing the Effect altogether would simplify your logic.</p> <p>If you're genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component's visual output? If you need to keep track of some data that isn't used by rendering, a ref (which doesn't trigger re-renders) might be more appropriate. Verify your Effect doesn't update the state (and trigger re-renders) more than needed.</p> <p>Finally, if your Effect is updating the state at the right time, but there is still a loop, it's because that state update leads to one of the Effect's dependencies changing. Read how to debug dependency changes.</p>"},{"location":"reference/use-async-effect/#my-cleanup-logic-runs-even-though-my-component-didnt-unmount","title":"My cleanup logic runs even though my component didn't unmount","text":"<p>The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.</p> <p>If you have cleanup code without corresponding setup code, it's usually a code smell:</p> <pre><code>useEffect(() =&gt; {\n// \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic\nreturn () =&gt; {\ndoSomething();\n};\n}, []);\n</code></pre> <p>Your cleanup logic should be \"symmetrical\" to the setup logic, and should stop or undo whatever setup did:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n</code></pre> <p>Learn how the Effect lifecycle is different from the component's lifecycle.</p>"},{"location":"reference/use-async-effect/#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs","title":"My Effect does something visual, and I see a flicker before it runs","text":"<p>If your Effect must block the browser from painting the screen, replace <code>useEffect</code> with <code>useLayoutEffect</code>. Note that this shouldn't be needed for the vast majority of Effects. You'll only need this if it's crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.</p>"},{"location":"reference/use-callback/","title":"Use Callback \ud83d\udea7","text":""},{"location":"reference/use-callback/#overview","title":"Overview","text":"<p> <code>useCallback</code> is a React Hook that lets you cache a function definition between re-renders.  <pre><code>const cachedFn = useCallback(fn, dependencies);\n</code></pre> </p>"},{"location":"reference/use-callback/#reference","title":"Reference","text":""},{"location":"reference/use-callback/#usecallbackfn-dependencies","title":"<code>useCallback(fn, dependencies)</code>","text":"<p>Call <code>useCallback</code> at the top level of your component to cache a function definition between re-renders:</p> <pre><code>import { useCallback } from 'react';\n\nexport default function ProductPage({ productId, referrer, theme }) {\nconst handleSubmit = useCallback((orderDetails) =&gt; {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]);\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-callback/#parameters","title":"Parameters","text":"<ul> <li> <p><code>fn</code>: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the <code>dependencies</code> have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.</p> </li> <li> <p><code>dependencies</code>: The list of all reactive values referenced inside of the <code>fn</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code>[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <code>Object.is</code> comparison algorithm.</p> </li> </ul>"},{"location":"reference/use-callback/#returns","title":"Returns","text":"<p>On the initial render, <code>useCallback</code> returns the <code>fn</code> function you have passed.</p> <p>During subsequent renders, it will either return an already stored <code>fn</code> function from the last render (if the dependencies haven't changed), or return the <code>fn</code> function you have passed during this render.</p>"},{"location":"reference/use-callback/#caveats","title":"Caveats","text":"<ul> <li><code>useCallback</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</li> <li>React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache--for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on <code>useCallback</code> as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.</li> </ul>"},{"location":"reference/use-callback/#usage","title":"Usage","text":""},{"location":"reference/use-callback/#skipping-re-rendering-of-components","title":"Skipping re-rendering of components","text":"<p>When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let's first look at the syntax for how to do this, and then see in which cases it's useful.</p> <p>To cache a function between re-renders of your component, wrap its definition into the <code>useCallback</code> Hook:</p> <pre><code>import { useCallback } from 'react';\n\nfunction ProductPage({ productId, referrer, theme }) {\nconst handleSubmit = useCallback((orderDetails) =&gt; {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]);\n// ...\n</code></pre> <p>You need to pass two things to <code>useCallback</code>:</p> <ol> <li>A function definition that you want to cache between re-renders.</li> <li>A list of dependencies including every value within your component that's used inside your function.</li> </ol> <p>On the initial render, the returned function you'll get from <code>useCallback</code> will be the function you passed.</p> <p>On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with <code>Object.is</code>), <code>useCallback</code> will return the same function as before. Otherwise, <code>useCallback</code> will return the function you passed on this render.</p> <p>In other words, <code>useCallback</code> caches a function between re-renders until its dependencies change.</p> <p>Let's walk through an example to see when this is useful.</p> <p>Say you're passing a <code>handleSubmit</code> function down from the <code>ProductPage</code> to the <code>ShippingForm</code> component:</p> <pre><code>function ProductPage({ productId, referrer, theme }) {\n// ...\nreturn (\n&lt;div className={theme}&gt;\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n</code></pre> <p>You've noticed that toggling the <code>theme</code> prop freezes the app for a moment, but if you remove <code>&lt;ShippingForm /&gt;</code> from your JSX, it feels fast. This tells you that it's worth trying to optimize the <code>ShippingForm</code> component.</p> <p>By default, when a component re-renders, React re-renders all of its children recursively. This is why, when <code>ProductPage</code> re-renders with a different <code>theme</code>, the <code>ShippingForm</code> component also re-renders. This is fine for components that don't require much calculation to re-render. But if you verified a re-render is slow, you can tell <code>ShippingForm</code> to skip re-rendering when its props are the same as on last render by wrapping it in <code>memo</code>:</p> <pre><code>import { memo } from \"react\";\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n// ...\n});\n</code></pre> <p>With this change, <code>ShippingForm</code> will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let's say you defined <code>handleSubmit</code> without <code>useCallback</code>:</p> <pre><code>function ProductPage({ productId, referrer, theme }) {\n// Every time the theme changes, this will be a different function...\nfunction handleSubmit(orderDetails) {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n}\n\nreturn (\n&lt;div className={theme}&gt;\n{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>In JavaScript, a <code>function () {}</code> or <code>() =&gt; {}</code> always creates a different function, similar to how the <code>{}</code> object literal always creates a new object. Normally, this wouldn't be a problem, but it means that <code>ShippingForm</code> props will never be the same, and your <code>memo</code> optimization won't work. This is where <code>useCallback</code> comes in handy:</p> <pre><code>function ProductPage({ productId, referrer, theme }) {\n// Tell React to cache your function between re-renders...\nconst handleSubmit = useCallback(\n(orderDetails) =&gt; {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n},\n[productId, referrer]\n); // ...so as long as these dependencies don't change...\n\nreturn (\n&lt;div className={theme}&gt;\n{/* ...ShippingForm will receive the same props and can skip re-rendering */}\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>By wrapping <code>handleSubmit</code> in <code>useCallback</code>, you ensure that it's the same function between the re-renders (until dependencies change). You don't have to wrap a function in <code>useCallback</code> unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in <code>memo</code>, and this lets it skip re-rendering. There are other reasons you might need <code>useCallback</code> which are described further on this page.</p> <p> <p>You should only rely on <code>useCallback</code> as a performance optimization. If your code doesn't work without it, find the underlying problem and fix it first. Then you may add <code>useCallback</code> back.</p> <p></p> <p>"},{"location":"reference/use-callback/#how-is-usecallback-related-to-usememo","title":"How is useCallback related to useMemo?","text":"<p>You will often see <code>useMemo</code> alongside <code>useCallback</code>. They are both useful when you're trying to optimize a child component. They let you memoize (or, in other words, cache) something you're passing down:</p> <pre><code>import { useMemo, useCallback } from \"react\";\n\nfunction ProductPage({ productId, referrer }) {\nconst product = useData(\"/product/\" + productId);\n\nconst requirements = useMemo(() =&gt; {\n// Calls your function and caches its result\nreturn computeRequirements(product);\n}, [product]);\n\nconst handleSubmit = useCallback(\n(orderDetails) =&gt; {\n// Caches your function itself\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n},\n[productId, referrer]\n);\n\nreturn (\n&lt;div className={theme}&gt;\n&lt;ShippingForm requirements={requirements} onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>The difference is in what they're letting you cache:</p> <ul> <li><code>useMemo</code> caches the result of calling your function. In this example, it caches the result of calling <code>computeRequirements(product)</code> so that it doesn't change unless <code>product</code> has changed. This lets you pass the <code>requirements</code> object down without unnecessarily re-rendering <code>ShippingForm</code>. When necessary, React will call the function you've passed during rendering to calculate the result.</li> <li><code>useCallback</code> caches the function itself. Unlike <code>useMemo</code>, it does not call the function you provide. Instead, it caches the function you provided so that <code>handleSubmit</code> itself doesn't change unless <code>productId</code> or <code>referrer</code> has changed. This lets you pass the <code>handleSubmit</code> function down without unnecessarily re-rendering <code>ShippingForm</code>. Your code won't run until the user submits the form.</li> </ul> <p>If you're already familiar with <code>useMemo</code>, you might find it helpful to think of <code>useCallback</code> as this:</p> <pre><code>// Simplified implementation (inside React)\nfunction useCallback(fn, dependencies) {\nreturn useMemo(() =&gt; fn, dependencies);\n}\n</code></pre> <p>Read more about the difference between <code>useMemo</code> and <code>useCallback</code>.</p> <p></p> <p>"},{"location":"reference/use-callback/#should-you-add-usecallback-everywhere","title":"Should you add useCallback everywhere?","text":"<p>If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.</p> <p>Caching a function with <code>useCallback</code> is only valuable in a few cases:</p> <ul> <li>You pass it as a prop to a component wrapped in <code>memo</code>. You want to skip re-rendering if the value hasn't changed. Memoization lets your component re-render only if dependencies changed.</li> <li>The function you're passing is later used as a dependency of some Hook. For example, another function wrapped in <code>useCallback</code> depends on it, or you depend on this function from <code>useEffect.</code></li> </ul> <p>There is no benefit to wrapping a function in <code>useCallback</code> in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that's \"always new\" is enough to break memoization for an entire component.</p> <p>Note that <code>useCallback</code> does not prevent creating the function. You're always creating a function (and that's fine!), but React ignores it and gives you back a cached function if nothing changed.</p> <p>In practice, you can make a lot of memoization unnecessary by following a few principles:</p> <ol> <li>When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children don't need to re-render.</li> <li>Prefer local state and don't lift state up any further than necessary. Don't keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.</li> <li>Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it's a bug in your component! Fix the bug instead of adding memoization.</li> <li>Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.</li> <li>Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it's often simpler to move some object or a function inside an Effect or outside the component.</li> </ol> <p>If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it's good to follow them in any case. In long term, we're researching doing memoization automatically to solve this once and for all.</p> <p></p> <p>"},{"location":"reference/use-callback/#skipping-re-rendering-with-usecallback-and-memo","title":"Skipping re-rendering with <code>useCallback</code> and <code>memo</code>","text":"<p>In this example, the <code>ShippingForm</code> component is artificially slowed down so that you can see what happens when a React component you're rendering is genuinely slow. Try incrementing the counter and toggling the theme.</p> <p>Incrementing the counter feels slow because it forces the slowed down <code>ShippingForm</code> to re-render. That's expected because the counter has changed, and so you need to reflect the user's new choice on the screen.</p> <p>Next, try toggling the theme. Thanks to <code>useCallback</code> together with <code>memo</code>, it\u2019s fast despite the artificial slowdown! <code>ShippingForm</code> skipped re-rendering because the <code>handleSubmit</code> function has not changed. The <code>handleSubmit</code> function has not changed because both <code>productId</code> and <code>referrer</code> (your <code>useCallback</code> dependencies) haven't changed since last render.</p> <pre><code>import { useState } from \"react\";\nimport ProductPage from \"./ProductPage.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ProductPage\nreferrerId=\"wizard_of_oz\"\nproductId={123}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useCallback } from \"react\";\nimport ShippingForm from \"./ShippingForm.js\";\n\nexport default function ProductPage({ productId, referrer, theme }) {\nconst handleSubmit = useCallback(\n(orderDetails) =&gt; {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n},\n[productId, referrer]\n);\n\nreturn (\n&lt;div className={theme}&gt;\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction post(url, data) {\n// Imagine this sends a request...\nconsole.log(\"POST /\" + url);\nconsole.log(data);\n}\n</code></pre> <pre><code>import { memo, useState } from \"react\";\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\nconst [count, setCount] = useState(1);\n\nconsole.log(\"[ARTIFICIALLY SLOW] Rendering &lt;ShippingForm /&gt;\");\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nfunction handleSubmit(e) {\ne.preventDefault();\nconst formData = new FormData(e.target);\nconst orderDetails = {\n...Object.fromEntries(formData),\ncount,\n};\nonSubmit(orderDetails);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;ShippingForm&lt;/code&gt; is artificially slowed down!\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;label&gt;\nNumber of items:\n&lt;button type=\"button\" onClick={() =&gt; setCount(count - 1)}&gt;\n\u2013\n&lt;/button&gt;\n{count}\n&lt;button type=\"button\" onClick={() =&gt; setCount(count + 1)}&gt;\n+\n&lt;/button&gt;\n&lt;/label&gt;\n&lt;label&gt;\nStreet:\n&lt;input name=\"street\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input name=\"city\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPostal code:\n&lt;input name=\"zipCode\" /&gt;\n&lt;/label&gt;\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n});\n\nexport default ShippingForm;\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\ninput {\nmargin-left: 5px;\n}\n\nbutton[type=\"button\"] {\nmargin: 5px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre>"},{"location":"reference/use-callback/#always-re-rendering-a-component","title":"Always re-rendering a component","text":"<p>In this example, the <code>ShippingForm</code> implementation is also artificially slowed down so that you can see what happens when some React component you're rendering is genuinely slow. Try incrementing the counter and toggling the theme.</p> <p>Unlike in the previous example, toggling the theme is also slow now! This is because there is no <code>useCallback</code> call in this version, so <code>handleSubmit</code> is always a new function, and the slowed down <code>ShippingForm</code> component can't skip re-rendering.</p> <pre><code>import { useState } from \"react\";\nimport ProductPage from \"./ProductPage.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ProductPage\nreferrerId=\"wizard_of_oz\"\nproductId={123}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import ShippingForm from \"./ShippingForm.js\";\n\nexport default function ProductPage({ productId, referrer, theme }) {\nfunction handleSubmit(orderDetails) {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n}\n\nreturn (\n&lt;div className={theme}&gt;\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction post(url, data) {\n// Imagine this sends a request...\nconsole.log(\"POST /\" + url);\nconsole.log(data);\n}\n</code></pre> <pre><code>import { memo, useState } from \"react\";\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\nconst [count, setCount] = useState(1);\n\nconsole.log(\"[ARTIFICIALLY SLOW] Rendering &lt;ShippingForm /&gt;\");\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nfunction handleSubmit(e) {\ne.preventDefault();\nconst formData = new FormData(e.target);\nconst orderDetails = {\n...Object.fromEntries(formData),\ncount,\n};\nonSubmit(orderDetails);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;ShippingForm&lt;/code&gt; is artificially slowed down!\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;label&gt;\nNumber of items:\n&lt;button type=\"button\" onClick={() =&gt; setCount(count - 1)}&gt;\n\u2013\n&lt;/button&gt;\n{count}\n&lt;button type=\"button\" onClick={() =&gt; setCount(count + 1)}&gt;\n+\n&lt;/button&gt;\n&lt;/label&gt;\n&lt;label&gt;\nStreet:\n&lt;input name=\"street\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input name=\"city\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPostal code:\n&lt;input name=\"zipCode\" /&gt;\n&lt;/label&gt;\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n});\n\nexport default ShippingForm;\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\ninput {\nmargin-left: 5px;\n}\n\nbutton[type=\"button\"] {\nmargin: 5px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>However, here is the same code with the artificial slowdown removed. Does the lack of <code>useCallback</code> feel noticeable or not?</p> <pre><code>import { useState } from \"react\";\nimport ProductPage from \"./ProductPage.js\";\n\nexport default function App() {\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ProductPage\nreferrerId=\"wizard_of_oz\"\nproductId={123}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import ShippingForm from \"./ShippingForm.js\";\n\nexport default function ProductPage({ productId, referrer, theme }) {\nfunction handleSubmit(orderDetails) {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n}\n\nreturn (\n&lt;div className={theme}&gt;\n&lt;ShippingForm onSubmit={handleSubmit} /&gt;\n&lt;/div&gt;\n);\n}\n\nfunction post(url, data) {\n// Imagine this sends a request...\nconsole.log(\"POST /\" + url);\nconsole.log(data);\n}\n</code></pre> <pre><code>import { memo, useState } from \"react\";\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\nconst [count, setCount] = useState(1);\n\nconsole.log(\"Rendering &lt;ShippingForm /&gt;\");\n\nfunction handleSubmit(e) {\ne.preventDefault();\nconst formData = new FormData(e.target);\nconst orderDetails = {\n...Object.fromEntries(formData),\ncount,\n};\nonSubmit(orderDetails);\n}\n\nreturn (\n&lt;form onSubmit={handleSubmit}&gt;\n&lt;label&gt;\nNumber of items:\n&lt;button type=\"button\" onClick={() =&gt; setCount(count - 1)}&gt;\n\u2013\n&lt;/button&gt;\n{count}\n&lt;button type=\"button\" onClick={() =&gt; setCount(count + 1)}&gt;\n+\n&lt;/button&gt;\n&lt;/label&gt;\n&lt;label&gt;\nStreet:\n&lt;input name=\"street\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input name=\"city\" /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nPostal code:\n&lt;input name=\"zipCode\" /&gt;\n&lt;/label&gt;\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n});\n\nexport default ShippingForm;\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\ninput {\nmargin-left: 5px;\n}\n\nbutton[type=\"button\"] {\nmargin: 5px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>Quite often, code without memoization works fine. If your interactions are fast enough, you don't need memoization.</p> <p>Keep in mind that you need to run React in production mode, disable React Developer Tools, and use devices similar to the ones your app's users have in order to get a realistic sense of what's actually slowing down your app.</p> <p></p>"},{"location":"reference/use-callback/#updating-state-from-a-memoized-callback","title":"Updating state from a memoized callback","text":"<p>Sometimes, you might need to update state based on previous state from a memoized callback.</p> <p>This <code>handleAddTodo</code> function specifies <code>todos</code> as a dependency because it computes the next todos from it:</p> <pre><code>function TodoList() {\nconst [todos, setTodos] = useState([]);\n\nconst handleAddTodo = useCallback((text) =&gt; {\nconst newTodo = { id: nextId++, text };\nsetTodos([...todos, newTodo]);\n}, [todos]);\n// ...\n</code></pre> <p>You'll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:</p> <pre><code>function TodoList() {\nconst [todos, setTodos] = useState([]);\n\nconst handleAddTodo = useCallback((text) =&gt; {\nconst newTodo = { id: nextId++, text };\nsetTodos(todos =&gt; [...todos, newTodo]);\n}, []); // \u2705 No need for the todos dependency\n// ...\n</code></pre> <p>Here, instead of making <code>todos</code> a dependency and reading it inside, you pass an instruction about how to update the state (<code>todos =&gt; [...todos, newTodo]</code>) to React. Read more about updater functions.</p>"},{"location":"reference/use-callback/#preventing-an-effect-from-firing-too-often","title":"Preventing an Effect from firing too often","text":"<p>Sometimes, you might want to call a function from inside an Effect:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nfunction createOptions() {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}\n\nuseEffect(() =&gt; {\nconst options = createOptions();\nconst connection = createConnection();\nconnection.connect();\n// ...\n</code></pre> <p>This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare <code>createOptions</code> as a dependency, it will cause your Effect to constantly reconnect to the chat room:</p> <pre><code>useEffect(() =&gt; {\nconst options = createOptions();\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [createOptions]); // \ud83d\udd34 Problem: This dependency changes on every render\n// ...\n</code></pre> <p>To solve this, you can wrap the function you need to call from an Effect into <code>useCallback</code>:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nconst createOptions = useCallback(() =&gt; {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}, [roomId]); // \u2705 Only changes when roomId changes\n\nuseEffect(() =&gt; {\nconst options = createOptions();\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [createOptions]); // \u2705 Only changes when createOptions changes\n// ...\n</code></pre> <p>This ensures that the <code>createOptions</code> function is the same between re-renders if the <code>roomId</code> is the same. However, it's even better to remove the need for a function dependency. Move your function inside the Effect:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nuseEffect(() =&gt; {\nfunction createOptions() { // \u2705 No need for useCallback or function dependencies!\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}\n\nconst options = createOptions();\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 Only changes when roomId changes\n// ...\n</code></pre> <p>Now your code is simpler and doesn't need <code>useCallback</code>. Learn more about removing Effect dependencies.</p>"},{"location":"reference/use-callback/#optimizing-a-custom-hook","title":"Optimizing a custom Hook","text":"<p>If you're writing a custom Hook, it's recommended to wrap any functions that it returns into <code>useCallback</code>:</p> <pre><code>function useRouter() {\nconst { dispatch } = useContext(RouterStateContext);\n\nconst navigate = useCallback(\n(url) =&gt; {\ndispatch({ type: \"navigate\", url });\n},\n[dispatch]\n);\n\nconst goBack = useCallback(() =&gt; {\ndispatch({ type: \"back\" });\n}, [dispatch]);\n\nreturn {\nnavigate,\ngoBack,\n};\n}\n</code></pre> <p>This ensures that the consumers of your Hook can optimize their own code when needed.</p>"},{"location":"reference/use-callback/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-callback/#every-time-my-component-renders-usecallback-returns-a-different-function","title":"Every time my component renders, <code>useCallback</code> returns a different function","text":"<p>Make sure you've specified the dependency array as a second argument!</p> <p>If you forget the dependency array, <code>useCallback</code> will return a new function every time:</p> <pre><code>function ProductPage({ productId, referrer }) {\nconst handleSubmit = useCallback((orderDetails) =&gt; {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}); // \ud83d\udd34 Returns a new function every time: no dependency array\n// ...\n</code></pre> <p>This is the corrected version passing the dependency array as a second argument:</p> <pre><code>function ProductPage({ productId, referrer }) {\nconst handleSubmit = useCallback((orderDetails) =&gt; {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]); // \u2705 Does not return a new function unnecessarily\n// ...\n</code></pre> <p>If this doesn't help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:</p> <pre><code>const handleSubmit = useCallback(\n(orderDetails) =&gt; {\n// ..\n},\n[productId, referrer]\n);\n\nconsole.log([productId, referrer]);\n</code></pre> <p>You can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as <code>temp1</code> and the second one got saved as <code>temp2</code>, you can then use the browser console to check whether each dependency in both arrays is the same:</p> <pre><code>Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n</code></pre> <p>When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.</p>"},{"location":"reference/use-callback/#i-need-to-call-usecallback-for-each-list-item-in-a-loop-but-its-not-allowed","title":"I need to call <code>useCallback</code> for each list item in a loop, but it's not allowed","text":"<p>Suppose the <code>Chart</code> component is wrapped in <code>memo</code>. You want to skip re-rendering every <code>Chart</code> in the list when the <code>ReportList</code> component re-renders. However, you can't call <code>useCallback</code> in a loop:</p> <pre><code>function ReportList({ items }) {\nreturn (\n&lt;article&gt;\n{items.map((item) =&gt; {\n// \ud83d\udd34 You can't call useCallback in a loop like this:\nconst handleClick = useCallback(() =&gt; {\nsendReport(item);\n}, [item]);\n\nreturn (\n&lt;figure key={item.id}&gt;\n&lt;Chart onClick={handleClick} /&gt;\n&lt;/figure&gt;\n);\n})}\n&lt;/article&gt;\n);\n}\n</code></pre> <p>Instead, extract a component for an individual item, and put <code>useCallback</code> there:</p> <pre><code>function ReportList({ items }) {\nreturn (\n&lt;article&gt;\n{items.map((item) =&gt; (\n&lt;Report key={item.id} item={item} /&gt;\n))}\n&lt;/article&gt;\n);\n}\n\nfunction Report({ item }) {\n// \u2705 Call useCallback at the top level:\nconst handleClick = useCallback(() =&gt; {\nsendReport(item);\n}, [item]);\n\nreturn (\n&lt;figure&gt;\n&lt;Chart onClick={handleClick} /&gt;\n&lt;/figure&gt;\n);\n}\n</code></pre> <p>Alternatively, you could remove <code>useCallback</code> in the last snippet and instead wrap <code>Report</code> itself in <code>memo</code>. If the <code>item</code> prop does not change, <code>Report</code> will skip re-rendering, so <code>Chart</code> will skip re-rendering too:</p> <pre><code>function ReportList({ items }) {\n// ...\n}\n\nconst Report = memo(function Report({ item }) {\nfunction handleClick() {\nsendReport(item);\n}\n\nreturn (\n&lt;figure&gt;\n&lt;Chart onClick={handleClick} /&gt;\n&lt;/figure&gt;\n);\n});\n</code></pre>"},{"location":"reference/use-context/","title":"Use Context \ud83d\udea7","text":""},{"location":"reference/use-context/#overview","title":"Overview","text":"<p> <code>useContext</code> is a React Hook that lets you read and subscribe to context from your component.  <pre><code>const value = useContext(SomeContext);\n</code></pre> </p>"},{"location":"reference/use-context/#reference","title":"Reference","text":""},{"location":"reference/use-context/#usecontextsomecontext","title":"<code>useContext(SomeContext)</code>","text":"<p>Call <code>useContext</code> at the top level of your component to read and subscribe to context.</p> <pre><code>import { useContext } from 'react';\n\nfunction MyComponent() {\nconst theme = useContext(ThemeContext);\n// ...\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-context/#parameters","title":"Parameters","text":"<ul> <li><code>SomeContext</code>: The context that you've previously created with <code>createContext</code>. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.</li> </ul>"},{"location":"reference/use-context/#returns","title":"Returns","text":"<p><code>useContext</code> returns the context value for the calling component. It is determined as the <code>value</code> passed to the closest <code>SomeContext.Provider</code> above the calling component in the tree. If there is no such provider, then the returned value will be the <code>defaultValue</code> you have passed to <code>createContext</code> for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.</p>"},{"location":"reference/use-context/#caveats","title":"Caveats","text":"<ul> <li><code>useContext()</code> call in a component is not affected by providers returned from the same component. The corresponding <code>&lt;Context.Provider&gt;</code> needs to be above the component doing the <code>useContext()</code> call.</li> <li>React automatically re-renders all the children that use a particular context starting from the provider that receives a different <code>value</code>. The previous and the next values are compared with the <code>Object.is</code> comparison. Skipping re-renders with <code>memo</code> does not prevent the children receiving fresh context values.</li> <li>If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if <code>SomeContext</code> that you use to provide context and <code>SomeContext</code> that you use to read it are exactly the same object, as determined by a <code>===</code> comparison.</li> </ul>"},{"location":"reference/use-context/#usage","title":"Usage","text":""},{"location":"reference/use-context/#passing-data-deeply-into-the-tree","title":"Passing data deeply into the tree","text":"<p>Call <code>useContext</code> at the top level of your component to read and subscribe to context.</p> <pre><code>import { useContext } from 'react';\n\nfunction Button() {\nconst theme = useContext(ThemeContext);\n// ...\n</code></pre> <p><code>useContext</code> returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.</p> <p>To pass context to a <code>Button</code>, wrap it or one of its parent components into the corresponding context provider:</p> <pre><code>function MyPage() {\nreturn (\n&lt;ThemeContext.Provider value=\"dark\"&gt;\n&lt;Form /&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction Form() {\n// ... renders buttons inside ...\n}\n</code></pre> <p>It doesn't matter how many layers of components there are between the provider and the <code>Button</code>. When a <code>Button</code> anywhere inside of <code>Form</code> calls <code>useContext(ThemeContext)</code>, it will receive <code>\"dark\"</code> as the value.</p> <p> <p><code>useContext()</code> always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you're calling <code>useContext()</code>.</p> <p></p> <pre><code>import { createContext, useContext } from \"react\";\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\nreturn (\n&lt;ThemeContext.Provider value=\"dark\"&gt;\n&lt;Form /&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction Form() {\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n&lt;Button&gt;Sign up&lt;/Button&gt;\n&lt;Button&gt;Log in&lt;/Button&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn &lt;button className={className}&gt;{children}&lt;/button&gt;;\n}\n</code></pre> <pre><code>.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre>"},{"location":"reference/use-context/#updating-data-passed-via-context","title":"Updating data passed via context","text":"<p>Often, you'll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.</p> <pre><code>function MyPage() {\nconst [theme, setTheme] = useState(\"dark\");\nreturn (\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;Form /&gt;\n&lt;Button\nonClick={() =&gt; {\nsetTheme(\"light\");\n}}\n&gt;\nSwitch to light theme\n&lt;/Button&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n</code></pre> <p>Now any <code>Button</code> inside of the provider will receive the current <code>theme</code> value. If you call <code>setTheme</code> to update the <code>theme</code> value that you pass to the provider, all <code>Button</code> components will re-render with the new <code>'light'</code> value.</p> <p>"},{"location":"reference/use-context/#updating-a-value-via-context","title":"Updating a value via context","text":"<p>In this example, the <code>MyApp</code> component holds a state variable which is then passed to the <code>ThemeContext</code> provider. Checking the \"Dark mode\" checkbox updates the state. Changing the provided value re-renders all the components using that context.</p> <pre><code>import { createContext, useContext, useState } from \"react\";\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\nconst [theme, setTheme] = useState(\"light\");\nreturn (\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;Form /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={theme === \"dark\"}\nonChange={(e) =&gt; {\nsetTheme(e.target.checked ? \"dark\" : \"light\");\n}}\n/&gt;\nUse dark mode\n&lt;/label&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction Form({ children }) {\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n&lt;Button&gt;Sign up&lt;/Button&gt;\n&lt;Button&gt;Log in&lt;/Button&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn &lt;button className={className}&gt;{children}&lt;/button&gt;;\n}\n</code></pre> <pre><code>.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\nmargin-bottom: 10px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre> <p>Note that <code>value=\"dark\"</code> passes the <code>\"dark\"</code> string, but <code>value={theme}</code> passes the value of the JavaScript <code>theme</code> variable with JSX curly braces. Curly braces also let you pass context values that aren't strings.</p>"},{"location":"reference/use-context/#updating-an-object-via-context","title":"Updating an object via context","text":"<p>In this example, there is a <code>currentUser</code> state variable which holds an object. You combine <code>{ currentUser, setCurrentUser }</code> into a single object and pass it down through the context inside the <code>value={}</code>. This lets any component below, such as <code>LoginButton</code>, read both <code>currentUser</code> and <code>setCurrentUser</code>, and then call <code>setCurrentUser</code> when needed.</p> <pre><code>import { createContext, useContext, useState } from \"react\";\n\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\nconst [currentUser, setCurrentUser] = useState(null);\nreturn (\n&lt;CurrentUserContext.Provider\nvalue={{\ncurrentUser,\nsetCurrentUser,\n}}\n&gt;\n&lt;Form /&gt;\n&lt;/CurrentUserContext.Provider&gt;\n);\n}\n\nfunction Form({ children }) {\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n&lt;LoginButton /&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction LoginButton() {\nconst { currentUser, setCurrentUser } = useContext(CurrentUserContext);\n\nif (currentUser !== null) {\nreturn &lt;p&gt;You logged in as {currentUser.name}.&lt;/p&gt;;\n}\n\nreturn (\n&lt;Button\nonClick={() =&gt; {\nsetCurrentUser({ name: \"Advika\" });\n}}\n&gt;\nLog in as Advika\n&lt;/Button&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nreturn (\n&lt;section className=\"panel\"&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children, onClick }) {\nreturn (\n&lt;button className=\"button\" onClick={onClick}&gt;\n{children}\n&lt;/button&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\n\n.panel {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\nmargin-bottom: 10px;\n}\n\n.button {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n</code></pre>"},{"location":"reference/use-context/#multiple-contexts","title":"Multiple contexts","text":"<p>In this example, there are two independent contexts. <code>ThemeContext</code> provides the current theme, which is a string, while <code>CurrentUserContext</code> holds the object representing the current user.</p> <pre><code>import { createContext, useContext, useState } from \"react\";\n\nconst ThemeContext = createContext(null);\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\nconst [theme, setTheme] = useState(\"light\");\nconst [currentUser, setCurrentUser] = useState(null);\nreturn (\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;CurrentUserContext.Provider\nvalue={{\ncurrentUser,\nsetCurrentUser,\n}}\n&gt;\n&lt;WelcomePanel /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={theme === \"dark\"}\nonChange={(e) =&gt; {\nsetTheme(e.target.checked ? \"dark\" : \"light\");\n}}\n/&gt;\nUse dark mode\n&lt;/label&gt;\n&lt;/CurrentUserContext.Provider&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction WelcomePanel({ children }) {\nconst { currentUser } = useContext(CurrentUserContext);\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n{currentUser !== null ? &lt;Greeting /&gt; : &lt;LoginForm /&gt;}\n&lt;/Panel&gt;\n);\n}\n\nfunction Greeting() {\nconst { currentUser } = useContext(CurrentUserContext);\nreturn &lt;p&gt;You logged in as {currentUser.name}.&lt;/p&gt;;\n}\n\nfunction LoginForm() {\nconst { setCurrentUser } = useContext(CurrentUserContext);\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\nconst canLogin = firstName !== \"\" &amp;&amp; lastName !== \"\";\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name{\": \"}\n&lt;input\nrequired\nvalue={firstName}\nonChange={(e) =&gt; setFirstName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name{\": \"}\n&lt;input\nrequired\nvalue={lastName}\nonChange={(e) =&gt; setLastName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;Button\ndisabled={!canLogin}\nonClick={() =&gt; {\nsetCurrentUser({\nname: firstName + \" \" + lastName,\n});\n}}\n&gt;\nLog in\n&lt;/Button&gt;\n{!canLogin &amp;&amp; &lt;i&gt;Fill in both fields.&lt;/i&gt;}\n&lt;/&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children, disabled, onClick }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn (\n&lt;button className={className} disabled={disabled} onClick={onClick}&gt;\n{children}\n&lt;/button&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\n\n.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\nmargin-bottom: 10px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre>"},{"location":"reference/use-context/#extracting-providers-to-a-component","title":"Extracting providers to a component","text":"<p>As your app grows, it is expected that you'll have a \"pyramid\" of contexts closer to the root of your app. There is nothing wrong with that. However, if you dislike the nesting aesthetically, you can extract the providers into a single component. In this example, <code>MyProviders</code> hides the \"plumbing\" and renders the children passed to it inside the necessary providers. Note that the <code>theme</code> and <code>setTheme</code> state is needed in <code>MyApp</code> itself, so <code>MyApp</code> still owns that piece of the state.</p> <pre><code>import { createContext, useContext, useState } from \"react\";\n\nconst ThemeContext = createContext(null);\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\nconst [theme, setTheme] = useState(\"light\");\nreturn (\n&lt;MyProviders theme={theme} setTheme={setTheme}&gt;\n&lt;WelcomePanel /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={theme === \"dark\"}\nonChange={(e) =&gt; {\nsetTheme(e.target.checked ? \"dark\" : \"light\");\n}}\n/&gt;\nUse dark mode\n&lt;/label&gt;\n&lt;/MyProviders&gt;\n);\n}\n\nfunction MyProviders({ children, theme, setTheme }) {\nconst [currentUser, setCurrentUser] = useState(null);\nreturn (\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;CurrentUserContext.Provider\nvalue={{\ncurrentUser,\nsetCurrentUser,\n}}\n&gt;\n{children}\n&lt;/CurrentUserContext.Provider&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction WelcomePanel({ children }) {\nconst { currentUser } = useContext(CurrentUserContext);\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n{currentUser !== null ? &lt;Greeting /&gt; : &lt;LoginForm /&gt;}\n&lt;/Panel&gt;\n);\n}\n\nfunction Greeting() {\nconst { currentUser } = useContext(CurrentUserContext);\nreturn &lt;p&gt;You logged in as {currentUser.name}.&lt;/p&gt;;\n}\n\nfunction LoginForm() {\nconst { setCurrentUser } = useContext(CurrentUserContext);\nconst [firstName, setFirstName] = useState(\"\");\nconst [lastName, setLastName] = useState(\"\");\nconst canLogin = firstName !== \"\" &amp;&amp; lastName !== \"\";\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name{\": \"}\n&lt;input\nrequired\nvalue={firstName}\nonChange={(e) =&gt; setFirstName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name{\": \"}\n&lt;input\nrequired\nvalue={lastName}\nonChange={(e) =&gt; setLastName(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;Button\ndisabled={!canLogin}\nonClick={() =&gt; {\nsetCurrentUser({\nname: firstName + \" \" + lastName,\n});\n}}\n&gt;\nLog in\n&lt;/Button&gt;\n{!canLogin &amp;&amp; &lt;i&gt;Fill in both fields.&lt;/i&gt;}\n&lt;/&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children, disabled, onClick }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn (\n&lt;button className={className} disabled={disabled} onClick={onClick}&gt;\n{children}\n&lt;/button&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\n\n.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\nmargin-bottom: 10px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre>"},{"location":"reference/use-context/#scaling-up-with-context-and-a-reducer","title":"Scaling up with context and a reducer","text":"<p>In larger apps, it is common to combine context with a reducer to extract the logic related to some state out of components. In this example, all the \"wiring\" is hidden in the <code>TasksContext.js</code>, which contains a reducer and two separate contexts.</p> <p>Read a full walkthrough of this example.</p> <pre><code>import AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\nimport { TasksProvider } from \"./TasksContext.js\";\n\nexport default function TaskApp() {\nreturn (\n&lt;TasksProvider&gt;\n&lt;h1&gt;Day off in Kyoto&lt;/h1&gt;\n&lt;AddTask /&gt;\n&lt;TaskList /&gt;\n&lt;/TasksProvider&gt;\n);\n}\n</code></pre> <pre><code>import { createContext, useContext, useReducer } from \"react\";\n\nconst TasksContext = createContext(null);\n\nconst TasksDispatchContext = createContext(null);\n\nexport function TasksProvider({ children }) {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nreturn (\n&lt;TasksContext.Provider value={tasks}&gt;\n&lt;TasksDispatchContext.Provider value={dispatch}&gt;\n{children}\n&lt;/TasksDispatchContext.Provider&gt;\n&lt;/TasksContext.Provider&gt;\n);\n}\n\nexport function useTasks() {\nreturn useContext(TasksContext);\n}\n\nexport function useTasksDispatch() {\nreturn useContext(TasksDispatchContext);\n}\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nconst initialTasks = [\n{ id: 0, text: \"Philosopher\u2019s Path\", done: true },\n{ id: 1, text: \"Visit the temple\", done: false },\n{ id: 2, text: \"Drink matcha\", done: false },\n];\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { useTasksDispatch } from \"./TasksContext.js\";\n\nexport default function AddTask() {\nconst [text, setText] = useState(\"\");\nconst dispatch = useTasksDispatch();\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\nonClick={() =&gt; {\nsetText(\"\");\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\n</code></pre> <pre><code>import { useState, useContext } from \"react\";\nimport { useTasks, useTasksDispatch } from \"./TasksContext.js\";\n\nexport default function TaskList() {\nconst tasks = useTasks();\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task task={task} /&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task }) {\nconst [isEditing, setIsEditing] = useState(false);\nconst dispatch = useTasksDispatch();\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ntext: e.target.value,\n},\n});\n}}\n/&gt;\n&lt;button onClick={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button onClick={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed\",\ntask: {\n...task,\ndone: e.target.checked,\n},\n});\n}}\n/&gt;\n{taskContent}\n&lt;button\nonClick={() =&gt; {\ndispatch({\ntype: \"deleted\",\nid: task.id,\n});\n}}\n&gt;\nDelete\n&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p></p>"},{"location":"reference/use-context/#specifying-a-fallback-default-value","title":"Specifying a fallback default value","text":"<p>If React can't find any providers of that particular context in the parent tree, the context value returned by <code>useContext()</code> will be equal to the default value that you specified when you created that context:</p> <pre><code>const ThemeContext = createContext(null);\n</code></pre> <p>The default value never changes. If you want to update context, use it with state as described above.</p> <p>Often, instead of <code>null</code>, there is some more meaningful value you can use as a default, for example:</p> <pre><code>const ThemeContext = createContext(\"light\");\n</code></pre> <p>This way, if you accidentally render some component without a corresponding provider, it won't break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.</p> <p>In the example below, the \"Toggle theme\" button is always light because it's outside any theme context provider and the default context theme value is <code>'light'</code>. Try editing the default theme to be <code>'dark'</code>.</p> <pre><code>import { createContext, useContext, useState } from \"react\";\n\nconst ThemeContext = createContext(\"light\");\n\nexport default function MyApp() {\nconst [theme, setTheme] = useState(\"light\");\nreturn (\n&lt;&gt;\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;Form /&gt;\n&lt;/ThemeContext.Provider&gt;\n&lt;Button\nonClick={() =&gt; {\nsetTheme(theme === \"dark\" ? \"light\" : \"dark\");\n}}\n&gt;\nToggle theme\n&lt;/Button&gt;\n&lt;/&gt;\n);\n}\n\nfunction Form({ children }) {\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n&lt;Button&gt;Sign up&lt;/Button&gt;\n&lt;Button&gt;Log in&lt;/Button&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children, onClick }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn (\n&lt;button className={className} onClick={onClick}&gt;\n{children}\n&lt;/button&gt;\n);\n}\n</code></pre> <pre><code>.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\nmargin-bottom: 10px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre>"},{"location":"reference/use-context/#overriding-context-for-a-part-of-the-tree","title":"Overriding context for a part of the tree","text":"<p>You can override the context for a part of the tree by wrapping that part in a provider with a different value.</p> <pre><code>&lt;ThemeContext.Provider value=\"dark\"&gt;\n...\n&lt;ThemeContext.Provider value=\"light\"&gt;\n&lt;Footer /&gt;\n&lt;/ThemeContext.Provider&gt;\n...\n&lt;/ThemeContext.Provider&gt;\n</code></pre> <p>You can nest and override providers as many times as you need.</p> <p>"},{"location":"reference/use-context/#overriding-a-theme","title":"Overriding a theme","text":"<p>Here, the button inside the <code>Footer</code> receives a different context value (<code>\"light\"</code>) than the buttons outside (<code>\"dark\"</code>).</p> <pre><code>import { createContext, useContext } from \"react\";\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\nreturn (\n&lt;ThemeContext.Provider value=\"dark\"&gt;\n&lt;Form /&gt;\n&lt;/ThemeContext.Provider&gt;\n);\n}\n\nfunction Form() {\nreturn (\n&lt;Panel title=\"Welcome\"&gt;\n&lt;Button&gt;Sign up&lt;/Button&gt;\n&lt;Button&gt;Log in&lt;/Button&gt;\n&lt;ThemeContext.Provider value=\"light\"&gt;\n&lt;Footer /&gt;\n&lt;/ThemeContext.Provider&gt;\n&lt;/Panel&gt;\n);\n}\n\nfunction Footer() {\nreturn (\n&lt;footer&gt;\n&lt;Button&gt;Settings&lt;/Button&gt;\n&lt;/footer&gt;\n);\n}\n\nfunction Panel({ title, children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"panel-\" + theme;\nreturn (\n&lt;section className={className}&gt;\n{title &amp;&amp; &lt;h1&gt;{title}&lt;/h1&gt;}\n{children}\n&lt;/section&gt;\n);\n}\n\nfunction Button({ children }) {\nconst theme = useContext(ThemeContext);\nconst className = \"button-\" + theme;\nreturn &lt;button className={className}&gt;{children}&lt;/button&gt;;\n}\n</code></pre> <pre><code>footer {\nmargin-top: 20px;\nborder-top: 1px solid #aaa;\n}\n\n.panel-light,\n.panel-dark {\nborder: 1px solid black;\nborder-radius: 4px;\npadding: 20px;\n}\n.panel-light {\ncolor: #222;\nbackground: #fff;\n}\n\n.panel-dark {\ncolor: #fff;\nbackground: rgb(23, 32, 42);\n}\n\n.button-light,\n.button-dark {\nborder: 1px solid #777;\npadding: 5px;\nmargin-right: 10px;\nmargin-top: 10px;\n}\n\n.button-dark {\nbackground: #222;\ncolor: #fff;\n}\n\n.button-light {\nbackground: #fff;\ncolor: #222;\n}\n</code></pre>"},{"location":"reference/use-context/#automatically-nested-headings","title":"Automatically nested headings","text":"<p>You can \"accumulate\" information when you nest context providers. In this example, the <code>Section</code> component keeps track of the <code>LevelContext</code> which specifies the depth of the section nesting. It reads the <code>LevelContext</code> from the parent section, and provides the <code>LevelContext</code> number increased by one to its children. As a result, the <code>Heading</code> component can automatically decide which of the <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, ..., tags to use based on how many <code>Section</code> components it is nested inside of.</p> <p>Read a detailed walkthrough of this example.</p> <pre><code>import Heading from \"./Heading.js\";\nimport Section from \"./Section.js\";\n\nexport default function Page() {\nreturn (\n&lt;Section&gt;\n&lt;Heading&gt;Title&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Heading&gt;Heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-heading&lt;/Heading&gt;\n&lt;Section&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n&lt;/Section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Section({ children }) {\nconst level = useContext(LevelContext);\nreturn (\n&lt;section className=\"section\"&gt;\n&lt;LevelContext.Provider value={level + 1}&gt;\n{children}\n&lt;/LevelContext.Provider&gt;\n&lt;/section&gt;\n);\n}\n</code></pre> <pre><code>import { useContext } from \"react\";\nimport { LevelContext } from \"./LevelContext.js\";\n\nexport default function Heading({ children }) {\nconst level = useContext(LevelContext);\nswitch (level) {\ncase 0:\nthrow Error(\"Heading must be inside a Section!\");\ncase 1:\nreturn &lt;h1&gt;{children}&lt;/h1&gt;;\ncase 2:\nreturn &lt;h2&gt;{children}&lt;/h2&gt;;\ncase 3:\nreturn &lt;h3&gt;{children}&lt;/h3&gt;;\ncase 4:\nreturn &lt;h4&gt;{children}&lt;/h4&gt;;\ncase 5:\nreturn &lt;h5&gt;{children}&lt;/h5&gt;;\ncase 6:\nreturn &lt;h6&gt;{children}&lt;/h6&gt;;\ndefault:\nthrow Error(\"Unknown level: \" + level);\n}\n}\n</code></pre> <pre><code>import { createContext } from \"react\";\n\nexport const LevelContext = createContext(0);\n</code></pre> <pre><code>.section {\npadding: 10px;\nmargin: 5px;\nborder-radius: 5px;\nborder: 1px solid #aaa;\n}\n</code></pre> <p></p>"},{"location":"reference/use-context/#optimizing-re-renders-when-passing-objects-and-functions","title":"Optimizing re-renders when passing objects and functions","text":"<p>You can pass any values via context, including objects and functions.</p> <pre><code>function MyApp() {\nconst [currentUser, setCurrentUser] = useState(null);\n\nfunction login(response) {\nstoreCredentials(response.credentials);\nsetCurrentUser(response.user);\n}\n\nreturn (\n&lt;AuthContext.Provider value={{ currentUser, login }}&gt;\n&lt;Page /&gt;\n&lt;/AuthContext.Provider&gt;\n);\n}\n</code></pre> <p>Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever <code>MyApp</code> re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call <code>useContext(AuthContext)</code>.</p> <p>In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like <code>currentUser</code>, has not changed. To help React take advantage of that fact, you may wrap the <code>login</code> function with <code>useCallback</code> and wrap the object creation into <code>useMemo</code>. This is a performance optimization:</p> <pre><code>import { useCallback, useMemo } from \"react\";\n\nfunction MyApp() {\nconst [currentUser, setCurrentUser] = useState(null);\n\nconst login = useCallback((response) =&gt; {\nstoreCredentials(response.credentials);\nsetCurrentUser(response.user);\n}, []);\n\nconst contextValue = useMemo(\n() =&gt; ({\ncurrentUser,\nlogin,\n}),\n[currentUser, login]\n);\n\nreturn (\n&lt;AuthContext.Provider value={contextValue}&gt;\n&lt;Page /&gt;\n&lt;/AuthContext.Provider&gt;\n);\n}\n</code></pre> <p>As a result of this change, even if <code>MyApp</code> needs to re-render, the components calling <code>useContext(AuthContext)</code> won't need to re-render unless <code>currentUser</code> has changed.</p> <p>Read more about <code>useMemo</code> and <code>useCallback</code>.</p>"},{"location":"reference/use-context/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-context/#my-component-doesnt-see-the-value-from-my-provider","title":"My component doesn't see the value from my provider","text":"<p>There are a few common ways that this can happen:</p> <ol> <li>You're rendering <code>&lt;SomeContext.Provider&gt;</code> in the same component (or below) as where you're calling <code>useContext()</code>. Move <code>&lt;SomeContext.Provider&gt;</code> above and outside the component calling <code>useContext()</code>.</li> <li>You may have forgotten to wrap your component with <code>&lt;SomeContext.Provider&gt;</code>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools.</li> <li>You might be running into some build issue with your tooling that causes <code>SomeContext</code> as seen from the providing component and <code>SomeContext</code> as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like <code>window.SomeContext1</code> and <code>window.SomeContext2</code> and then checking whether <code>window.SomeContext1 === window.SomeContext2</code> in the console. If they're not the same, fix that issue on the build tool level.</li> </ol>"},{"location":"reference/use-context/#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different","title":"I am always getting <code>undefined</code> from my context although the default value is different","text":"<p>You might have a provider without a <code>value</code> in the tree:</p> <pre><code>// \ud83d\udea9 Doesn't work: no value prop\n&lt;ThemeContext.Provider&gt;\n&lt;Button /&gt;\n&lt;/ThemeContext.Provider&gt;\n</code></pre> <p>If you forget to specify <code>value</code>, it's like passing <code>value={undefined}</code>.</p> <p>You may have also mistakingly used a different prop name by mistake:</p> <pre><code>// \ud83d\udea9 Doesn't work: prop should be called \"value\"\n&lt;ThemeContext.Provider theme={theme}&gt;\n&lt;Button /&gt;\n&lt;/ThemeContext.Provider&gt;\n</code></pre> <p>In both of these cases you should see a warning from React in the console. To fix them, call the prop <code>value</code>:</p> <pre><code>// \u2705 Passing the value prop\n&lt;ThemeContext.Provider value={theme}&gt;\n&lt;Button /&gt;\n&lt;/ThemeContext.Provider&gt;\n</code></pre> <p>Note that the default value from your <code>createContext(defaultValue)</code> call is only used if there is no matching provider above at all. If there is a <code>&lt;SomeContext.Provider value={undefined}&gt;</code> component somewhere in the parent tree, the component calling <code>useContext(SomeContext)</code> will receive <code>undefined</code> as the context value.</p>"},{"location":"reference/use-debug-value/","title":"Use Debug Value \ud83d\udea7","text":""},{"location":"reference/use-debug-value/#overview","title":"Overview","text":"<p> <code>useDebugValue</code> is a React Hook that lets you add a label to a custom Hook in React DevTools. <pre><code>useDebugValue(value, format?)\n</code></pre> </p>"},{"location":"reference/use-debug-value/#reference","title":"Reference","text":""},{"location":"reference/use-debug-value/#usedebugvaluevalue-format","title":"<code>useDebugValue(value, format?)</code>","text":"<p>Call <code>useDebugValue</code> at the top level of your custom Hook to display a readable debug value:</p> <pre><code>import { useDebugValue } from \"react\";\n\nfunction useOnlineStatus() {\n// ...\nuseDebugValue(isOnline ? \"Online\" : \"Offline\");\n// ...\n}\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-debug-value/#parameters","title":"Parameters","text":"<ul> <li><code>value</code>: The value you want to display in React DevTools. It can have any type.</li> <li>optional <code>format</code>: A formatting function. When the component is inspected, React DevTools will call the formatting function with the <code>value</code> as the argument, and then display the returned formatted value (which may have any type). If you don't specify the formatting function, the original <code>value</code> itself will be displayed.</li> </ul>"},{"location":"reference/use-debug-value/#returns","title":"Returns","text":"<p><code>useDebugValue</code> does not return anything.</p>"},{"location":"reference/use-debug-value/#usage","title":"Usage","text":""},{"location":"reference/use-debug-value/#adding-a-label-to-a-custom-hook","title":"Adding a label to a custom Hook","text":"<p>Call <code>useDebugValue</code> at the top level of your custom Hook to display a readable debug value for React DevTools.</p> <pre><code>import { useDebugValue } from \"react\";\n\nfunction useOnlineStatus() {\n// ...\nuseDebugValue(isOnline ? \"Online\" : \"Offline\");\n// ...\n}\n</code></pre> <p>This gives components calling <code>useOnlineStatus</code> a label like <code>OnlineStatus: \"Online\"</code> when you inspect them:</p> <p></p> <p>Without the <code>useDebugValue</code> call, only the underlying data (in this example, <code>true</code>) would be displayed.</p> <pre><code>import { useOnlineStatus } from \"./useOnlineStatus.js\";\n\nfunction StatusBar() {\nconst isOnline = useOnlineStatus();\nreturn &lt;h1&gt;{isOnline ? \"\u2705 Online\" : \"\u274c Disconnected\"}&lt;/h1&gt;;\n}\n\nexport default function App() {\nreturn &lt;StatusBar /&gt;;\n}\n</code></pre> <pre><code>import { useSyncExternalStore, useDebugValue } from \"react\";\n\nexport function useOnlineStatus() {\nconst isOnline = useSyncExternalStore(\nsubscribe,\n() =&gt; navigator.onLine,\n() =&gt; true\n);\nuseDebugValue(isOnline ? \"Online\" : \"Offline\");\nreturn isOnline;\n}\n\nfunction subscribe(callback) {\nwindow.addEventListener(\"online\", callback);\nwindow.addEventListener(\"offline\", callback);\nreturn () =&gt; {\nwindow.removeEventListener(\"online\", callback);\nwindow.removeEventListener(\"offline\", callback);\n};\n}\n</code></pre> <p> <p>Don't add debug values to every custom Hook. It's most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that's difficult to inspect.</p> <p></p>"},{"location":"reference/use-debug-value/#deferring-formatting-of-a-debug-value","title":"Deferring formatting of a debug value","text":"<p>You can also pass a formatting function as the second argument to <code>useDebugValue</code>:</p> <pre><code>useDebugValue(date, (date) =&gt; date.toDateString());\n</code></pre> <p>Your formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.</p> <p>This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if <code>date</code> is a Date value, this avoids calling <code>toDateString()</code> on it for every render.</p>"},{"location":"reference/use-deferred-value/","title":"Use deferred value","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"},{"location":"reference/use-effect/","title":"Use Effect \ud83d\udea7","text":""},{"location":"reference/use-effect/#overview","title":"Overview","text":"<p> <code>useEffect</code> is a React Hook that lets you synchronize a component with an external system. <pre><code>useEffect(setup, dependencies?)\n</code></pre> </p>"},{"location":"reference/use-effect/#reference","title":"Reference","text":""},{"location":"reference/use-effect/#useeffectsetup-dependencies","title":"<code>useEffect(setup, dependencies?)</code>","text":"<p>Call <code>useEffect</code> at the top level of your component to declare an Effect:</p> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-effect/#parameters","title":"Parameters","text":"<ul> <li> <p><code>setup</code>: The function with your Effect's logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.</p> </li> <li> <p>optional <code>dependencies</code>: The list of all reactive values referenced inside of the <code>setup</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code>[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <code>Object.is</code> comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.</p> </li> </ul>"},{"location":"reference/use-effect/#returns","title":"Returns","text":"<p><code>useEffect</code> returns <code>undefined</code>.</p>"},{"location":"reference/use-effect/#caveats","title":"Caveats","text":"<ul> <li> <p><code>useEffect</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</p> </li> <li> <p>If you're not trying to synchronize with some external system, you probably don't need an Effect.</p> </li> <li> <p>When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic \"mirrors\" your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.</p> </li> <li> <p>If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.</p> </li> <li> <p>If your Effect wasn't caused by an interaction (like a click), React will let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace <code>useEffect</code> with <code>useLayoutEffect</code>.</p> </li> <li> <p>Even if your Effect was caused by an interaction (like a click), the browser may repaint the screen before processing the state updates inside your Effect. Usually, that's what you want. However, if you must block the browser from repainting the screen, you need to replace <code>useEffect</code> with <code>useLayoutEffect</code>.</p> </li> <li> <p>Effects only run on the client. They don't run during server rendering.</p> </li> </ul>"},{"location":"reference/use-effect/#usage","title":"Usage","text":""},{"location":"reference/use-effect/#connecting-to-an-external-system","title":"Connecting to an external system","text":"<p>Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren't controlled by React, so they are called external.</p> <p>To connect your component to some external system, call <code>useEffect</code> at the top level of your component:</p> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\n</code></pre> <p>You need to pass two arguments to <code>useEffect</code>:</p> <ol> <li>A setup function with setup code that connects to that system.<ul> <li>It should return a cleanup function with cleanup code that disconnects from that system.</li> </ul> </li> <li>A list of dependencies including every value from your component used inside of those functions.</li> </ol> <p>React calls your setup and cleanup functions whenever it's necessary, which may happen multiple times:</p> <ol> <li>Your setup code runs when your component is added to the page (mounts).</li> <li>After every re-render of your component where the dependencies have changed:<ul> <li>First, your cleanup code runs with the old props and state.</li> <li>Then, your setup code runs with the new props and state.</li> </ul> </li> <li>Your cleanup code runs one final time after your component is removed from the page (unmounts).</li> </ol> <p>Let's illustrate this sequence for the example above.</p> <p>When the <code>ChatRoom</code> component above gets added to the page, it will connect to the chat room with the initial <code>serverUrl</code> and <code>roomId</code>. If either <code>serverUrl</code> or <code>roomId</code> change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the <code>ChatRoom</code> component is removed from the page, your Effect will disconnect one last time.</p> <p>To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect's logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn't be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development). See common solutions.</p> <p>Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn't matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly \"mirrors\" the setup logic, your Effect is resilient to running setup and cleanup as often as needed.</p> <p> <p>An Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code that's not controlled by React, such as:</p> <ul> <li>A timer managed with <code>setInterval()</code> and <code>clearInterval()</code>.</li> <li>An event subscription using <code>window.addEventListener()</code> and <code>window.removeEventListener()</code>.</li> <li>A third-party animation library with an API like <code>animation.start()</code> and <code>animation.reset()</code>.</li> </ul> <p>If you're not connecting to any external system, you probably don't need an Effect.</p> <p></p> <p>"},{"location":"reference/use-effect/#connecting-to-a-chat-server","title":"Connecting to a chat server","text":"<p>In this example, the <code>ChatRoom</code> component uses an Effect to stay connected to an external system defined in <code>chat.js</code>. Press \"Open chat\" to make the <code>ChatRoom</code> component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the <code>roomId</code> and <code>serverUrl</code> using the dropdown and the input, and see how the Effect re-connects to the chat. Press \"Close chat\" to see the Effect disconnect one last time.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre>"},{"location":"reference/use-effect/#listening-to-a-global-browser-event","title":"Listening to a global browser event","text":"<p>In this example, the external system is the browser DOM itself. Normally, you'd specify event listeners with JSX, but you can't listen to the global <code>window</code> object this way. An Effect lets you connect to the <code>window</code> object and listen to its events. Listening to the <code>pointermove</code> event lets you track the cursor (or finger) position and update the red dot to move with it.</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseEffect(() =&gt; {\nfunction handleMove(e) {\nsetPosition({ x: e.clientX, y: e.clientY });\n}\nwindow.addEventListener(\"pointermove\", handleMove);\nreturn () =&gt; {\nwindow.removeEventListener(\"pointermove\", handleMove);\n};\n}, []);\n\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-effect/#triggering-an-animation","title":"Triggering an animation","text":"<p>In this example, the external system is the animation library in <code>animation.js</code>. It provides a JavaScript class called <code>FadeInAnimation</code> that takes a DOM node as an argument and exposes <code>start()</code> and <code>stop()</code> methods to control the animation. This component uses a ref to access the underlying DOM node. The Effect reads the DOM node from the ref and automatically starts the animation for that node when the component appears.</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { FadeInAnimation } from \"./animation.js\";\n\nfunction Welcome() {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst animation = new FadeInAnimation(ref.current);\nanimation.start(1000);\nreturn () =&gt; {\nanimation.stop();\n};\n}, []);\n\nreturn (\n&lt;h1\nref={ref}\nstyle={{\nopacity: 0,\ncolor: \"white\",\npadding: 50,\ntextAlign: \"center\",\nfontSize: 50,\nbackgroundImage:\n\"radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)\",\n}}\n&gt;\nWelcome\n&lt;/h1&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Remove\" : \"Show\"}\n&lt;/button&gt;\n&lt;hr /&gt;\n{show &amp;&amp; &lt;Welcome /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export class FadeInAnimation {\nconstructor(node) {\nthis.node = node;\n}\nstart(duration) {\nthis.duration = duration;\nif (this.duration === 0) {\n// Jump to end immediately\nthis.onProgress(1);\n} else {\nthis.onProgress(0);\n// Start animating\nthis.startTime = performance.now();\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonFrame() {\nconst timePassed = performance.now() - this.startTime;\nconst progress = Math.min(timePassed / this.duration, 1);\nthis.onProgress(progress);\nif (progress &lt; 1) {\n// We still have more frames to paint\nthis.frameId = requestAnimationFrame(() =&gt; this.onFrame());\n}\n}\nonProgress(progress) {\nthis.node.style.opacity = progress;\n}\nstop() {\ncancelAnimationFrame(this.frameId);\nthis.startTime = null;\nthis.frameId = null;\nthis.duration = 0;\n}\n}\n</code></pre> <pre><code>label,\nbutton {\ndisplay: block;\nmargin-bottom: 20px;\n}\nhtml,\nbody {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-effect/#controlling-a-modal-dialog","title":"Controlling a modal dialog","text":"<p>In this example, the external system is the browser DOM. The <code>ModalDialog</code> component renders a <code>&lt;dialog&gt;</code> element. It uses an Effect to synchronize the <code>isOpen</code> prop to the <code>showModal()</code> and <code>close()</code> method calls.</p> <pre><code>import { useState } from \"react\";\nimport ModalDialog from \"./ModalDialog.js\";\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(true)}&gt;Open dialog&lt;/button&gt;\n&lt;ModalDialog isOpen={show}&gt;\nHello there!\n&lt;br /&gt;\n&lt;button\nonClick={() =&gt; {\nsetShow(false);\n}}\n&gt;\nClose\n&lt;/button&gt;\n&lt;/ModalDialog&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect, useRef } from \"react\";\n\nexport default function ModalDialog({ isOpen, children }) {\nconst ref = useRef();\n\nuseEffect(() =&gt; {\nif (!isOpen) {\nreturn;\n}\nconst dialog = ref.current;\ndialog.showModal();\nreturn () =&gt; {\ndialog.close();\n};\n}, [isOpen]);\n\nreturn &lt;dialog ref={ref}&gt;{children}&lt;/dialog&gt;;\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-effect/#tracking-element-visibility","title":"Tracking element visibility","text":"<p>In this example, the external system is again the browser DOM. The <code>App</code> component displays a long list, then a <code>Box</code> component, and then another long list. Scroll the list down. Notice that when the <code>Box</code> component appears in the viewport, the background color changes to black. To implement this, the <code>Box</code> component uses an Effect to manage an <code>IntersectionObserver</code>. This browser API notifies you when the DOM element is visible in the viewport.</p> <pre><code>import Box from \"./Box.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;/&gt;\n);\n}\n\nfunction LongSection() {\nconst items = [];\nfor (let i = 0; i &lt; 50; i++) {\nitems.push(&lt;li key={i}&gt;Item #{i} (keep scrolling)&lt;/li&gt;);\n}\nreturn &lt;ul&gt;{items}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>import { useRef, useEffect } from \"react\";\n\nexport default function Box() {\nconst ref = useRef(null);\n\nuseEffect(() =&gt; {\nconst div = ref.current;\nconst observer = new IntersectionObserver((entries) =&gt; {\nconst entry = entries[0];\nif (entry.isIntersecting) {\ndocument.body.style.backgroundColor = \"black\";\ndocument.body.style.color = \"white\";\n} else {\ndocument.body.style.backgroundColor = \"white\";\ndocument.body.style.color = \"black\";\n}\n});\nobserver.observe(div, {\nthreshold: 1.0,\n});\nreturn () =&gt; {\nobserver.disconnect();\n};\n}, []);\n\nreturn (\n&lt;div\nref={ref}\nstyle={{\nmargin: 20,\nheight: 100,\nwidth: 100,\nborder: \"2px solid black\",\nbackgroundColor: \"blue\",\n}}\n/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"reference/use-effect/#wrapping-effects-in-custom-hooks","title":"Wrapping Effects in custom Hooks","text":"<p>Effects are an \"escape hatch\": you use them when you need to \"step outside React\" and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it's usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.</p> <p>For example, this <code>useChatRoom</code> custom Hook \"hides\" the logic of your Effect behind a more declarative API:</p> <pre><code>function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId, serverUrl]);\n}\n</code></pre> <p>Then you can use it from any component like this:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl\n});\n// ...\n</code></pre> <p>There are also many excellent custom Hooks for every purpose available in the React ecosystem.</p> <p>Learn more about wrapping Effects in custom Hooks.</p> <p>"},{"location":"reference/use-effect/#custom-usechatroom-hook","title":"Custom <code>useChatRoom</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.</p> <pre><code>import { useState } from \"react\";\nimport { useChatRoom } from \"./useChatRoom.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl,\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nexport function useChatRoom({ serverUrl, roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [roomId, serverUrl]);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre>"},{"location":"reference/use-effect/#custom-usewindowlistener-hook","title":"Custom <code>useWindowListener</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.</p> <pre><code>import { useState } from \"react\";\nimport { useWindowListener } from \"./useWindowListener.js\";\n\nexport default function App() {\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseWindowListener(\"pointermove\", (e) =&gt; {\nsetPosition({ x: e.clientX, y: e.clientY });\n});\n\nreturn (\n&lt;div\nstyle={{\nposition: \"absolute\",\nbackgroundColor: \"pink\",\nborderRadius: \"50%\",\nopacity: 0.6,\ntransform: `translate(${position.x}px, ${position.y}px)`,\npointerEvents: \"none\",\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useWindowListener(eventType, listener) {\nuseEffect(() =&gt; {\nwindow.addEventListener(eventType, listener);\nreturn () =&gt; {\nwindow.removeEventListener(eventType, listener);\n};\n}, [eventType, listener]);\n}\n</code></pre> <pre><code>body {\nmin-height: 300px;\n}\n</code></pre>"},{"location":"reference/use-effect/#custom-useintersectionobserver-hook","title":"Custom <code>useIntersectionObserver</code> Hook","text":"<p>This example is identical to one of the earlier examples, but the logic is partially extracted to a custom Hook.</p> <pre><code>import Box from \"./Box.js\";\n\nexport default function App() {\nreturn (\n&lt;&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;Box /&gt;\n&lt;LongSection /&gt;\n&lt;/&gt;\n);\n}\n\nfunction LongSection() {\nconst items = [];\nfor (let i = 0; i &lt; 50; i++) {\nitems.push(&lt;li key={i}&gt;Item #{i} (keep scrolling)&lt;/li&gt;);\n}\nreturn &lt;ul&gt;{items}&lt;/ul&gt;;\n}\n</code></pre> <pre><code>import { useRef, useEffect } from \"react\";\nimport { useIntersectionObserver } from \"./useIntersectionObserver.js\";\n\nexport default function Box() {\nconst ref = useRef(null);\nconst isIntersecting = useIntersectionObserver(ref);\n\nuseEffect(() =&gt; {\nif (isIntersecting) {\ndocument.body.style.backgroundColor = \"black\";\ndocument.body.style.color = \"white\";\n} else {\ndocument.body.style.backgroundColor = \"white\";\ndocument.body.style.color = \"black\";\n}\n}, [isIntersecting]);\n\nreturn (\n&lt;div\nref={ref}\nstyle={{\nmargin: 20,\nheight: 100,\nwidth: 100,\nborder: \"2px solid black\",\nbackgroundColor: \"blue\",\n}}\n/&gt;\n);\n}\n</code></pre> <pre><code>import { useState, useEffect } from \"react\";\n\nexport function useIntersectionObserver(ref) {\nconst [isIntersecting, setIsIntersecting] = useState(false);\n\nuseEffect(() =&gt; {\nconst div = ref.current;\nconst observer = new IntersectionObserver((entries) =&gt; {\nconst entry = entries[0];\nsetIsIntersecting(entry.isIntersecting);\n});\nobserver.observe(div, {\nthreshold: 1.0,\n});\nreturn () =&gt; {\nobserver.disconnect();\n};\n}, [ref]);\n\nreturn isIntersecting;\n}\n</code></pre> <p></p>"},{"location":"reference/use-effect/#controlling-a-non-react-widget","title":"Controlling a non-React widget","text":"<p>Sometimes, you want to keep an external system synchronized to some prop or state of your component.</p> <p>For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a <code>MapWidget</code> class defined in <code>map-widget.js</code>. When you change the <code>zoomLevel</code> prop of the <code>Map</code> component, the Effect calls the <code>setZoom()</code> on the class instance to keep it synchronized:</p> <p>```json package.json hidden {     \"dependencies\": {         \"leaflet\": \"1.9.1\",         \"react\": \"latest\",         \"react-dom\": \"latest\",         \"react-scripts\": \"latest\",         \"remarkable\": \"2.0.1\"     },     \"scripts\": {         \"start\": \"react-scripts start\",         \"build\": \"react-scripts build\",         \"test\": \"react-scripts test --env=jsdom\",         \"eject\": \"react-scripts eject\"     } } <pre><code>```js\nimport { useState } from \"react\";\nimport Map from \"./Map.js\";\n\nexport default function App() {\n    const [zoomLevel, setZoomLevel] = useState(0);\n    return (\n        &lt;&gt;\n            Zoom level: {zoomLevel}x\n            &lt;button onClick={() =&gt; setZoomLevel(zoomLevel + 1)}&gt;+&lt;/button&gt;\n            &lt;button onClick={() =&gt; setZoomLevel(zoomLevel - 1)}&gt;-&lt;/button&gt;\n            &lt;hr /&gt;\n            &lt;Map zoomLevel={zoomLevel} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></p> <pre><code>import { useRef, useEffect } from \"react\";\nimport { MapWidget } from \"./map-widget.js\";\n\nexport default function Map({ zoomLevel }) {\nconst containerRef = useRef(null);\nconst mapRef = useRef(null);\n\nuseEffect(() =&gt; {\nif (mapRef.current === null) {\nmapRef.current = new MapWidget(containerRef.current);\n}\n\nconst map = mapRef.current;\nmap.setZoom(zoomLevel);\n}, [zoomLevel]);\n\nreturn &lt;div style={{ width: 200, height: 200 }} ref={containerRef} /&gt;;\n}\n</code></pre> <pre><code>import \"leaflet/dist/leaflet.css\";\nimport * as L from \"leaflet\";\n\nexport class MapWidget {\nconstructor(domNode) {\nthis.map = L.map(domNode, {\nzoomControl: false,\ndoubleClickZoom: false,\nboxZoom: false,\nkeyboard: false,\nscrollWheelZoom: false,\nzoomAnimation: false,\ntouchZoom: false,\nzoomSnap: 0.1,\n});\nL.tileLayer(\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\", {\nmaxZoom: 19,\nattribution: \"\u00a9 OpenStreetMap\",\n}).addTo(this.map);\nthis.map.setView([0, 0], 0);\n}\nsetZoom(level) {\nthis.map.setZoom(level);\n}\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\n</code></pre> <p>In this example, a cleanup function is not needed because the <code>MapWidget</code> class manages only the DOM node that was passed to it. After the <code>Map</code> React component is removed from the tree, both the DOM node and the <code>MapWidget</code> class instance will be automatically garbage-collected by the browser JavaScript engine.</p>"},{"location":"reference/use-effect/#fetching-data-with-effects","title":"Fetching data with Effects","text":"<p>You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework's data fetching mechanism will be a lot more efficient than writing Effects manually.</p> <p>If you want to fetch data from an Effect manually, your code might look like this:</p> <pre><code>import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\nconst [person, setPerson] = useState('Alice');\nconst [bio, setBio] = useState(null);\n\nuseEffect(() =&gt; {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then(result =&gt; {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\n// ...\n</code></pre> <p>Note the <code>ignore</code> variable which is initialized to <code>false</code>, and is set to <code>true</code> during cleanup. This ensures your code doesn't suffer from \"race conditions\": network responses may arrive in a different order than you sent them.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\nuseEffect(() =&gt; {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then((result) =&gt; {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>You can also rewrite using the <code>async</code> / <code>await</code> syntax, but you still need to provide a cleanup function:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { fetchBio } from \"./api.js\";\n\nexport default function Page() {\nconst [person, setPerson] = useState(\"Alice\");\nconst [bio, setBio] = useState(null);\nuseEffect(() =&gt; {\nasync function startFetching() {\nsetBio(null);\nconst result = await fetchBio(person);\nif (!ignore) {\nsetBio(result);\n}\n}\n\nlet ignore = false;\nstartFetching();\nreturn () =&gt; {\nignore = true;\n};\n}, [person]);\n\nreturn (\n&lt;&gt;\n&lt;select\nvalue={person}\nonChange={(e) =&gt; {\nsetPerson(e.target.value);\n}}\n&gt;\n&lt;option value=\"Alice\"&gt;Alice&lt;/option&gt;\n&lt;option value=\"Bob\"&gt;Bob&lt;/option&gt;\n&lt;option value=\"Taylor\"&gt;Taylor&lt;/option&gt;\n&lt;/select&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n&lt;i&gt;{bio ?? \"Loading...\"}&lt;/i&gt;\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export async function fetchBio(person) {\nconst delay = person === \"Bob\" ? 2000 : 200;\nreturn new Promise((resolve) =&gt; {\nsetTimeout(() =&gt; {\nresolve(\"This is \" + person + \"\u2019s bio.\");\n}, delay);\n});\n}\n</code></pre> <p>Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It's easier to use a custom Hook--either your own or maintained by the community.</p> <p>"},{"location":"reference/use-effect/#what-are-good-alternatives-to-data-fetching-in-effects","title":"What are good alternatives to data fetching in Effects?","text":"<p>Writing <code>fetch</code> calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:</p> <ul> <li>Effects don't run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.</li> <li>Fetching directly in Effects makes it easy to create \"network waterfalls\". You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.</li> <li>Fetching directly in Effects usually means you don't preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.</li> <li>It's not very ergonomic. There's quite a bit of boilerplate code involved when writing <code>fetch</code> calls in a way that doesn't suffer from bugs like race conditions.</li> </ul> <p>This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:</p> <ul> <li>If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.</li> <li>Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).</li> </ul> <p>You can continue fetching data directly in Effects if neither of these approaches suit you.</p> <p></p>"},{"location":"reference/use-effect/#specifying-reactive-dependencies","title":"Specifying reactive dependencies","text":"<p>Notice that you can't \"choose\" the dependencies of your Effect. Every reactive value used by your Effect's code must be declared as a dependency. Your Effect's dependency list is determined by the surrounding code:</p> <pre><code>function ChatRoom({ roomId }) {\n// This is a reactive value\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); // This is a reactive value too\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [serverUrl, roomId]); // \u2705 So you must specify them as dependencies of your Effect\n// ...\n}\n</code></pre> <p>If either <code>serverUrl</code> or <code>roomId</code> change, your Effect will reconnect to the chat using the new values.</p> <p>Reactive values include props and all variables and functions declared directly inside of your component. Since <code>roomId</code> and <code>serverUrl</code> are reactive values, you can't remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \ud83d\udd34 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n// ...\n}\n</code></pre> <p>To remove a dependency, you need to \"prove\" to the linter that it doesn't need to be a dependency. For example, you can move <code>serverUrl</code> out of your component to prove that it's not reactive and won't change on re-renders:</p> <pre><code>const serverUrl = \"https://localhost:1234\"; // Not a reactive value anymore\n\nfunction ChatRoom({ roomId }) {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Now that <code>serverUrl</code> is not a reactive value (and can't change on a re-render), it doesn't need to be a dependency. If your Effect's code doesn't use any reactive values, its dependency list should be empty (<code>[]</code>):</p> <pre><code>const serverUrl = \"https://localhost:1234\"; // Not a reactive value anymore\nconst roomId = \"music\"; // Not a reactive value anymore\n\nfunction ChatRoom() {\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>An Effect with empty dependencies doesn't re-run when any of your component's props or state change.</p> <p> <p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p> <pre><code>useEffect(() =&gt; {\n// ...\n// \ud83d\udd34 Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}, []);\n</code></pre> <p>When dependencies don't match the code, there is a high risk of introducing bugs. By suppressing the linter, you \"lie\" to React about the values your Effect depends on. Instead, prove they're unnecessary.</p> <p></p> <p>"},{"location":"reference/use-effect/#passing-a-dependency-array","title":"Passing a dependency array","text":"<p>If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}, [a, b]); // Runs again if a or b are different\n</code></pre> <p>In the below example, <code>serverUrl</code> and <code>roomId</code> are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since <code>message</code> isn't used in the Effect (and so it isn't a dependency), editing the message doesn't re-connect to the chat.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;{show ? \"Close chat\" : \"Open chat\"}&lt;/button&gt;\n&lt;/label&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\nmargin-bottom: 10px;\n}\nbutton {\nmargin-left: 5px;\n}\n</code></pre>"},{"location":"reference/use-effect/#passing-an-empty-dependency-array","title":"Passing an empty dependency array","text":"<p>If your Effect truly doesn't use any reactive values, it will only run after the initial render.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}, []); // Does not run again (except once in development)\n</code></pre> <p>Even with empty dependencies, setup and cleanup will run one extra time in development to help you find bugs.</p> <p>In this example, both <code>serverUrl</code> and <code>roomId</code> are hardcoded. Since they're declared outside the component, they are not reactive values, and so they aren't dependencies. The dependency list is empty, so the Effect doesn't re-run on re-renders.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\nconst roomId = \"music\";\n\nfunction ChatRoom() {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, []);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;\n{show ? \"Close chat\" : \"Open chat\"}\n&lt;/button&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre>"},{"location":"reference/use-effect/#passing-no-dependency-array-at-all","title":"Passing no dependency array at all","text":"<p>If you pass no dependency array at all, your Effect runs after every single render (and re-render) of your component.</p> <pre><code>useEffect(() =&gt; {\n// ...\n}); // Always runs again\n</code></pre> <p>In this example, the Effect re-runs when you change <code>serverUrl</code> and <code>roomId</code>, which is sensible. However, it also re-runs when you change the <code>message</code>, which is probably undesirable. This is why usually you'll specify the dependency array.</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState(\"https://localhost:1234\");\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}); // No dependency array at all\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nServer URL:{\" \"}\n&lt;input\nvalue={serverUrl}\nonChange={(e) =&gt; setServerUrl(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;label&gt;\nYour message:{\" \"}\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/label&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [show, setShow] = useState(false);\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;button onClick={() =&gt; setShow(!show)}&gt;{show ? \"Close chat\" : \"Open chat\"}&lt;/button&gt;\n&lt;/label&gt;\n{show &amp;&amp; &lt;hr /&gt;}\n{show &amp;&amp; &lt;ChatRoom roomId={roomId} /&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection(serverUrl, roomId) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\nmargin-bottom: 10px;\n}\nbutton {\nmargin-left: 5px;\n}\n</code></pre> <p></p>"},{"location":"reference/use-effect/#updating-state-based-on-previous-state-from-an-effect","title":"Updating state based on previous state from an Effect","text":"<p>When you want to update state based on previous state from an Effect, you might run into a problem:</p> <pre><code>function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconst intervalId = setInterval(() =&gt; {\nsetCount(count + 1); // You want to increment the counter every second...\n}, 1000);\nreturn () =&gt; clearInterval(intervalId);\n}, [count]); // \ud83d\udea9 ... but specifying `count` as a dependency always resets the interval.\n// ...\n}\n</code></pre> <p>Since <code>count</code> is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the <code>count</code> changes. This is not ideal.</p> <p>To fix this, pass the <code>c =&gt; c + 1</code> state updater to <code>setCount</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nuseEffect(() =&gt; {\nconst intervalId = setInterval(() =&gt; {\nsetCount((c) =&gt; c + 1); // \u2705 Pass a state updater\n}, 1000);\nreturn () =&gt; clearInterval(intervalId);\n}, []); // \u2705 Now count is not a dependency\n\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 20px;\nmargin-bottom: 20px;\n}\n\nbody {\nmin-height: 150px;\n}\n</code></pre> <p>Now that you're passing <code>c =&gt; c + 1</code> instead of <code>count + 1</code>, your Effect no longer needs to depend on <code>count</code>. As a result of this fix, it won't need to cleanup and setup the interval again every time the <code>count</code> changes.</p>"},{"location":"reference/use-effect/#removing-unnecessary-object-dependencies","title":"Removing unnecessary object dependencies","text":"<p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code>options</code> object is different for every render:</p> <pre><code>const serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nconst options = { // \ud83d\udea9 This object is created from scratch on every re-render\nserverUrl: serverUrl,\nroomId: roomId\n};\n\nuseEffect(() =&gt; {\nconst connection = createConnection(options); // It's used inside the Effect\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [options]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\n</code></pre> <p>Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId,\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Now that you create the <code>options</code> object inside the Effect, the Effect itself only depends on the <code>roomId</code> string.</p> <p>With this fix, typing into the input doesn't reconnect the chat. Unlike an object which gets re-created, a string like <code>roomId</code> doesn't change unless you set it to another value. Read more about removing dependencies.</p>"},{"location":"reference/use-effect/#removing-unnecessary-function-dependencies","title":"Removing unnecessary function dependencies","text":"<p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code>createOptions</code> function is different for every render:</p> <pre><code>function ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\n\nfunction createOptions() { // \ud83d\udea9 This function is created from scratch on every re-render\nreturn {\nserverUrl: serverUrl,\nroomId: roomId\n};\n}\n\nuseEffect(() =&gt; {\nconst options = createOptions(); // It's used inside the Effect\nconst connection = createConnection();\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [createOptions]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\n</code></pre> <p>By itself, creating a function from scratch on every re-render is not a problem. You don't need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.</p> <p>Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { createConnection } from \"./chat.js\";\n\nconst serverUrl = \"https://localhost:1234\";\n\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState(\"\");\n\nuseEffect(() =&gt; {\nfunction createOptions() {\nreturn {\nserverUrl: serverUrl,\nroomId: roomId,\n};\n}\n\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () =&gt; connection.disconnect();\n}, [roomId]);\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;\n&lt;input\nvalue={message}\nonChange={(e) =&gt; setMessage(e.target.value)}\n/&gt;\n&lt;/&gt;\n);\n}\n\nexport default function App() {\nconst [roomId, setRoomId] = useState(\"general\");\nreturn (\n&lt;&gt;\n&lt;label&gt;\nChoose the chat room:{\" \"}\n&lt;select\nvalue={roomId}\nonChange={(e) =&gt; setRoomId(e.target.value)}\n&gt;\n&lt;option value=\"general\"&gt;general&lt;/option&gt;\n&lt;option value=\"travel\"&gt;travel&lt;/option&gt;\n&lt;option value=\"music\"&gt;music&lt;/option&gt;\n&lt;/select&gt;\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;ChatRoom roomId={roomId} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>export function createConnection({ serverUrl, roomId }) {\n// A real implementation would actually connect to the server\nreturn {\nconnect() {\nconsole.log(\n'\u2705 Connecting to \"' + roomId + '\" room at ' + serverUrl + \"...\"\n);\n},\ndisconnect() {\nconsole.log(\n'\u274c Disconnected from \"' + roomId + '\" room at ' + serverUrl\n);\n},\n};\n}\n</code></pre> <pre><code>input {\ndisplay: block;\nmargin-bottom: 20px;\n}\nbutton {\nmargin-left: 10px;\n}\n</code></pre> <p>Now that you define the <code>createOptions</code> function inside the Effect, the Effect itself only depends on the <code>roomId</code> string. With this fix, typing into the input doesn't reconnect the chat. Unlike a function which gets re-created, a string like <code>roomId</code> doesn't change unless you set it to another value. Read more about removing dependencies.</p>"},{"location":"reference/use-effect/#reading-the-latest-props-and-state-from-an-effect","title":"Reading the latest props and state from an Effect","text":"<p> <p>This section describes an experimental API that has not yet been released in a stable version of React.</p> <p></p> <p>By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect \"reacts\" to every change of that value. For most dependencies, that's the behavior you want.</p> <p>However, sometimes you'll want to read the latest props and state from an Effect without \"reacting\" to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:</p> <pre><code>function Page({ url, shoppingCart }) {\nuseEffect(() =&gt; {\nlogVisit(url, shoppingCart.length);\n}, [url, shoppingCart]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>What if you want to log a new page visit after every <code>url</code> change, but not if only the <code>shoppingCart</code> changes? You can't exclude <code>shoppingCart</code> from dependencies without breaking the reactivity rules. However, you can express that you don't want a piece of code to \"react\" to changes even though it is called from inside an Effect. Declare an Effect Event with the <code>useEffectEvent</code> Hook, and move the code reading <code>shoppingCart</code> inside of it:</p> <pre><code>function Page({ url, shoppingCart }) {\nconst onVisit = useEffectEvent((visitedUrl) =&gt; {\nlogVisit(visitedUrl, shoppingCart.length);\n});\n\nuseEffect(() =&gt; {\nonVisit(url);\n}, [url]); // \u2705 All dependencies declared\n// ...\n}\n</code></pre> <p>Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading <code>shoppingCart</code> inside of <code>onVisit</code>, you ensure that <code>shoppingCart</code> won't re-run your Effect.</p> <p>Read more about how Effect Events let you separate reactive and non-reactive code.</p>"},{"location":"reference/use-effect/#displaying-different-content-on-the-server-and-the-client","title":"Displaying different content on the server and the client","text":"<p>If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.</p> <p>In rare cases, you might need to display different content on the client. For example, if your app reads some data from <code>localStorage</code>, it can't possibly do that on the server. Here is how you could implement this:</p> <pre><code>function MyComponent() {\nconst [didMount, setDidMount] = useState(false);\n\nuseEffect(() =&gt; {\nsetDidMount(true);\n}, []);\n\nif (didMount) {\n// ... return client-only JSX ...\n} else {\n// ... return initial JSX ...\n}\n}\n</code></pre> <p>While the app is loading, the user will see the initial render output. Then, when it's loaded and hydrated, your Effect will run and set <code>didMount</code> to <code>true</code>, triggering a re-render. This will switch to the client-only render output. Effects don't run on the server, so this is why <code>didMount</code> was <code>false</code> during the initial server render.</p> <p>Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time--potentially, many seconds--so you don't want to make jarring changes to your component's appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.</p>"},{"location":"reference/use-effect/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-effect/#my-effect-runs-twice-when-the-component-mounts","title":"My Effect runs twice when the component mounts","text":"<p>When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.</p> <p>This is a stress-test that verifies your Effect\u2019s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn\u2019t be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development).</p> <p>Read more about how this helps find bugs and how to fix your logic.</p>"},{"location":"reference/use-effect/#my-effect-runs-after-every-re-render","title":"My Effect runs after every re-render","text":"<p>First, check that you haven't forgotten to specify the dependency array:</p> <pre><code>useEffect(() =&gt; {\n// ...\n}); // \ud83d\udea9 No dependency array: re-runs after every render!\n</code></pre> <p>If you've specified the dependency array but your Effect still re-runs in a loop, it's because one of your dependencies is different on every re-render.</p> <p>You can debug this problem by manually logging your dependencies to the console:</p> <pre><code>useEffect(() =&gt; {\n// ..\n}, [serverUrl, roomId]);\n\nconsole.log([serverUrl, roomId]);\n</code></pre> <p>You can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as <code>temp1</code> and the second one got saved as <code>temp2</code>, you can then use the browser console to check whether each dependency in both arrays is the same:</p> <pre><code>Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n</code></pre> <p>When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:</p> <ul> <li>Updating state based on previous state from an Effect</li> <li>Removing unnecessary object dependencies</li> <li>Removing unnecessary function dependencies</li> <li>Reading the latest props and state from an Effect</li> </ul> <p>As a last resort (if these methods didn't help), wrap its creation with <code>useMemo</code> or <code>useCallback</code> (for functions).</p>"},{"location":"reference/use-effect/#my-effect-keeps-re-running-in-an-infinite-cycle","title":"My Effect keeps re-running in an infinite cycle","text":"<p>If your Effect runs in an infinite cycle, these two things must be true:</p> <ul> <li>Your Effect is updating some state.</li> <li>That state leads to a re-render, which causes the Effect's dependencies to change.</li> </ul> <p>Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application's data flow with it?</p> <p>If there is no external system, consider whether removing the Effect altogether would simplify your logic.</p> <p>If you're genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component's visual output? If you need to keep track of some data that isn't used by rendering, a ref (which doesn't trigger re-renders) might be more appropriate. Verify your Effect doesn't update the state (and trigger re-renders) more than needed.</p> <p>Finally, if your Effect is updating the state at the right time, but there is still a loop, it's because that state update leads to one of the Effect's dependencies changing. Read how to debug dependency changes.</p>"},{"location":"reference/use-effect/#my-cleanup-logic-runs-even-though-my-component-didnt-unmount","title":"My cleanup logic runs even though my component didn't unmount","text":"<p>The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.</p> <p>If you have cleanup code without corresponding setup code, it's usually a code smell:</p> <pre><code>useEffect(() =&gt; {\n// \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic\nreturn () =&gt; {\ndoSomething();\n};\n}, []);\n</code></pre> <p>Your cleanup logic should be \"symmetrical\" to the setup logic, and should stop or undo whatever setup did:</p> <pre><code>useEffect(() =&gt; {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () =&gt; {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n</code></pre> <p>Learn how the Effect lifecycle is different from the component's lifecycle.</p>"},{"location":"reference/use-effect/#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs","title":"My Effect does something visual, and I see a flicker before it runs","text":"<p>If your Effect must block the browser from painting the screen, replace <code>useEffect</code> with <code>useLayoutEffect</code>. Note that this shouldn't be needed for the vast majority of Effects. You'll only need this if it's crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.</p>"},{"location":"reference/use-id/","title":"Use id","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p> <p>See this issue for more details.</p>"},{"location":"reference/use-imperative-handle/","title":"Use imperative handle","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"},{"location":"reference/use-insertion-effect/","title":"Use insertion effect","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"},{"location":"reference/use-layout-effect/","title":"Use layout effect","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"},{"location":"reference/use-memo/","title":"Use Memo \ud83d\udea7","text":""},{"location":"reference/use-memo/#overview","title":"Overview","text":"<p> <code>useMemo</code> is a React Hook that lets you cache the result of a calculation between re-renders.  <pre><code>const cachedValue = useMemo(calculateValue, dependencies);\n</code></pre> </p>"},{"location":"reference/use-memo/#reference","title":"Reference","text":""},{"location":"reference/use-memo/#usememocalculatevalue-dependencies","title":"<code>useMemo(calculateValue, dependencies)</code>","text":"<p>Call <code>useMemo</code> at the top level of your component to cache a calculation between re-renders:</p> <pre><code>import { useMemo } from \"react\";\n\nfunction TodoList({ todos, tab }) {\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\n// ...\n}\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-memo/#parameters","title":"Parameters","text":"<ul> <li> <p><code>calculateValue</code>: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the <code>dependencies</code> have not changed since the last render. Otherwise, it will call <code>calculateValue</code>, return its result, and store it so it can be reused later.</p> </li> <li> <p><code>dependencies</code>: The list of all reactive values referenced inside of the <code>calculateValue</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code>[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <code>Object.is</code> comparison.</p> </li> </ul>"},{"location":"reference/use-memo/#returns","title":"Returns","text":"<p>On the initial render, <code>useMemo</code> returns the result of calling <code>calculateValue</code> with no arguments.</p> <p>During next renders, it will either return an already stored value from the last render (if the dependencies haven't changed), or call <code>calculateValue</code> again, and return the result that <code>calculateValue</code> has returned.</p>"},{"location":"reference/use-memo/#caveats","title":"Caveats","text":"<ul> <li><code>useMemo</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</li> <li>In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.</li> <li>React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache--for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on <code>useMemo</code> solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.</li> </ul> <p> <p>Caching return values like this is also known as memoization, which is why this Hook is called <code>useMemo</code>.</p> <p></p>"},{"location":"reference/use-memo/#usage","title":"Usage","text":""},{"location":"reference/use-memo/#skipping-expensive-recalculations","title":"Skipping expensive recalculations","text":"<p>To cache a calculation between re-renders, wrap it in a <code>useMemo</code> call at the top level of your component:</p> <pre><code>import { useMemo } from \"react\";\n\nfunction TodoList({ todos, tab, theme }) {\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\n// ...\n}\n</code></pre> <p>You need to pass two things to <code>useMemo</code>:</p> <ol> <li>A calculation function that takes no arguments, like <code>() =&gt;</code>, and returns what you wanted to calculate.</li> <li>A list of dependencies including every value within your component that's used inside your calculation.</li> </ol> <p>On the initial render, the value you'll get from <code>useMemo</code> will be the result of calling your calculation.</p> <p>On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with <code>Object.is</code>), <code>useMemo</code> will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.</p> <p>In other words, <code>useMemo</code> caches a calculation result between re-renders until its dependencies change.</p> <p>Let's walk through an example to see when this is useful.</p> <p>By default, React will re-run the entire body of your component every time that it re-renders. For example, if this <code>TodoList</code> updates its state or receives new props from its parent, the <code>filterTodos</code> function will re-run:</p> <pre><code>function TodoList({ todos, tab, theme }) {\nconst visibleTodos = filterTodos(todos, tab);\n// ...\n}\n</code></pre> <p>Usually, this isn't a problem because most calculations are very fast. However, if you're filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn't changed. If both <code>todos</code> and <code>tab</code> are the same as they were during the last render, wrapping the calculation in <code>useMemo</code> like earlier lets you reuse <code>visibleTodos</code> you've already calculated before.</p> <p>This type of caching is called memoization.</p> <p> <p>You should only rely on <code>useMemo</code> as a performance optimization. If your code doesn't work without it, find the underlying problem and fix it first. Then you may add <code>useMemo</code> to improve performance.</p> <p></p> <p>"},{"location":"reference/use-memo/#how-to-tell-if-a-calculation-is-expensive","title":"How to tell if a calculation is expensive?","text":"<p>In general, unless you're creating or looping over thousands of objects, it's probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:</p> <pre><code>console.time(\"filter array\");\nconst visibleTodos = filterTodos(todos, tab);\nconsole.timeEnd(\"filter array\");\n</code></pre> <p>Perform the interaction you're measuring (for example, typing into the input). You will then see logs like <code>filter array: 0.15ms</code> in your console. If the overall logged time adds up to a significant amount (say, <code>1ms</code> or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in <code>useMemo</code> to verify whether the total logged time has decreased for that interaction or not:</p> <pre><code>console.time(\"filter array\");\nconst visibleTodos = useMemo(() =&gt; {\nreturn filterTodos(todos, tab); // Skipped if todos and tab haven't changed\n}, [todos, tab]);\nconsole.timeEnd(\"filter array\");\n</code></pre> <p><code>useMemo</code> won't make the first render faster. It only helps you skip unnecessary work on updates.</p> <p>Keep in mind that your machine is probably faster than your users' so it's a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.</p> <p>Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.</p> <p></p> <p>"},{"location":"reference/use-memo/#should-you-add-usememo-everywhere","title":"Should you add useMemo everywhere?","text":"<p>If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.</p> <p>Optimizing with <code>useMemo</code> is only valuable in a few cases:</p> <ul> <li>The calculation you're putting in <code>useMemo</code> is noticeably slow, and its dependencies rarely change.</li> <li>You pass it as a prop to a component wrapped in <code>memo</code>. You want to skip re-rendering if the value hasn't changed. Memoization lets your component re-render only when dependencies aren't the same.</li> <li>The value you're passing is later used as a dependency of some Hook. For example, maybe another <code>useMemo</code> calculation value depends on it. Or maybe you are depending on this value from <code>useEffect.</code></li> </ul> <p>There is no benefit to wrapping a calculation in <code>useMemo</code> in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that's \"always new\" is enough to break memoization for an entire component.</p> <p>In practice, you can make a lot of memoization unnecessary by following a few principles:</p> <ol> <li>When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children don't need to re-render.</li> <li>Prefer local state and don't lift state up any further than necessary. For example, don't keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.</li> <li>Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it's a bug in your component! Fix the bug instead of adding memoization.</li> <li>Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.</li> <li>Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it's often simpler to move some object or a function inside an Effect or outside the component.</li> </ol> <p>If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it's good to follow them in any case. In the long term, we're researching doing granular memoization automatically to solve this once and for all.</p> <p></p> <p>"},{"location":"reference/use-memo/#skipping-recalculation-with-usememo","title":"Skipping recalculation with <code>useMemo</code>","text":"<p>In this example, the <code>filterTodos</code> implementation is artificially slowed down so that you can see what happens when some JavaScript function you're calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.</p> <p>Switching the tabs feels slow because it forces the slowed down <code>filterTodos</code> to re-execute. That's expected because the <code>tab</code> has changed, and so the entire calculation needs to re-run. (If you're curious why it runs twice, it's explained here.)</p> <p>Toggle the theme. Thanks to <code>useMemo</code>, it's fast despite the artificial slowdown! The slow <code>filterTodos</code> call was skipped because both <code>todos</code> and <code>tab</code> (which you pass as dependencies to <code>useMemo</code>) haven't changed since the last render.</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useMemo } from \"react\";\nimport { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\nreturn (\n&lt;div className={theme}&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;filterTodos&lt;/code&gt; is artificially slowed down!\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nconsole.log(\n\"[ARTIFICIALLY SLOW] Filtering \" +\ntodos.length +\n' todos for \"' +\ntab +\n'\" tab.'\n);\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre>"},{"location":"reference/use-memo/#always-recalculating-a-value","title":"Always recalculating a value","text":"<p>In this example, the <code>filterTodos</code> implementation is also artificially slowed down so that you can see what happens when some JavaScript function you're calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.</p> <p>Unlike in the previous example, toggling the theme is also slow now! This is because there is no <code>useMemo</code> call in this version, so the artificially slowed down <code>filterTodos</code> gets called on every re-render. It is called even if only <code>theme</code> has changed.</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n&lt;div className={theme}&gt;\n&lt;ul&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;filterTodos&lt;/code&gt; is artificially slowed\ndown!\n&lt;/b&gt;\n&lt;/p&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nconsole.log(\n\"[ARTIFICIALLY SLOW] Filtering \" +\ntodos.length +\n' todos for \"' +\ntab +\n'\" tab.'\n);\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>However, here is the same code with the artificial slowdown removed. Does the lack of <code>useMemo</code> feel noticeable or not?</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n&lt;div className={theme}&gt;\n&lt;ul&gt;\n{visibleTodos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n{todo.completed ? &lt;s&gt;{todo.text}&lt;/s&gt; : todo.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nconsole.log(\"Filtering \" + todos.length + ' todos for \"' + tab + '\" tab.');\n\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>Quite often, code without memoization works fine. If your interactions are fast enough, you might not need memoization.</p> <p>You can try increasing the number of todo items in <code>utils.js</code> and see how the behavior changes. This particular calculation wasn't very expensive to begin with, but if the number of todos grows significantly, most of the overhead will be in re-rendering rather than in the filtering. Keep reading below to see how you can optimize re-rendering with <code>useMemo</code>.</p> <p></p>"},{"location":"reference/use-memo/#skipping-re-rendering-of-components","title":"Skipping re-rendering of components","text":"<p>In some cases, <code>useMemo</code> can also help you optimize performance of re-rendering child components. To illustrate this, let's say this <code>TodoList</code> component passes the <code>visibleTodos</code> as a prop to the child <code>List</code> component:</p> <pre><code>export default function TodoList({ todos, tab, theme }) {\n// ...\nreturn (\n&lt;div className={theme}&gt;\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>You've noticed that toggling the <code>theme</code> prop freezes the app for a moment, but if you remove <code>&lt;List /&gt;</code> from your JSX, it feels fast. This tells you that it's worth trying to optimize the <code>List</code> component.</p> <p>By default, when a component re-renders, React re-renders all of its children recursively. This is why, when <code>TodoList</code> re-renders with a different <code>theme</code>, the <code>List</code> component also re-renders. This is fine for components that don't require much calculation to re-render. But if you've verified that a re-render is slow, you can tell <code>List</code> to skip re-rendering when its props are the same as on last render by wrapping it in <code>memo</code>:</p> <pre><code>import { memo } from \"react\";\n\nconst List = memo(function List({ items }) {\n// ...\n});\n</code></pre> <p>With this change, <code>List</code> will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated <code>visibleTodos</code> without <code>useMemo</code>:</p> <pre><code>export default function TodoList({ todos, tab, theme }) {\n// Every time the theme changes, this will be a different array...\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n&lt;div className={theme}&gt;\n{/* ... so List's props will never be the same, and it will re-render every time */}\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>In the above example, the <code>filterTodos</code> function always creates a different array, similar to how the <code>{}</code> object literal always creates a new object. Normally, this wouldn't be a problem, but it means that <code>List</code> props will never be the same, and your <code>memo</code> optimization won't work. This is where <code>useMemo</code> comes in handy:</p> <pre><code>export default function TodoList({ todos, tab, theme }) {\n// Tell React to cache your calculation between re-renders...\nconst visibleTodos = useMemo(\n() =&gt; filterTodos(todos, tab),\n[todos, tab] // ...so as long as these dependencies don't change...\n);\nreturn (\n&lt;div className={theme}&gt;\n{/* ...List will receive the same props and can skip re-rendering */}\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>By wrapping the <code>visibleTodos</code> calculation in <code>useMemo</code>, you ensure that it has the same value between the re-renders (until dependencies change). You don't have to wrap a calculation in <code>useMemo</code> unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in <code>memo</code>, and this lets it skip re-rendering. There are a few other reasons to add <code>useMemo</code> which are described further on this page.</p> <p>"},{"location":"reference/use-memo/#memoizing-individual-jsx-nodes","title":"Memoizing individual JSX nodes","text":"<p>Instead of wrapping <code>List</code> in <code>memo</code>, you could wrap the <code>&lt;List /&gt;</code> JSX node itself in <code>useMemo</code>:</p> <pre><code>export default function TodoList({ todos, tab, theme }) {\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\nconst children = useMemo(\n() =&gt; &lt;List items={visibleTodos} /&gt;,\n[visibleTodos]\n);\nreturn &lt;div className={theme}&gt;{children}&lt;/div&gt;;\n}\n</code></pre> <p>The behavior would be the same. If the <code>visibleTodos</code> haven't changed, <code>List</code> won't be re-rendered.</p> <p>A JSX node like <code>&lt;List items={visibleTodos} /&gt;</code> is an object like <code>{ type: List, props: { items: visibleTodos } }</code>. Creating this object is very cheap, but React doesn't know whether its contents is the same as last time or not. This is why by default, React will re-render the <code>List</code> component.</p> <p>However, if React sees the same exact JSX as during the previous render, it won't try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows it's safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what <code>useMemo</code> does in this example.</p> <p>Manually wrapping JSX nodes into <code>useMemo</code> is not convenient. For example, you can't do this conditionally. This is usually why you would wrap components with <code>memo</code> instead of wrapping JSX nodes.</p> <p></p> <p>"},{"location":"reference/use-memo/#skipping-re-rendering-with-usememo-and-memo","title":"Skipping re-rendering with <code>useMemo</code> and <code>memo</code>","text":"<p>In this example, the <code>List</code> component is artificially slowed down so that you can see what happens when a React component you're rendering is genuinely slow. Try switching the tabs and toggling the theme.</p> <p>Switching the tabs feels slow because it forces the slowed down <code>List</code> to re-render. That's expected because the <code>tab</code> has changed, and so you need to reflect the user's new choice on the screen.</p> <p>Next, try toggling the theme. Thanks to <code>useMemo</code> together with <code>memo</code>, it\u2019s fast despite the artificial slowdown! The <code>List</code> skipped re-rendering because the <code>visibleItems</code> array has not changed since the last render. The <code>visibleItems</code> array has not changed because both <code>todos</code> and <code>tab</code> (which you pass as dependencies to <code>useMemo</code>) haven't changed since the last render.</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useMemo } from \"react\";\nimport List from \"./List.js\";\nimport { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\nreturn (\n&lt;div className={theme}&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;List&lt;/code&gt; is artificially slowed down!\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { memo } from \"react\";\n\nconst List = memo(function List({ items }) {\nconsole.log(\n\"[ARTIFICIALLY SLOW] Rendering &lt;List /&gt; with \" + items.length + \" items\"\n);\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nreturn (\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n{item.completed ? &lt;s&gt;{item.text}&lt;/s&gt; : item.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n});\n\nexport default List;\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre>"},{"location":"reference/use-memo/#always-re-rendering-a-component","title":"Always re-rendering a component","text":"<p>In this example, the <code>List</code> implementation is also artificially slowed down so that you can see what happens when some React component you're rendering is genuinely slow. Try switching the tabs and toggling the theme.</p> <p>Unlike in the previous example, toggling the theme is also slow now! This is because there is no <code>useMemo</code> call in this version, so the <code>visibleTodos</code> is always a different array, and the slowed down <code>List</code> component can't skip re-rendering.</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import List from \"./List.js\";\nimport { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n&lt;div className={theme}&gt;\n&lt;p&gt;\n&lt;b&gt;\nNote: &lt;code&gt;List&lt;/code&gt; is artificially slowed down!\n&lt;/b&gt;\n&lt;/p&gt;\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { memo } from \"react\";\n\nconst List = memo(function List({ items }) {\nconsole.log(\n\"[ARTIFICIALLY SLOW] Rendering &lt;List /&gt; with \" + items.length + \" items\"\n);\nlet startTime = performance.now();\nwhile (performance.now() - startTime &lt; 500) {\n// Do nothing for 500 ms to emulate extremely slow code\n}\n\nreturn (\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n{item.completed ? &lt;s&gt;{item.text}&lt;/s&gt; : item.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n});\n\nexport default List;\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>However, here is the same code with the artificial slowdown removed. Does the lack of <code>useMemo</code> feel noticeable or not?</p> <pre><code>import { useState } from \"react\";\nimport { createTodos } from \"./utils.js\";\nimport TodoList from \"./TodoList.js\";\n\nconst todos = createTodos();\n\nexport default function App() {\nconst [tab, setTab] = useState(\"all\");\nconst [isDark, setIsDark] = useState(false);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setTab(\"all\")}&gt;All&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"active\")}&gt;Active&lt;/button&gt;\n&lt;button onClick={() =&gt; setTab(\"completed\")}&gt;Completed&lt;/button&gt;\n&lt;br /&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={isDark}\nonChange={(e) =&gt; setIsDark(e.target.checked)}\n/&gt;\nDark mode\n&lt;/label&gt;\n&lt;hr /&gt;\n&lt;TodoList\ntodos={todos}\ntab={tab}\ntheme={isDark ? \"dark\" : \"light\"}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import List from \"./List.js\";\nimport { filterTodos } from \"./utils.js\";\n\nexport default function TodoList({ todos, theme, tab }) {\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n&lt;div className={theme}&gt;\n&lt;List items={visibleTodos} /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <pre><code>import { memo } from \"react\";\n\nfunction List({ items }) {\nreturn (\n&lt;ul&gt;\n{items.map((item) =&gt; (\n&lt;li key={item.id}&gt;\n{item.completed ? &lt;s&gt;{item.text}&lt;/s&gt; : item.text}\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nexport default memo(List);\n</code></pre> <pre><code>export function createTodos() {\nconst todos = [];\nfor (let i = 0; i &lt; 50; i++) {\ntodos.push({\nid: i,\ntext: \"Todo \" + (i + 1),\ncompleted: Math.random() &gt; 0.5,\n});\n}\nreturn todos;\n}\n\nexport function filterTodos(todos, tab) {\nreturn todos.filter((todo) =&gt; {\nif (tab === \"all\") {\nreturn true;\n} else if (tab === \"active\") {\nreturn !todo.completed;\n} else if (tab === \"completed\") {\nreturn todo.completed;\n}\n});\n}\n</code></pre> <pre><code>label {\ndisplay: block;\nmargin-top: 10px;\n}\n\n.dark {\nbackground-color: black;\ncolor: white;\n}\n\n.light {\nbackground-color: white;\ncolor: black;\n}\n</code></pre> <p>Quite often, code without memoization works fine. If your interactions are fast enough, you don't need memoization.</p> <p>Keep in mind that you need to run React in production mode, disable React Developer Tools, and use devices similar to the ones your app's users have in order to get a realistic sense of what's actually slowing down your app.</p> <p></p>"},{"location":"reference/use-memo/#memoizing-a-dependency-of-another-hook","title":"Memoizing a dependency of another Hook","text":"<p>Suppose you have a calculation that depends on an object created directly in the component body:</p> <pre><code>function Dropdown({ allItems, text }) {\nconst searchOptions = { matchMode: 'whole-word', text };\n\nconst visibleItems = useMemo(() =&gt; {\nreturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // \ud83d\udea9 Caution: Dependency on an object created in the component body\n// ...\n</code></pre> <p>Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the <code>searchOptions</code> object will also run on every re-render. Since <code>searchOptions</code> is a dependency of your <code>useMemo</code> call, and it's different every time, React knows the dependencies are different, and recalculate <code>searchItems</code> every time.</p> <p>To fix this, you could memoize the <code>searchOptions</code> object itself before passing it as a dependency:</p> <pre><code>function Dropdown({ allItems, text }) {\nconst searchOptions = useMemo(() =&gt; {\nreturn { matchMode: 'whole-word', text };\n}, [text]); // \u2705 Only changes when text changes\n\nconst visibleItems = useMemo(() =&gt; {\nreturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // \u2705 Only changes when allItems or searchOptions changes\n// ...\n</code></pre> <p>In the example above, if the <code>text</code> did not change, the <code>searchOptions</code> object also won't change. However, an even better fix is to move the <code>searchOptions</code> object declaration inside of the <code>useMemo</code> calculation function:</p> <pre><code>function Dropdown({ allItems, text }) {\nconst visibleItems = useMemo(() =&gt; {\nconst searchOptions = { matchMode: 'whole-word', text };\nreturn searchItems(allItems, searchOptions);\n}, [allItems, text]); // \u2705 Only changes when allItems or text changes\n// ...\n</code></pre> <p>Now your calculation depends on <code>text</code> directly (which is a string and can't \"accidentally\" become different).</p>"},{"location":"reference/use-memo/#memoizing-a-function","title":"Memoizing a function","text":"<p>Suppose the <code>Form</code> component is wrapped in <code>memo</code>. You want to pass a function to it as a prop:</p> <pre><code>export default function ProductPage({ productId, referrer }) {\nfunction handleSubmit(orderDetails) {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n}\n\nreturn &lt;Form onSubmit={handleSubmit} /&gt;;\n}\n</code></pre> <p>Just as <code>{}</code> creates a different object, function declarations like <code>function() {}</code> and expressions like <code>() =&gt; {}</code> produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the <code>Form</code> component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization.</p> <p>To memoize a function with <code>useMemo</code>, your calculation function would have to return another function:</p> <pre><code>export default function Page({ productId, referrer }) {\nconst handleSubmit = useMemo(() =&gt; {\nreturn (orderDetails) =&gt; {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n};\n}, [productId, referrer]);\n\nreturn &lt;Form onSubmit={handleSubmit} /&gt;;\n}\n</code></pre> <p>This looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into <code>useCallback</code> instead of <code>useMemo</code> to avoid having to write an extra nested function:</p> <pre><code>export default function Page({ productId, referrer }) {\nconst handleSubmit = useCallback(\n(orderDetails) =&gt; {\npost(\"/product/\" + productId + \"/buy\", {\nreferrer,\norderDetails,\n});\n},\n[productId, referrer]\n);\n\nreturn &lt;Form onSubmit={handleSubmit} /&gt;;\n}\n</code></pre> <p>The two examples above are completely equivalent. The only benefit to <code>useCallback</code> is that it lets you avoid writing an extra nested function inside. It doesn't do anything else. Read more about <code>useCallback</code>.</p>"},{"location":"reference/use-memo/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-memo/#my-calculation-runs-twice-on-every-re-render","title":"My calculation runs twice on every re-render","text":"<p>In Strict Mode, React will call some of your functions twice instead of once:</p> <pre><code>function TodoList({ todos, tab }) {\n// This component function will run twice for every render.\n\nconst visibleTodos = useMemo(() =&gt; {\n// This calculation will run twice if any of the dependencies change.\nreturn filterTodos(todos, tab);\n}, [todos, tab]);\n\n// ...\n</code></pre> <p>This is expected and shouldn't break your code.</p> <p>This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.</p> <p>For example, this impure calculation function mutates an array you received as a prop:</p> <pre><code>const visibleTodos = useMemo(() =&gt; {\n// \ud83d\udea9 Mistake: mutating a prop\ntodos.push({ id: \"last\", text: \"Go for a walk!\" });\nconst filtered = filterTodos(todos, tab);\nreturn filtered;\n}, [todos, tab]);\n</code></pre> <p>React calls your function twice, so you'd notice the todo is added twice. Your calculation shouldn't change any existing objects, but it's okay to change any new objects you created during the calculation. For example, if the <code>filterTodos</code> function always returns a different array, you can mutate that array instead:</p> <pre><code>const visibleTodos = useMemo(() =&gt; {\nconst filtered = filterTodos(todos, tab);\n// \u2705 Correct: mutating an object you created during the calculation\nfiltered.push({ id: \"last\", text: \"Go for a walk!\" });\nreturn filtered;\n}, [todos, tab]);\n</code></pre> <p>Read keeping components pure to learn more about purity.</p> <p>Also, check out the guides on updating objects and updating arrays without mutation.</p>"},{"location":"reference/use-memo/#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined","title":"My <code>useMemo</code> call is supposed to return an object, but returns undefined","text":"<p>This code doesn't work:</p> <pre><code>  // \ud83d\udd34 You can't return an object from an arrow function with () =&gt; {\nconst searchOptions = useMemo(() =&gt; {\nmatchMode: 'whole-word',\ntext: text\n}, [text]);\n</code></pre> <p>In JavaScript, <code>() =&gt; {</code> starts the arrow function body, so the <code>{</code> brace is not a part of your object. This is why it doesn't return an object, and leads to mistakes. You could fix it by adding parentheses like <code>({</code> and <code>})</code>:</p> <pre><code>// This works, but is easy for someone to break again\nconst searchOptions = useMemo(\n() =&gt; ({\nmatchMode: \"whole-word\",\ntext: text,\n}),\n[text]\n);\n</code></pre> <p>However, this is still confusing and too easy for someone to break by removing the parentheses.</p> <p>To avoid this mistake, write a <code>return</code> statement explicitly:</p> <pre><code>// \u2705 This works and is explicit\nconst searchOptions = useMemo(() =&gt; {\nreturn {\nmatchMode: \"whole-word\",\ntext: text,\n};\n}, [text]);\n</code></pre>"},{"location":"reference/use-memo/#every-time-my-component-renders-the-calculation-in-usememo-re-runs","title":"Every time my component renders, the calculation in <code>useMemo</code> re-runs","text":"<p>Make sure you've specified the dependency array as a second argument!</p> <p>If you forget the dependency array, <code>useMemo</code> will re-run the calculation every time:</p> <pre><code>function TodoList({ todos, tab }) {\n// \ud83d\udd34 Recalculates every time: no dependency array\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab));\n// ...\n</code></pre> <p>This is the corrected version passing the dependency array as a second argument:</p> <pre><code>function TodoList({ todos, tab }) {\n// \u2705 Does not recalculate unnecessarily\nconst visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\n// ...\n</code></pre> <p>If this doesn't help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:</p> <pre><code>const visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);\nconsole.log([todos, tab]);\n</code></pre> <p>You can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as <code>temp1</code> and the second one got saved as <code>temp2</code>, you can then use the browser console to check whether each dependency in both arrays is the same:</p> <pre><code>Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n</code></pre> <p>When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well.</p>"},{"location":"reference/use-memo/#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed","title":"I need to call <code>useMemo</code> for each list item in a loop, but it's not allowed","text":"<p>Suppose the <code>Chart</code> component is wrapped in <code>memo</code>. You want to skip re-rendering every <code>Chart</code> in the list when the <code>ReportList</code> component re-renders. However, you can't call <code>useMemo</code> in a loop:</p> <pre><code>function ReportList({ items }) {\nreturn (\n&lt;article&gt;\n{items.map((item) =&gt; {\n// \ud83d\udd34 You can't call useMemo in a loop like this:\nconst data = useMemo(() =&gt; calculateReport(item), [item]);\nreturn (\n&lt;figure key={item.id}&gt;\n&lt;Chart data={data} /&gt;\n&lt;/figure&gt;\n);\n})}\n&lt;/article&gt;\n);\n}\n</code></pre> <p>Instead, extract a component for each item and memoize data for individual items:</p> <pre><code>function ReportList({ items }) {\nreturn (\n&lt;article&gt;\n{items.map((item) =&gt; (\n&lt;Report key={item.id} item={item} /&gt;\n))}\n&lt;/article&gt;\n);\n}\n\nfunction Report({ item }) {\n// \u2705 Call useMemo at the top level:\nconst data = useMemo(() =&gt; calculateReport(item), [item]);\nreturn (\n&lt;figure&gt;\n&lt;Chart data={data} /&gt;\n&lt;/figure&gt;\n);\n}\n</code></pre> <p>Alternatively, you could remove <code>useMemo</code> and instead wrap <code>Report</code> itself in <code>memo</code>. If the <code>item</code> prop does not change, <code>Report</code> will skip re-rendering, so <code>Chart</code> will skip re-rendering too:</p> <pre><code>function ReportList({ items }) {\n// ...\n}\n\nconst Report = memo(function Report({ item }) {\nconst data = calculateReport(item);\nreturn (\n&lt;figure&gt;\n&lt;Chart data={data} /&gt;\n&lt;/figure&gt;\n);\n});\n</code></pre>"},{"location":"reference/use-reducer/","title":"Use Reducer \ud83d\udea7","text":""},{"location":"reference/use-reducer/#overview","title":"Overview","text":"<p> <code>useReducer</code> is a React Hook that lets you add a reducer to your component.  <pre><code>const [state, dispatch] = useReducer(reducer, initialArg, init?)\n</code></pre> </p>"},{"location":"reference/use-reducer/#reference","title":"Reference","text":""},{"location":"reference/use-reducer/#usereducerreducer-initialarg-init","title":"<code>useReducer(reducer, initialArg, init?)</code>","text":"<p>Call <code>useReducer</code> at the top level of your component to manage its state with a reducer.</p> <pre><code>import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n// ...\n}\n\nfunction MyComponent() {\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n// ...\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-reducer/#parameters","title":"Parameters","text":"<ul> <li><code>reducer</code>: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.</li> <li><code>initialArg</code>: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next <code>init</code> argument.</li> <li>optional <code>init</code>: The initializer function that should return the initial state. If it's not specified, the initial state is set to <code>initialArg</code>. Otherwise, the initial state is set to the result of calling <code>init(initialArg)</code>.</li> </ul>"},{"location":"reference/use-reducer/#returns","title":"Returns","text":"<p><code>useReducer</code> returns an array with exactly two values:</p> <ol> <li>The current state. During the first render, it's set to <code>init(initialArg)</code> or <code>initialArg</code> (if there's no <code>init</code>).</li> <li>The <code>dispatch</code> function that lets you update the state to a different value and trigger a re-render.</li> </ol>"},{"location":"reference/use-reducer/#caveats","title":"Caveats","text":"<ul> <li><code>useReducer</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</li> <li>In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.</li> </ul>"},{"location":"reference/use-reducer/#dispatch-function","title":"<code>dispatch</code> function","text":"<p>The <code>dispatch</code> function returned by <code>useReducer</code> lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the <code>dispatch</code> function:</p> <pre><code>const [state, dispatch] = useReducer(reducer, { age: 42 });\n\nfunction handleClick() {\ndispatch({ type: 'incremented_age' });\n// ...\n</code></pre> <p>React will set the next state to the result of calling the <code>reducer</code> function you've provided with the current <code>state</code> and the action you've passed to <code>dispatch</code>.</p>"},{"location":"reference/use-reducer/#parameters_1","title":"Parameters","text":"<ul> <li><code>action</code>: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a <code>type</code> property identifying it and, optionally, other properties with additional information.</li> </ul>"},{"location":"reference/use-reducer/#returns_1","title":"Returns","text":"<p><code>dispatch</code> functions do not have a return value.</p>"},{"location":"reference/use-reducer/#caveats_1","title":"Caveats","text":"<ul> <li> <p>The <code>dispatch</code> function only updates the state variable for the next render. If you read the state variable after calling the <code>dispatch</code> function, you will still get the old value that was on the screen before your call.</p> </li> <li> <p>If the new value you provide is identical to the current <code>state</code>, as determined by an <code>Object.is</code> comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn't affect your code.</p> </li> <li> <p>React batches state updates. It updates the screen after all the event handlers have run and have called their <code>set</code> functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use <code>flushSync</code>.</p> </li> </ul>"},{"location":"reference/use-reducer/#usage","title":"Usage","text":""},{"location":"reference/use-reducer/#adding-a-reducer-to-a-component","title":"Adding a reducer to a component","text":"<p>Call <code>useReducer</code> at the top level of your component to manage state with a reducer.</p> <pre><code>import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n// ...\n}\n\nfunction MyComponent() {\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n// ...\n</code></pre> <p><code>useReducer</code> returns an array with exactly two items:</p> <ol> <li>The current state of this state variable, initially set to the initial state you provided.</li> <li>The <code>dispatch</code> function that lets you change it in response to interaction.</li> </ol> <p>To update what's on the screen, call <code>dispatch</code> with an object representing what the user did, called an action:</p> <pre><code>function handleClick() {\ndispatch({ type: \"incremented_age\" });\n}\n</code></pre> <p>React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.</p> <pre><code>import { useReducer } from \"react\";\n\nfunction reducer(state, action) {\nif (action.type === \"incremented_age\") {\nreturn {\nage: state.age + 1,\n};\n}\nthrow Error(\"Unknown action.\");\n}\n\nexport default function Counter() {\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\nreturn (\n&lt;&gt;\n&lt;button\nonClick={() =&gt; {\ndispatch({ type: \"incremented_age\" });\n}}\n&gt;\nIncrement age\n&lt;/button&gt;\n&lt;p&gt;Hello! You are {state.age}.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p><code>useReducer</code> is very similar to <code>useState</code>, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between <code>useState</code> and <code>useReducer</code>.</p>"},{"location":"reference/use-reducer/#writing-the-reducer-function","title":"Writing the reducer function","text":"<p>A reducer function is declared like this:</p> <pre><code>function reducer(state, action) {\n// ...\n}\n</code></pre> <p>Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a <code>switch</code> statement. For each <code>case</code> in the <code>switch</code>, calculate and return some next state.</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"incremented_age\": {\nreturn {\nname: state.name,\nage: state.age + 1,\n};\n}\ncase \"changed_name\": {\nreturn {\nname: action.nextName,\nage: state.age,\n};\n}\n}\nthrow Error(\"Unknown action: \" + action.type);\n}\n</code></pre> <p>Actions can have any shape. By convention, it's common to pass objects with a <code>type</code> property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.</p> <pre><code>function Form() {\nconst [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\n\nfunction handleButtonClick() {\ndispatch({ type: 'incremented_age' });\n}\n\nfunction handleInputChange(e) {\ndispatch({\ntype: 'changed_name',\nnextName: e.target.value\n});\n}\n// ...\n</code></pre> <p>The action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually it'll be an object or an array.</p> <p>Read extracting state logic into a reducer to learn more.</p> <p> <p>State is read-only. Don't modify any objects or arrays in state:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\n// \ud83d\udea9 Don't mutate an object in state like this:\nstate.age = state.age + 1;\nreturn state;\n}\n</code></pre> <p>Instead, always return new objects from your reducer:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\n// \u2705 Instead, return a new object\nreturn {\n...state,\nage: state.age + 1\n};\n}\n</code></pre> <p>Read updating objects in state and updating arrays in state to learn more.</p> <p></p> <p>"},{"location":"reference/use-reducer/#form-object","title":"Form (object)","text":"<p>In this example, the reducer manages a state object with two fields: <code>name</code> and <code>age</code>.</p> <pre><code>import { useReducer } from \"react\";\n\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"incremented_age\": {\nreturn {\nname: state.name,\nage: state.age + 1,\n};\n}\ncase \"changed_name\": {\nreturn {\nname: action.nextName,\nage: state.age,\n};\n}\n}\nthrow Error(\"Unknown action: \" + action.type);\n}\n\nconst initialState = { name: \"Taylor\", age: 42 };\n\nexport default function Form() {\nconst [state, dispatch] = useReducer(reducer, initialState);\n\nfunction handleButtonClick() {\ndispatch({ type: \"incremented_age\" });\n}\n\nfunction handleInputChange(e) {\ndispatch({\ntype: \"changed_name\",\nnextName: e.target.value,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={state.name} onChange={handleInputChange} /&gt;\n&lt;button onClick={handleButtonClick}&gt;Increment age&lt;/button&gt;\n&lt;p&gt;\nHello, {state.name}. You are {state.age}.\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre>"},{"location":"reference/use-reducer/#todo-list-array","title":"Todo list (array)","text":"<p>In this example, the reducer manages an array of tasks. The array needs to be updated without mutation.</p> <pre><code>import { useReducer } from \"react\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nfunction tasksReducer(tasks, action) {\nswitch (action.type) {\ncase \"added\": {\nreturn [\n...tasks,\n{\nid: action.id,\ntext: action.text,\ndone: false,\n},\n];\n}\ncase \"changed\": {\nreturn tasks.map((t) =&gt; {\nif (t.id === action.task.id) {\nreturn action.task;\n} else {\nreturn t;\n}\n});\n}\ncase \"deleted\": {\nreturn tasks.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\nonClick={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button onClick={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button onClick={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button onClick={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre>"},{"location":"reference/use-reducer/#writing-concise-update-logic-with-immer","title":"Writing concise update logic with Immer","text":"<p>If updating arrays and objects without mutation feels tedious, you can use a library like Immer to reduce repetitive code. Immer lets you write concise code as if you were mutating objects, but under the hood it performs immutable updates:</p> <pre><code>import { useImmerReducer } from \"use-immer\";\nimport AddTask from \"./AddTask.js\";\nimport TaskList from \"./TaskList.js\";\n\nfunction tasksReducer(draft, action) {\nswitch (action.type) {\ncase \"added\": {\ndraft.push({\nid: action.id,\ntext: action.text,\ndone: false,\n});\nbreak;\n}\ncase \"changed\": {\nconst index = draft.findIndex((t) =&gt; t.id === action.task.id);\ndraft[index] = action.task;\nbreak;\n}\ncase \"deleted\": {\nreturn draft.filter((t) =&gt; t.id !== action.id);\n}\ndefault: {\nthrow Error(\"Unknown action: \" + action.type);\n}\n}\n}\n\nexport default function TaskApp() {\nconst [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);\n\nfunction handleAddTask(text) {\ndispatch({\ntype: \"added\",\nid: nextId++,\ntext: text,\n});\n}\n\nfunction handleChangeTask(task) {\ndispatch({\ntype: \"changed\",\ntask: task,\n});\n}\n\nfunction handleDeleteTask(taskId) {\ndispatch({\ntype: \"deleted\",\nid: taskId,\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Prague itinerary&lt;/h1&gt;\n&lt;AddTask onAddTask={handleAddTask} /&gt;\n&lt;TaskList\ntasks={tasks}\nonChangeTask={handleChangeTask}\nonDeleteTask={handleDeleteTask}\n/&gt;\n&lt;/&gt;\n);\n}\n\nlet nextId = 3;\nconst initialTasks = [\n{ id: 0, text: \"Visit Kafka Museum\", done: true },\n{ id: 1, text: \"Watch a puppet show\", done: false },\n{ id: 2, text: \"Lennon Wall pic\", done: false },\n];\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTask({ onAddTask }) {\nconst [text, setText] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add task\"\nvalue={text}\nonChange={(e) =&gt; setText(e.target.value)}\n/&gt;\n&lt;button\nonClick={() =&gt; {\nsetText(\"\");\nonAddTask(text);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ tasks, onChangeTask, onDeleteTask }) {\nreturn (\n&lt;ul&gt;\n{tasks.map((task) =&gt; (\n&lt;li key={task.id}&gt;\n&lt;Task\ntask={task}\nonChange={onChangeTask}\nonDelete={onDeleteTask}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ task, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet taskContent;\nif (isEditing) {\ntaskContent = (\n&lt;&gt;\n&lt;input\nvalue={task.text}\nonChange={(e) =&gt; {\nonChange({\n...task,\ntext: e.target.value,\n});\n}}\n/&gt;\n&lt;button onClick={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntaskContent = (\n&lt;&gt;\n{task.text}\n&lt;button onClick={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={task.done}\nonChange={(e) =&gt; {\nonChange({\n...task,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{taskContent}\n&lt;button onClick={() =&gt; onDelete(task.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre> <p>```json package.json {     \"dependencies\": {         \"immer\": \"1.7.3\",         \"react\": \"latest\",         \"react-dom\": \"latest\",         \"react-scripts\": \"latest\",         \"use-immer\": \"0.5.1\"     },     \"scripts\": {         \"start\": \"react-scripts start\",         \"build\": \"react-scripts build\",         \"test\": \"react-scripts test --env=jsdom\",         \"eject\": \"react-scripts eject\"     } } <pre><code>&lt;/Recipes&gt;\n\n---\n\n### Avoiding recreating the initial state\n\nReact saves the initial state once and ignores it on the next renders.\n\n```js\nfunction createInitialState(username) {\n  // ...\n}\n\nfunction TodoList({ username }) {\n  const [state, dispatch] = useReducer(reducer, createInitialState(username));\n  // ...\n</code></pre></p> <p>Although the result of <code>createInitialState(username)</code> is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating large arrays or performing expensive calculations.</p> <p>To solve this, you may pass it as an initializer function to <code>useReducer</code> as the third argument instead:</p> <pre><code>function createInitialState(username) {\n// ...\n}\n\nfunction TodoList({ username }) {\nconst [state, dispatch] = useReducer(reducer, username, createInitialState);\n// ...\n</code></pre> <p>Notice that you\u2019re passing <code>createInitialState</code>, which is the function itself, and not <code>createInitialState()</code>, which is the result of calling it. This way, the initial state does not get re-created after initialization.</p> <p>In the above example, <code>createInitialState</code> takes a <code>username</code> argument. If your initializer doesn't need any information to compute the initial state, you may pass <code>null</code> as the second argument to <code>useReducer</code>.</p> <p>"},{"location":"reference/use-reducer/#passing-the-initializer-function","title":"Passing the initializer function","text":"<p>This example passes the initializer function, so the <code>createInitialState</code> function only runs during initialization. It does not run when component re-renders, such as when you type into the input.</p> <pre><code>import TodoList from \"./TodoList.js\";\n\nexport default function App() {\nreturn &lt;TodoList username=\"Taylor\" /&gt;;\n}\n</code></pre> <pre><code>import { useReducer } from \"react\";\n\nfunction createInitialState(username) {\nconst initialTodos = [];\nfor (let i = 0; i &lt; 50; i++) {\ninitialTodos.push({\nid: i,\ntext: username + \"'s task #\" + (i + 1),\n});\n}\nreturn {\ndraft: \"\",\ntodos: initialTodos,\n};\n}\n\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"changed_draft\": {\nreturn {\ndraft: action.nextDraft,\ntodos: state.todos,\n};\n}\ncase \"added_todo\": {\nreturn {\ndraft: \"\",\ntodos: [\n{\nid: state.todos.length,\ntext: state.draft,\n},\n...state.todos,\n],\n};\n}\n}\nthrow Error(\"Unknown action: \" + action.type);\n}\n\nexport default function TodoList({ username }) {\nconst [state, dispatch] = useReducer(reducer, username, createInitialState);\nreturn (\n&lt;&gt;\n&lt;input\nvalue={state.draft}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed_draft\",\nnextDraft: e.target.value,\n});\n}}\n/&gt;\n&lt;button\nonClick={() =&gt; {\ndispatch({ type: \"added_todo\" });\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{state.todos.map((item) =&gt; (\n&lt;li key={item.id}&gt;{item.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"reference/use-reducer/#passing-the-initial-state-directly","title":"Passing the initial state directly","text":"<p>This example does not pass the initializer function, so the <code>createInitialState</code> function runs on every render, such as when you type into the input. There is no observable difference in behavior, but this code is less efficient.</p> <pre><code>import TodoList from \"./TodoList.js\";\n\nexport default function App() {\nreturn &lt;TodoList username=\"Taylor\" /&gt;;\n}\n</code></pre> <pre><code>import { useReducer } from \"react\";\n\nfunction createInitialState(username) {\nconst initialTodos = [];\nfor (let i = 0; i &lt; 50; i++) {\ninitialTodos.push({\nid: i,\ntext: username + \"'s task #\" + (i + 1),\n});\n}\nreturn {\ndraft: \"\",\ntodos: initialTodos,\n};\n}\n\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"changed_draft\": {\nreturn {\ndraft: action.nextDraft,\ntodos: state.todos,\n};\n}\ncase \"added_todo\": {\nreturn {\ndraft: \"\",\ntodos: [\n{\nid: state.todos.length,\ntext: state.draft,\n},\n...state.todos,\n],\n};\n}\n}\nthrow Error(\"Unknown action: \" + action.type);\n}\n\nexport default function TodoList({ username }) {\nconst [state, dispatch] = useReducer(reducer, createInitialState(username));\nreturn (\n&lt;&gt;\n&lt;input\nvalue={state.draft}\nonChange={(e) =&gt; {\ndispatch({\ntype: \"changed_draft\",\nnextDraft: e.target.value,\n});\n}}\n/&gt;\n&lt;button\nonClick={() =&gt; {\ndispatch({ type: \"added_todo\" });\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{state.todos.map((item) =&gt; (\n&lt;li key={item.id}&gt;{item.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"reference/use-reducer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-reducer/#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value","title":"I've dispatched an action, but logging gives me the old state value","text":"<p>Calling the <code>dispatch</code> function does not change state in the running code:</p> <pre><code>function handleClick() {\nconsole.log(state.age); // 42\n\ndispatch({ type: \"incremented_age\" }); // Request a re-render with 43\nconsole.log(state.age); // Still 42!\n\nsetTimeout(() =&gt; {\nconsole.log(state.age); // Also 42!\n}, 5000);\n}\n</code></pre> <p>This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the <code>state</code> JavaScript variable in your already-running event handler.</p> <p>If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:</p> <pre><code>const action = { type: \"incremented_age\" };\ndispatch(action);\n\nconst nextState = reducer(state, action);\nconsole.log(state); // { age: 42 }\nconsole.log(nextState); // { age: 43 }\n</code></pre>"},{"location":"reference/use-reducer/#ive-dispatched-an-action-but-the-screen-doesnt-update","title":"I've dispatched an action, but the screen doesn't update","text":"<p>React will ignore your update if the next state is equal to the previous state, as determined by an <code>Object.is</code> comparison. This usually happens when you change an object or an array in state directly:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"incremented_age\": {\n// \ud83d\udea9 Wrong: mutating existing object\nstate.age++;\nreturn state;\n}\ncase \"changed_name\": {\n// \ud83d\udea9 Wrong: mutating existing object\nstate.name = action.nextName;\nreturn state;\n}\n// ...\n}\n}\n</code></pre> <p>You mutated an existing <code>state</code> object and returned it, so React ignored the update. To fix this, you need to ensure that you're always updating objects in state and updating arrays in state instead of mutating them:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"incremented_age\": {\n// \u2705 Correct: creating a new object\nreturn {\n...state,\nage: state.age + 1,\n};\n}\ncase \"changed_name\": {\n// \u2705 Correct: creating a new object\nreturn {\n...state,\nname: action.nextName,\n};\n}\n// ...\n}\n}\n</code></pre>"},{"location":"reference/use-reducer/#a-part-of-my-reducer-state-becomes-undefined-after-dispatching","title":"A part of my reducer state becomes undefined after dispatching","text":"<p>Make sure that every <code>case</code> branch copies all of the existing fields when returning the new state:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\nreturn {\n...state, // Don't forget this!\nage: state.age + 1\n};\n}\n// ...\n</code></pre> <p>Without <code>...state</code> above, the returned next state would only contain the <code>age</code> field and nothing else.</p>"},{"location":"reference/use-reducer/#my-entire-reducer-state-becomes-undefined-after-dispatching","title":"My entire reducer state becomes undefined after dispatching","text":"<p>If your state unexpectedly becomes <code>undefined</code>, you're likely forgetting to <code>return</code> state in one of the cases, or your action type doesn't match any of the <code>case</code> statements. To find why, throw an error outside the <code>switch</code>:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"incremented_age\": {\n// ...\n}\ncase \"edited_name\": {\n// ...\n}\n}\nthrow Error(\"Unknown action: \" + action.type);\n}\n</code></pre> <p>You can also use a static type checker like TypeScript to catch such mistakes.</p>"},{"location":"reference/use-reducer/#im-getting-an-error-too-many-re-renders","title":"I'm getting an error: \"Too many re-renders\"","text":"<p>You might get an error that says: <code>Too many re-renders. React limits the number of renders to prevent an infinite loop.</code> Typically, this means that you're unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:</p> <pre><code>// \ud83d\udea9 Wrong: calls the handler during render\nreturn &lt;button onClick={handleClick()}&gt;Click me&lt;/button&gt;;\n\n// \u2705 Correct: passes down the event handler\nreturn &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;\n\n// \u2705 Correct: passes down an inline function\nreturn &lt;button onClick={(e) =&gt; handleClick(e)}&gt;Click me&lt;/button&gt;;\n</code></pre> <p>If you can't find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific <code>dispatch</code> function call responsible for the error.</p>"},{"location":"reference/use-reducer/#my-reducer-or-initializer-function-runs-twice","title":"My reducer or initializer function runs twice","text":"<p>In Strict Mode, React will call your reducer and initializer functions twice. This shouldn't break your code.</p> <p>This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.</p> <p>For example, this impure reducer function mutates an array in state:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"added_todo\": {\n// \ud83d\udea9 Mistake: mutating state\nstate.todos.push({ id: nextId++, text: action.text });\nreturn state;\n}\n// ...\n}\n}\n</code></pre> <p>Because React calls your reducer function twice, you'll see the todo was added twice, so you'll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:</p> <pre><code>function reducer(state, action) {\nswitch (action.type) {\ncase \"added_todo\": {\n// \u2705 Correct: replacing with new state\nreturn {\n...state,\ntodos: [...state.todos, { id: nextId++, text: action.text }],\n};\n}\n// ...\n}\n}\n</code></pre> <p>Now that this reducer function is pure, calling it an extra time doesn't make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don't need to be pure, so React will never call your event handlers twice.</p> <p>Read keeping components pure to learn more.</p>"},{"location":"reference/use-ref/","title":"Use Ref \ud83d\udea7","text":""},{"location":"reference/use-ref/#overview","title":"Overview","text":"<p> <code>useRef</code> is a React Hook that lets you reference a value that's not needed for rendering.  <pre><code>const ref = useRef(initialValue);\n</code></pre> </p>"},{"location":"reference/use-ref/#reference","title":"Reference","text":""},{"location":"reference/use-ref/#userefinitialvalue","title":"<code>useRef(initialValue)</code>","text":"<p>Call <code>useRef</code> at the top level of your component to declare a ref.</p> <pre><code>import { useRef } from 'react';\n\nfunction MyComponent() {\nconst intervalRef = useRef(0);\nconst inputRef = useRef(null);\n// ...\n</code></pre> <p>See more examples below.</p>"},{"location":"reference/use-ref/#parameters","title":"Parameters","text":"<ul> <li><code>initialValue</code>: The value you want the ref object's <code>current</code> property to be initially. It can be a value of any type. This argument is ignored after the initial render.</li> </ul>"},{"location":"reference/use-ref/#returns","title":"Returns","text":"<p><code>useRef</code> returns an object with a single property:</p> <ul> <li><code>current</code>: Initially, it's set to the <code>initialValue</code> you have passed. You can later set it to something else. If you pass the ref object to React as a <code>ref</code> attribute to a JSX node, React will set its <code>current</code> property.</li> </ul> <p>On the next renders, <code>useRef</code> will return the same object.</p>"},{"location":"reference/use-ref/#caveats","title":"Caveats","text":"<ul> <li>You can mutate the <code>ref.current</code> property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn't mutate that object.</li> <li>When you change the <code>ref.current</code> property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.</li> <li>Do not write or read <code>ref.current</code> during rendering, except for initialization. This makes your component's behavior unpredictable.</li> <li>In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.</li> </ul>"},{"location":"reference/use-ref/#usage","title":"Usage","text":""},{"location":"reference/use-ref/#referencing-a-value-with-a-ref","title":"Referencing a value with a ref","text":"<p>Call <code>useRef</code> at the top level of your component to declare one or more refs.</p> <pre><code>import { useRef } from 'react';\n\nfunction Stopwatch() {\nconst intervalRef = useRef(0);\n// ...\n</code></pre> <p><code>useRef</code> returns a ref object with a single <code>current</code> property initially set to the initial value you provided.</p> <p>On the next renders, <code>useRef</code> will return the same object. You can change its <code>current</code> property to store information and read it later. This might remind you of state, but there is an important difference.</p> <p>Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesn't affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its <code>current</code> property:</p> <pre><code>function handleStartClick() {\nconst intervalId = setInterval(() =&gt; {\n// ...\n}, 1000);\nintervalRef.current = intervalId;\n}\n</code></pre> <p>Later, you can read that interval ID from the ref so that you can call clear that interval:</p> <pre><code>function handleStopClick() {\nconst intervalId = intervalRef.current;\nclearInterval(intervalId);\n}\n</code></pre> <p>By using a ref, you ensure that:</p> <ul> <li>You can store information between re-renders (unlike regular variables, which reset on every render).</li> <li>Changing it does not trigger a re-render (unlike state variables, which trigger a re-render).</li> <li>The information is local to each copy of your component (unlike the variables outside, which are shared).</li> </ul> <p>Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between <code>useRef</code> and <code>useState</code>.</p> <p>"},{"location":"reference/use-ref/#click-counter","title":"Click counter","text":"<p>This component uses a ref to keep track of how many times the button was clicked. Note that it's okay to use a ref instead of state here because the click count is only read and written in an event handler.</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Counter() {\nlet ref = useRef(0);\n\nfunction handleClick() {\nref.current = ref.current + 1;\nalert(\"You clicked \" + ref.current + \" times!\");\n}\n\nreturn &lt;button onClick={handleClick}&gt;Click me!&lt;/button&gt;;\n}\n</code></pre> <p>If you show <code>{ref.current}</code> in the JSX, the number won't update on click. This is because setting <code>ref.current</code> does not trigger a re-render. Information that's used for rendering should be state instead.</p>"},{"location":"reference/use-ref/#a-stopwatch","title":"A stopwatch","text":"<p>This example uses a combination of state and refs. Both <code>startTime</code> and <code>now</code> are state variables because they are used for rendering. But we also need to hold an interval ID so that we can stop the interval on button press. Since the interval ID is not used for rendering, it's appropriate to keep it in a ref, and manually update it.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function Stopwatch() {\nconst [startTime, setStartTime] = useState(null);\nconst [now, setNow] = useState(null);\nconst intervalRef = useRef(null);\n\nfunction handleStart() {\nsetStartTime(Date.now());\nsetNow(Date.now());\n\nclearInterval(intervalRef.current);\nintervalRef.current = setInterval(() =&gt; {\nsetNow(Date.now());\n}, 10);\n}\n\nfunction handleStop() {\nclearInterval(intervalRef.current);\n}\n\nlet secondsPassed = 0;\nif (startTime != null &amp;&amp; now != null) {\nsecondsPassed = (now - startTime) / 1000;\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Time passed: {secondsPassed.toFixed(3)}&lt;/h1&gt;\n&lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n&lt;button onClick={handleStop}&gt;Stop&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p></p> <p> <p>Do not write or read <code>ref.current</code> during rendering.</p> <p>React expects that the body of your component behaves like a pure function:</p> <ul> <li>If the inputs (props, state, and context) are the same, it should return exactly the same JSX.</li> <li>Calling it in a different order or with different arguments should not affect the results of other calls.</li> </ul> <p>Reading or writing a ref during rendering breaks these expectations.</p> <pre><code>function MyComponent() {\n// ...\n// \ud83d\udea9 Don't write a ref during rendering\nmyRef.current = 123;\n// ...\n// \ud83d\udea9 Don't read a ref during rendering\nreturn &lt;h1&gt;{myOtherRef.current}&lt;/h1&gt;;\n}\n</code></pre> <p>You can read or write refs from event handlers or effects instead.</p> <pre><code>function MyComponent() {\n// ...\nuseEffect(() =&gt; {\n// \u2705 You can read or write refs in effects\nmyRef.current = 123;\n});\n// ...\nfunction handleClick() {\n// \u2705 You can read or write refs in event handlers\ndoSomething(myOtherRef.current);\n}\n// ...\n}\n</code></pre> <p>If you have to read or write something during rendering, use state instead.</p> <p>When you break these rules, your component might still work, but most of the newer features we're adding to React will rely on these expectations. Read more about keeping your components pure.</p> <p></p>"},{"location":"reference/use-ref/#manipulating-the-dom-with-a-ref","title":"Manipulating the DOM with a ref","text":"<p>It's particularly common to use a ref to manipulate the DOM. React has built-in support for this.</p> <p>First, declare a ref object with an initial value of <code>null</code>:</p> <pre><code>import { useRef } from 'react';\n\nfunction MyComponent() {\nconst inputRef = useRef(null);\n// ...\n</code></pre> <p>Then pass your ref object as the <code>ref</code> attribute to the JSX of the DOM node you want to manipulate:</p> <pre><code>// ...\nreturn &lt;input ref={inputRef} /&gt;;\n</code></pre> <p>After React creates the DOM node and puts it on the screen, React will set the <code>current</code> property of your ref object to that DOM node. Now you can access the <code>&lt;input&gt;</code>'s DOM node and call methods like <code>focus()</code>:</p> <pre><code>function handleClick() {\ninputRef.current.focus();\n}\n</code></pre> <p>React will set the <code>current</code> property back to <code>null</code> when the node is removed from the screen.</p> <p>Read more about manipulating the DOM with refs.</p> <p>"},{"location":"reference/use-ref/#focusing-a-text-input","title":"Focusing a text input","text":"<p>In this example, clicking the button will focus the input:</p> <pre><code>import { useRef } from \"react\";\n\nexport default function Form() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;input ref={inputRef} /&gt;\n&lt;button onClick={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"reference/use-ref/#scrolling-an-image-into-view","title":"Scrolling an image into view","text":"<p>In this example, clicking the button will scroll an image into view. It uses a ref to the list DOM node, and then calls DOM <code>querySelectorAll</code> API to find the image we want to scroll to.</p> <pre><code>import { useRef } from \"react\";\n\nexport default function CatFriends() {\nconst listRef = useRef(null);\n\nfunction scrollToIndex(index) {\nconst listNode = listRef.current;\n// This line assumes a particular DOM structure:\nconst imgNode = listNode.querySelectorAll(\"li &gt; img\")[index];\nimgNode.scrollIntoView({\nbehavior: \"smooth\",\nblock: \"nearest\",\ninline: \"center\",\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;nav&gt;\n&lt;button onClick={() =&gt; scrollToIndex(0)}&gt;Tom&lt;/button&gt;\n&lt;button onClick={() =&gt; scrollToIndex(1)}&gt;Maru&lt;/button&gt;\n&lt;button onClick={() =&gt; scrollToIndex(2)}&gt;Jellylorum&lt;/button&gt;\n&lt;/nav&gt;\n&lt;div&gt;\n&lt;ul ref={listRef}&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/200/200\"\nalt=\"Tom\"\n/&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/300/200\"\nalt=\"Maru\"\n/&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;img\nsrc=\"https://placekitten.com/g/250/200\"\nalt=\"Jellylorum\"\n/&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>div {\nwidth: 100%;\noverflow: hidden;\n}\n\nnav {\ntext-align: center;\n}\n\nbutton {\nmargin: 0.25rem;\n}\n\nul,\nli {\nlist-style: none;\nwhite-space: nowrap;\n}\n\nli {\ndisplay: inline;\npadding: 0.5rem;\n}\n</code></pre>"},{"location":"reference/use-ref/#playing-and-pausing-a-video","title":"Playing and pausing a video","text":"<p>This example uses a ref to call <code>play()</code> and <code>pause()</code> on a <code>&lt;video&gt;</code> DOM node.</p> <pre><code>import { useState, useRef } from \"react\";\n\nexport default function VideoPlayer() {\nconst [isPlaying, setIsPlaying] = useState(false);\nconst ref = useRef(null);\n\nfunction handleClick() {\nconst nextIsPlaying = !isPlaying;\nsetIsPlaying(nextIsPlaying);\n\nif (nextIsPlaying) {\nref.current.play();\n} else {\nref.current.pause();\n}\n}\n\nreturn (\n&lt;&gt;\n&lt;button onClick={handleClick}&gt;\n{isPlaying ? \"Pause\" : \"Play\"}\n&lt;/button&gt;\n&lt;video\nwidth=\"250\"\nref={ref}\nonPlay={() =&gt; setIsPlaying(true)}\nonPause={() =&gt; setIsPlaying(false)}\n&gt;\n&lt;source\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\ntype=\"video/mp4\"\n/&gt;\n&lt;/video&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre>"},{"location":"reference/use-ref/#exposing-a-ref-to-your-own-component","title":"Exposing a ref to your own component","text":"<p>Sometimes, you may want to let the parent component manipulate the DOM inside of your component. For example, maybe you're writing a <code>MyInput</code> component, but you want the parent to be able to focus the input (which the parent has no access to). You can use a combination of <code>useRef</code> to hold the input and <code>forwardRef</code> to expose it to the parent component. Read a detailed walkthrough here.</p> <pre><code>import { forwardRef, useRef } from \"react\";\n\nconst MyInput = forwardRef((props, ref) =&gt; {\nreturn &lt;input {...props} ref={ref} /&gt;;\n});\n\nexport default function Form() {\nconst inputRef = useRef(null);\n\nfunction handleClick() {\ninputRef.current.focus();\n}\n\nreturn (\n&lt;&gt;\n&lt;MyInput ref={inputRef} /&gt;\n&lt;button onClick={handleClick}&gt;Focus the input&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"reference/use-ref/#avoiding-recreating-the-ref-contents","title":"Avoiding recreating the ref contents","text":"<p>React saves the initial ref value once and ignores it on the next renders.</p> <pre><code>function Video() {\nconst playerRef = useRef(new VideoPlayer());\n// ...\n</code></pre> <p>Although the result of <code>new VideoPlayer()</code> is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating expensive objects.</p> <p>To solve it, you may initialize the ref like this instead:</p> <pre><code>function Video() {\nconst playerRef = useRef(null);\nif (playerRef.current === null) {\nplayerRef.current = new VideoPlayer();\n}\n// ...\n</code></pre> <p>Normally, writing or reading <code>ref.current</code> during render is not allowed. However, it's fine in this case because the result is always the same, and the condition only executes during initialization so it's fully predictable.</p> <p>"},{"location":"reference/use-ref/#how-to-avoid-null-checks-when-initializing-useref-later","title":"How to avoid null checks when initializing useRef later","text":"<p>If you use a type checker and don't want to always check for <code>null</code>, you can try a pattern like this instead:</p> <pre><code>function Video() {\nconst playerRef = useRef(null);\n\nfunction getPlayer() {\nif (playerRef.current !== null) {\nreturn playerRef.current;\n}\nconst player = new VideoPlayer();\nplayerRef.current = player;\nreturn player;\n}\n\n// ...\n</code></pre> <p>Here, the <code>playerRef</code> itself is nullable. However, you should be able to convince your type checker that there is no case in which <code>getPlayer()</code> returns <code>null</code>. Then use <code>getPlayer()</code> in your event handlers.</p> <p></p>"},{"location":"reference/use-ref/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-ref/#i-cant-get-a-ref-to-a-custom-component","title":"I can't get a ref to a custom component","text":"<p>If you try to pass a <code>ref</code> to your own component like this:</p> <pre><code>const inputRef = useRef(null);\n\nreturn &lt;MyInput ref={inputRef} /&gt;;\n</code></pre> <p>You might get an error in the console:</p> <p> <p>Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p> <p></p> <p>By default, your own components don't expose refs to the DOM nodes inside them.</p> <p>To fix this, find the component that you want to get a ref to:</p> <pre><code>export default function MyInput({ value, onChange }) {\nreturn &lt;input value={value} onChange={onChange} /&gt;;\n}\n</code></pre> <p>And then wrap it in <code>forwardRef</code> like this:</p> <pre><code>import { forwardRef } from \"react\";\n\nconst MyInput = forwardRef(({ value, onChange }, ref) =&gt; {\nreturn &lt;input value={value} onChange={onChange} ref={ref} /&gt;;\n});\n\nexport default MyInput;\n</code></pre> <p>Then the parent component can get a ref to it.</p> <p>Read more about accessing another component's DOM nodes.</p>"},{"location":"reference/use-state/","title":"Use State \ud83d\udea7","text":""},{"location":"reference/use-state/#overview","title":"Overview","text":"<p> <code>useState</code> is a React Hook that lets you add a state variable to your component.  <pre><code>const [state, setState] = useState(initialState);\n</code></pre> </p>"},{"location":"reference/use-state/#reference","title":"Reference","text":""},{"location":"reference/use-state/#usestateinitialstate","title":"<code>useState(initialState)</code>","text":"<p>Call <code>useState</code> at the top level of your component to declare a state variable.</p> <pre><code>import { useState } from 'react';\n\nfunction MyComponent() {\nconst [age, setAge] = useState(28);\nconst [name, setName] = useState('Taylor');\nconst [todos, setTodos] = useState(() =&gt; createTodos());\n// ...\n</code></pre> <p>The convention is to name state variables like <code>[something, setSomething]</code> using array destructuring.</p> <p>See more examples below.</p>"},{"location":"reference/use-state/#parameters","title":"Parameters","text":"<ul> <li><code>initialState</code>: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.<ul> <li>If you pass a function as <code>initialState</code>, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below.</li> </ul> </li> </ul>"},{"location":"reference/use-state/#returns","title":"Returns","text":"<p><code>useState</code> returns an array with exactly two values:</p> <ol> <li>The current state. During the first render, it will match the <code>initialState</code> you have passed.</li> <li>The <code>set</code> function that lets you update the state to a different value and trigger a re-render.</li> </ol>"},{"location":"reference/use-state/#caveats","title":"Caveats","text":"<ul> <li><code>useState</code> is a Hook, so you can only call it at the top level of your component or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.</li> <li>In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.</li> </ul>"},{"location":"reference/use-state/#set-functions-like-setsomethingnextstate","title":"<code>set</code> functions, like <code>setSomething(nextState)</code>","text":"<p>The <code>set</code> function returned by <code>useState</code> lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:</p> <pre><code>const [name, setName] = useState('Edward');\n\nfunction handleClick() {\nsetName('Taylor');\nsetAge(a =&gt; a + 1);\n// ...\n</code></pre>"},{"location":"reference/use-state/#parameters_1","title":"Parameters","text":"<ul> <li><code>nextState</code>: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.<ul> <li>If you pass a function as <code>nextState</code>, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below.</li> </ul> </li> </ul>"},{"location":"reference/use-state/#returns_1","title":"Returns","text":"<p><code>set</code> functions do not have a return value.</p>"},{"location":"reference/use-state/#caveats_1","title":"Caveats","text":"<ul> <li> <p>The <code>set</code> function only updates the state variable for the next render. If you read the state variable after calling the <code>set</code> function, you will still get the old value that was on the screen before your call.</p> </li> <li> <p>If the new value you provide is identical to the current <code>state</code>, as determined by an <code>Object.is</code> comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn't affect your code.</p> </li> <li> <p>React batches state updates. It updates the screen after all the event handlers have run and have called their <code>set</code> functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use <code>flushSync</code>.</p> </li> <li> <p>Calling the <code>set</code> function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below.</p> </li> <li> <p>In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.</p> </li> </ul>"},{"location":"reference/use-state/#usage","title":"Usage","text":""},{"location":"reference/use-state/#adding-state-to-a-component","title":"Adding state to a component","text":"<p>Call <code>useState</code> at the top level of your component to declare one or more state variables.</p> <pre><code>import { useState } from 'react';\n\nfunction MyComponent() {\nconst [age, setAge] = useState(42);\nconst [name, setName] = useState('Taylor');\n// ...\n</code></pre> <p>The convention is to name state variables like <code>[something, setSomething]</code> using array destructuring.</p> <p><code>useState</code> returns an array with exactly two items:</p> <ol> <li>The current state of this state variable, initially set to the initial state you provided.</li> <li>The <code>set</code> function that lets you change it to any other value in response to interaction.</li> </ol> <p>To update what\u2019s on the screen, call the <code>set</code> function with some next state:</p> <pre><code>function handleClick() {\nsetName(\"Robin\");\n}\n</code></pre> <p>React will store the next state, render your component again with the new values, and update the UI.</p> <p> <p>Calling the <code>set</code> function does not change the current state in the already executing code:</p> <pre><code>function handleClick() {\nsetName(\"Robin\");\nconsole.log(name); // Still \"Taylor\"!\n}\n</code></pre> <p>It only affects what <code>useState</code> will return starting from the next render.</p> <p></p> <p>"},{"location":"reference/use-state/#counter-number","title":"Counter (number)","text":"<p>In this example, the <code>count</code> state variable holds a number. Clicking the button increments it.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [count, setCount] = useState(0);\n\nfunction handleClick() {\nsetCount(count + 1);\n}\n\nreturn &lt;button onClick={handleClick}&gt;You pressed me {count} times&lt;/button&gt;;\n}\n</code></pre>"},{"location":"reference/use-state/#text-field-string","title":"Text field (string)","text":"<p>In this example, the <code>text</code> state variable holds a string. When you type, <code>handleChange</code> reads the latest input value from the browser input DOM element, and calls <code>setText</code> to update the state. This allows you to display the current <code>text</code> below.</p> <pre><code>import { useState } from \"react\";\n\nexport default function MyInput() {\nconst [text, setText] = useState(\"hello\");\n\nfunction handleChange(e) {\nsetText(e.target.value);\n}\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={handleChange} /&gt;\n&lt;p&gt;You typed: {text}&lt;/p&gt;\n&lt;button onClick={() =&gt; setText(\"hello\")}&gt;Reset&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"reference/use-state/#checkbox-boolean","title":"Checkbox (boolean)","text":"<p>In this example, the <code>liked</code> state variable holds a boolean. When you click the input, <code>setLiked</code> updates the <code>liked</code> state variable with whether the browser checkbox input is checked. The <code>liked</code> variable is used to render the text below the checkbox.</p> <pre><code>import { useState } from \"react\";\n\nexport default function MyCheckbox() {\nconst [liked, setLiked] = useState(true);\n\nfunction handleChange(e) {\nsetLiked(e.target.checked);\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={liked}\nonChange={handleChange}\n/&gt;\nI liked this\n&lt;/label&gt;\n&lt;p&gt;You {liked ? \"liked\" : \"did not like\"} this.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"reference/use-state/#form-two-variables","title":"Form (two variables)","text":"<p>You can declare more than one state variable in the same component. Each state variable is completely independent.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [name, setName] = useState(\"Taylor\");\nconst [age, setAge] = useState(42);\n\nreturn (\n&lt;&gt;\n&lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;\n&lt;button onClick={() =&gt; setAge(age + 1)}&gt;Increment age&lt;/button&gt;\n&lt;p&gt;\nHello, {name}. You are {age}.\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-top: 10px;\n}\n</code></pre> <p></p>"},{"location":"reference/use-state/#updating-state-based-on-the-previous-state","title":"Updating state based on the previous state","text":"<p>Suppose the <code>age</code> is <code>42</code>. This handler calls <code>setAge(age + 1)</code> three times:</p> <pre><code>function handleClick() {\nsetAge(age + 1); // setAge(42 + 1)\nsetAge(age + 1); // setAge(42 + 1)\nsetAge(age + 1); // setAge(42 + 1)\n}\n</code></pre> <p>However, after one click, <code>age</code> will only be <code>43</code> rather than <code>45</code>! This is because calling the <code>set</code> function does not update the <code>age</code> state variable in the already running code. So each <code>setAge(age + 1)</code> call becomes <code>setAge(43)</code>.</p> <p>To solve this problem, you may pass an updater function to <code>setAge</code> instead of the next state:</p> <pre><code>function handleClick() {\nsetAge((a) =&gt; a + 1); // setAge(42 =&gt; 43)\nsetAge((a) =&gt; a + 1); // setAge(43 =&gt; 44)\nsetAge((a) =&gt; a + 1); // setAge(44 =&gt; 45)\n}\n</code></pre> <p>Here, <code>a =&gt; a + 1</code> is your updater function. It takes the pending state and calculates the next state from it.</p> <p>React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:</p> <ol> <li><code>a =&gt; a + 1</code> will receive <code>42</code> as the pending state and return <code>43</code> as the next state.</li> <li><code>a =&gt; a + 1</code> will receive <code>43</code> as the pending state and return <code>44</code> as the next state.</li> <li><code>a =&gt; a + 1</code> will receive <code>44</code> as the pending state and return <code>45</code> as the next state.</li> </ol> <p>There are no other queued updates, so React will store <code>45</code> as the current state in the end.</p> <p>By convention, it's common to name the pending state argument for the first letter of the state variable name, like <code>a</code> for <code>age</code>. However, you may also call it like <code>prevAge</code> or something else that you find clearer.</p> <p>React may call your updaters twice in development to verify that they are pure.</p> <p>"},{"location":"reference/use-state/#is-using-an-updater-always-preferred","title":"Is using an updater always preferred?","text":"<p>You might hear a recommendation to always write code like <code>setAge(a =&gt; a + 1)</code> if the state you're setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.</p> <p>In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the <code>age</code> state variable would be updated before the next click. This means there is no risk of a click handler seeing a \"stale\" <code>age</code> at the beginning of the event handler.</p> <p>However, if you do multiple updates within the same event, updaters can be helpful. They're also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).</p> <p>If you prefer consistency over slightly more verbose syntax, it's reasonable to always write an updater if the state you're setting is calculated from the previous state. If it's calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.</p> <p></p> <p>"},{"location":"reference/use-state/#passing-the-updater-function","title":"Passing the updater function","text":"<p>This example passes the updater function, so the \"+3\" button works.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [age, setAge] = useState(42);\n\nfunction increment() {\nsetAge((a) =&gt; a + 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Your age: {age}&lt;/h1&gt;\n&lt;button\nonClick={() =&gt; {\nincrement();\nincrement();\nincrement();\n}}\n&gt;\n+3\n&lt;/button&gt;\n&lt;button\nonClick={() =&gt; {\nincrement();\n}}\n&gt;\n+1\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: block;\nmargin: 10px;\n}\n</code></pre>"},{"location":"reference/use-state/#passing-the-next-state-directly","title":"Passing the next state directly","text":"<p>This example does not pass the updater function, so the \"+3\" button doesn't work as intended.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Counter() {\nconst [age, setAge] = useState(42);\n\nfunction increment() {\nsetAge(age + 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Your age: {age}&lt;/h1&gt;\n&lt;button\nonClick={() =&gt; {\nincrement();\nincrement();\nincrement();\n}}\n&gt;\n+3\n&lt;/button&gt;\n&lt;button\nonClick={() =&gt; {\nincrement();\n}}\n&gt;\n+1\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin: 10px;\nfont-size: 20px;\n}\nh1 {\ndisplay: block;\nmargin: 10px;\n}\n</code></pre> <p></p>"},{"location":"reference/use-state/#updating-objects-and-arrays-in-state","title":"Updating objects and arrays in state","text":"<p>You can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a <code>form</code> object in state, don't mutate it:</p> <pre><code>// \ud83d\udea9 Don't mutate an object in state like this:\nform.firstName = \"Taylor\";\n</code></pre> <p>Instead, replace the whole object by creating a new one:</p> <pre><code>// \u2705 Replace state with a new object\nsetForm({\n...form,\nfirstName: \"Taylor\",\n});\n</code></pre> <p>Read updating objects in state and updating arrays in state to learn more.</p> <p>"},{"location":"reference/use-state/#form-object","title":"Form (object)","text":"<p>In this example, the <code>form</code> state variable holds an object. Each input has a change handler that calls <code>setForm</code> with the next state of the entire form. The <code>{ ...form }</code> spread syntax ensures that the state object is replaced rather than mutated.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [form, setForm] = useState({\nfirstName: \"Barbara\",\nlastName: \"Hepworth\",\nemail: \"bhepworth@sculpture.com\",\n});\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nFirst name:\n&lt;input\nvalue={form.firstName}\nonChange={(e) =&gt; {\nsetForm({\n...form,\nfirstName: e.target.value,\n});\n}}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nLast name:\n&lt;input\nvalue={form.lastName}\nonChange={(e) =&gt; {\nsetForm({\n...form,\nlastName: e.target.value,\n});\n}}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nEmail:\n&lt;input\nvalue={form.email}\nonChange={(e) =&gt; {\nsetForm({\n...form,\nemail: e.target.value,\n});\n}}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\n{form.firstName} {form.lastName} ({form.email})\n&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\n}\n</code></pre>"},{"location":"reference/use-state/#form-nested-object","title":"Form (nested object)","text":"<p>In this example, the state is more nested. When you update nested state, you need to create a copy of the object you're updating, as well as any objects \"containing\" it on the way upwards. Read updating a nested object to learn more.</p> <pre><code>import { useState } from \"react\";\n\nexport default function Form() {\nconst [person, setPerson] = useState({\nname: \"Niki de Saint Phalle\",\nartwork: {\ntitle: \"Blue Nana\",\ncity: \"Hamburg\",\nimage: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n},\n});\n\nfunction handleNameChange(e) {\nsetPerson({\n...person,\nname: e.target.value,\n});\n}\n\nfunction handleTitleChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\ntitle: e.target.value,\n},\n});\n}\n\nfunction handleCityChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\ncity: e.target.value,\n},\n});\n}\n\nfunction handleImageChange(e) {\nsetPerson({\n...person,\nartwork: {\n...person.artwork,\nimage: e.target.value,\n},\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;label&gt;\nName:\n&lt;input value={person.name} onChange={handleNameChange} /&gt;\n&lt;/label&gt;\n&lt;label&gt;\nTitle:\n&lt;input\nvalue={person.artwork.title}\nonChange={handleTitleChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nCity:\n&lt;input\nvalue={person.artwork.city}\nonChange={handleCityChange}\n/&gt;\n&lt;/label&gt;\n&lt;label&gt;\nImage:\n&lt;input\nvalue={person.artwork.image}\nonChange={handleImageChange}\n/&gt;\n&lt;/label&gt;\n&lt;p&gt;\n&lt;i&gt;{person.artwork.title}&lt;/i&gt;\n{\" by \"}\n{person.name}\n&lt;br /&gt;\n(located in {person.artwork.city})\n&lt;/p&gt;\n&lt;img src={person.artwork.image} alt={person.artwork.title} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>label {\ndisplay: block;\n}\ninput {\nmargin-left: 5px;\nmargin-bottom: 5px;\n}\nimg {\nwidth: 200px;\nheight: 200px;\n}\n</code></pre>"},{"location":"reference/use-state/#list-array","title":"List (array)","text":"<p>In this example, the <code>todos</code> state variable holds an array. Each button handler calls <code>setTodos</code> with the next version of that array. The <code>[...todos]</code> spread syntax, <code>todos.map()</code> and <code>todos.filter()</code> ensure the state array is replaced rather than mutated.</p> <pre><code>import { useState } from \"react\";\nimport AddTodo from \"./AddTodo.js\";\nimport TaskList from \"./TaskList.js\";\n\nlet nextId = 3;\nconst initialTodos = [\n{ id: 0, title: \"Buy milk\", done: true },\n{ id: 1, title: \"Eat tacos\", done: false },\n{ id: 2, title: \"Brew tea\", done: false },\n];\n\nexport default function TaskApp() {\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAddTodo(title) {\nsetTodos([\n...todos,\n{\nid: nextId++,\ntitle: title,\ndone: false,\n},\n]);\n}\n\nfunction handleChangeTodo(nextTodo) {\nsetTodos(\ntodos.map((t) =&gt; {\nif (t.id === nextTodo.id) {\nreturn nextTodo;\n} else {\nreturn t;\n}\n})\n);\n}\n\nfunction handleDeleteTodo(todoId) {\nsetTodos(todos.filter((t) =&gt; t.id !== todoId));\n}\n\nreturn (\n&lt;&gt;\n&lt;AddTodo onAddTodo={handleAddTodo} /&gt;\n&lt;TaskList\ntodos={todos}\nonChangeTodo={handleChangeTodo}\nonDeleteTodo={handleDeleteTodo}\n/&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function AddTodo({ onAddTodo }) {\nconst [title, setTitle] = useState(\"\");\nreturn (\n&lt;&gt;\n&lt;input\nplaceholder=\"Add todo\"\nvalue={title}\nonChange={(e) =&gt; setTitle(e.target.value)}\n/&gt;\n&lt;button\nonClick={() =&gt; {\nsetTitle(\"\");\nonAddTodo(title);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function TaskList({ todos, onChangeTodo, onDeleteTodo }) {\nreturn (\n&lt;ul&gt;\n{todos.map((todo) =&gt; (\n&lt;li key={todo.id}&gt;\n&lt;Task\ntodo={todo}\nonChange={onChangeTodo}\nonDelete={onDeleteTodo}\n/&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n\nfunction Task({ todo, onChange, onDelete }) {\nconst [isEditing, setIsEditing] = useState(false);\nlet todoContent;\nif (isEditing) {\ntodoContent = (\n&lt;&gt;\n&lt;input\nvalue={todo.title}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ntitle: e.target.value,\n});\n}}\n/&gt;\n&lt;button onClick={() =&gt; setIsEditing(false)}&gt;Save&lt;/button&gt;\n&lt;/&gt;\n);\n} else {\ntodoContent = (\n&lt;&gt;\n{todo.title}\n&lt;button onClick={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;\n&lt;/&gt;\n);\n}\nreturn (\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={todo.done}\nonChange={(e) =&gt; {\nonChange({\n...todo,\ndone: e.target.checked,\n});\n}}\n/&gt;\n{todoContent}\n&lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;\n&lt;/label&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin: 5px;\n}\nli {\nlist-style-type: none;\n}\nul,\nli {\nmargin: 0;\npadding: 0;\n}\n</code></pre>"},{"location":"reference/use-state/#writing-concise-update-logic-with-immer","title":"Writing concise update logic with Immer","text":"<p>If updating arrays and objects without mutation feels tedious, you can use a library like Immer to reduce repetitive code. Immer lets you write concise code as if you were mutating objects, but under the hood it performs immutable updates:</p> <pre><code>import { useState } from \"react\";\nimport { useImmer } from \"use-immer\";\n\nlet nextId = 3;\nconst initialList = [\n{ id: 0, title: \"Big Bellies\", seen: false },\n{ id: 1, title: \"Lunar Landscape\", seen: false },\n{ id: 2, title: \"Terracotta Army\", seen: true },\n];\n\nexport default function BucketList() {\nconst [list, updateList] = useImmer(initialList);\n\nfunction handleToggle(artworkId, nextSeen) {\nupdateList((draft) =&gt; {\nconst artwork = draft.find((a) =&gt; a.id === artworkId);\nartwork.seen = nextSeen;\n});\n}\n\nreturn (\n&lt;&gt;\n&lt;h1&gt;Art Bucket List&lt;/h1&gt;\n&lt;h2&gt;My list of art to see:&lt;/h2&gt;\n&lt;ItemList artworks={list} onToggle={handleToggle} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction ItemList({ artworks, onToggle }) {\nreturn (\n&lt;ul&gt;\n{artworks.map((artwork) =&gt; (\n&lt;li key={artwork.id}&gt;\n&lt;label&gt;\n&lt;input\ntype=\"checkbox\"\nchecked={artwork.seen}\nonChange={(e) =&gt; {\nonToggle(artwork.id, e.target.checked);\n}}\n/&gt;\n{artwork.title}\n&lt;/label&gt;\n&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\n</code></pre> <p>```json package.json {     \"dependencies\": {         \"immer\": \"1.7.3\",         \"react\": \"latest\",         \"react-dom\": \"latest\",         \"react-scripts\": \"latest\",         \"use-immer\": \"0.5.1\"     },     \"scripts\": {         \"start\": \"react-scripts start\",         \"build\": \"react-scripts build\",         \"test\": \"react-scripts test --env=jsdom\",         \"eject\": \"react-scripts eject\"     } } <pre><code>&lt;/Recipes&gt;\n\n---\n\n### Avoiding recreating the initial state\n\nReact saves the initial state once and ignores it on the next renders.\n\n```js\nfunction TodoList() {\n  const [todos, setTodos] = useState(createInitialTodos());\n  // ...\n</code></pre></p> <p>Although the result of <code>createInitialTodos()</code> is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating large arrays or performing expensive calculations.</p> <p>To solve this, you may pass it as an initializer function to <code>useState</code> instead:</p> <pre><code>function TodoList() {\nconst [todos, setTodos] = useState(createInitialTodos);\n// ...\n</code></pre> <p>Notice that you\u2019re passing <code>createInitialTodos</code>, which is the function itself, and not <code>createInitialTodos()</code>, which is the result of calling it. If you pass a function to <code>useState</code>, React will only call it during initialization.</p> <p>React may call your initializers twice in development to verify that they are pure.</p> <p>"},{"location":"reference/use-state/#passing-the-initializer-function","title":"Passing the initializer function","text":"<p>This example passes the initializer function, so the <code>createInitialTodos</code> function only runs during initialization. It does not run when component re-renders, such as when you type into the input.</p> <pre><code>import { useState } from \"react\";\n\nfunction createInitialTodos() {\nconst initialTodos = [];\nfor (let i = 0; i &lt; 50; i++) {\ninitialTodos.push({\nid: i,\ntext: \"Item \" + (i + 1),\n});\n}\nreturn initialTodos;\n}\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(createInitialTodos);\nconst [text, setText] = useState(\"\");\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button\nonClick={() =&gt; {\nsetText(\"\");\nsetTodos([\n{\nid: todos.length,\ntext: text,\n},\n...todos,\n]);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{todos.map((item) =&gt; (\n&lt;li key={item.id}&gt;{item.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"reference/use-state/#passing-the-initial-state-directly","title":"Passing the initial state directly","text":"<p>This example does not pass the initializer function, so the <code>createInitialTodos</code> function runs on every render, such as when you type into the input. There is no observable difference in behavior, but this code is less efficient.</p> <pre><code>import { useState } from \"react\";\n\nfunction createInitialTodos() {\nconst initialTodos = [];\nfor (let i = 0; i &lt; 50; i++) {\ninitialTodos.push({\nid: i,\ntext: \"Item \" + (i + 1),\n});\n}\nreturn initialTodos;\n}\n\nexport default function TodoList() {\nconst [todos, setTodos] = useState(createInitialTodos());\nconst [text, setText] = useState(\"\");\n\nreturn (\n&lt;&gt;\n&lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n&lt;button\nonClick={() =&gt; {\nsetText(\"\");\nsetTodos([\n{\nid: todos.length,\ntext: text,\n},\n...todos,\n]);\n}}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;ul&gt;\n{todos.map((item) =&gt; (\n&lt;li key={item.id}&gt;{item.text}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <p></p>"},{"location":"reference/use-state/#resetting-state-with-a-key","title":"Resetting state with a key","text":"<p>You'll often encounter the <code>key</code> attribute when rendering lists. However, it also serves another purpose.</p> <p>You can reset a component's state by passing a different <code>key</code> to a component. In this example, the Reset button changes the <code>version</code> state variable, which we pass as a <code>key</code> to the <code>Form</code>. When the <code>key</code> changes, React re-creates the <code>Form</code> component (and all of its children) from scratch, so its state gets reset.</p> <p>Read preserving and resetting state to learn more.</p> <pre><code>import { useState } from \"react\";\n\nexport default function App() {\nconst [version, setVersion] = useState(0);\n\nfunction handleReset() {\nsetVersion(version + 1);\n}\n\nreturn (\n&lt;&gt;\n&lt;button onClick={handleReset}&gt;Reset&lt;/button&gt;\n&lt;Form key={version} /&gt;\n&lt;/&gt;\n);\n}\n\nfunction Form() {\nconst [name, setName] = useState(\"Taylor\");\n\nreturn (\n&lt;&gt;\n&lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;\n&lt;p&gt;Hello, {name}.&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\ndisplay: block;\nmargin-bottom: 20px;\n}\n</code></pre>"},{"location":"reference/use-state/#storing-information-from-previous-renders","title":"Storing information from previous renders","text":"<p>Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering -- for example, you might want to change a state variable when a prop changes.</p> <p>In most cases, you don't need this:</p> <ul> <li>If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you're worried about recomputing too often, the <code>useMemo</code> Hook can help.</li> <li>If you want to reset the entire component tree's state, pass a different <code>key</code> to your component.</li> <li>If you can, update all the relevant state in the event handlers.</li> </ul> <p>In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a <code>set</code> function while your component is rendering.</p> <p>Here's an example. This <code>CountLabel</code> component displays the <code>count</code> prop passed to it:</p> <pre><code>export default function CountLabel({ count }) {\nreturn &lt;h1&gt;{count}&lt;/h1&gt;;\n}\n</code></pre> <p>Say you want to show whether the counter has increased or decreased since the last change. The <code>count</code> prop doesn't tell you this -- you need to keep track of its previous value. Add the <code>prevCount</code> state variable to track it. Add another state variable called <code>trend</code> to hold whether the count has increased or decreased. Compare <code>prevCount</code> with <code>count</code>, and if they're not equal, update both <code>prevCount</code> and <code>trend</code>. Now you can show both the current count prop and how it has changed since the last render.</p> <pre><code>import { useState } from \"react\";\nimport CountLabel from \"./CountLabel.js\";\n\nexport default function App() {\nconst [count, setCount] = useState(0);\nreturn (\n&lt;&gt;\n&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n&lt;button onClick={() =&gt; setCount(count - 1)}&gt;Decrement&lt;/button&gt;\n&lt;CountLabel count={count} /&gt;\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>import { useState } from \"react\";\n\nexport default function CountLabel({ count }) {\nconst [prevCount, setPrevCount] = useState(count);\nconst [trend, setTrend] = useState(null);\nif (prevCount !== count) {\nsetPrevCount(count);\nsetTrend(count &gt; prevCount ? \"increasing\" : \"decreasing\");\n}\nreturn (\n&lt;&gt;\n&lt;h1&gt;{count}&lt;/h1&gt;\n{trend &amp;&amp; &lt;p&gt;The count is {trend}&lt;/p&gt;}\n&lt;/&gt;\n);\n}\n</code></pre> <pre><code>button {\nmargin-bottom: 10px;\n}\n</code></pre> <p>Note that if you call a <code>set</code> function while rendering, it must be inside a condition like <code>prevCount !== count</code>, and there must be a call like <code>setPrevCount(count)</code> inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the <code>set</code> function of another component during rendering is an error. Finally, your <code>set</code> call should still update state without mutation -- this doesn't mean you can break other rules of pure functions.</p> <p>This pattern can be hard to understand and is usually best avoided. However, it's better than updating state in an effect. When you call the <code>set</code> function during render, React will re-render that component immediately after your component exits with a <code>return</code> statement, and before rendering the children. This way, children don't need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early <code>return;</code> to restart rendering earlier.</p>"},{"location":"reference/use-state/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/use-state/#ive-updated-the-state-but-logging-gives-me-the-old-value","title":"I've updated the state, but logging gives me the old value","text":"<p>Calling the <code>set</code> function does not change state in the running code:</p> <pre><code>function handleClick() {\nconsole.log(count); // 0\n\nsetCount(count + 1); // Request a re-render with 1\nconsole.log(count); // Still 0!\n\nsetTimeout(() =&gt; {\nconsole.log(count); // Also 0!\n}, 5000);\n}\n</code></pre> <p>This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the <code>count</code> JavaScript variable in your already-running event handler.</p> <p>If you need to use the next state, you can save it in a variable before passing it to the <code>set</code> function:</p> <pre><code>const nextCount = count + 1;\nsetCount(nextCount);\n\nconsole.log(count); // 0\nconsole.log(nextCount); // 1\n</code></pre>"},{"location":"reference/use-state/#ive-updated-the-state-but-the-screen-doesnt-update","title":"I've updated the state, but the screen doesn't update","text":"<p>React will ignore your update if the next state is equal to the previous state, as determined by an <code>Object.is</code> comparison. This usually happens when you change an object or an array in state directly:</p> <pre><code>obj.x = 10; // \ud83d\udea9 Wrong: mutating existing object\nsetObj(obj); // \ud83d\udea9 Doesn't do anything\n</code></pre> <p>You mutated an existing <code>obj</code> object and passed it back to <code>setObj</code>, so React ignored the update. To fix this, you need to ensure that you're always replacing objects and arrays in state instead of mutating them:</p> <pre><code>// \u2705 Correct: creating a new object\nsetObj({\n...obj,\nx: 10,\n});\n</code></pre>"},{"location":"reference/use-state/#im-getting-an-error-too-many-re-renders","title":"I'm getting an error: \"Too many re-renders\"","text":"<p>You might get an error that says: <code>Too many re-renders. React limits the number of renders to prevent an infinite loop.</code> Typically, this means that you're unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:</p> <pre><code>// \ud83d\udea9 Wrong: calls the handler during render\nreturn &lt;button onClick={handleClick()}&gt;Click me&lt;/button&gt;;\n\n// \u2705 Correct: passes down the event handler\nreturn &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;\n\n// \u2705 Correct: passes down an inline function\nreturn &lt;button onClick={(e) =&gt; handleClick(e)}&gt;Click me&lt;/button&gt;;\n</code></pre> <p>If you can't find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific <code>set</code> function call responsible for the error.</p>"},{"location":"reference/use-state/#my-initializer-or-updater-function-runs-twice","title":"My initializer or updater function runs twice","text":"<p>In Strict Mode, React will call some of your functions twice instead of once:</p> <pre><code>function TodoList() {\n// This component function will run twice for every render.\n\nconst [todos, setTodos] = useState(() =&gt; {\n// This initializer function will run twice during initialization.\nreturn createTodos();\n});\n\nfunction handleClick() {\nsetTodos(prevTodos =&gt; {\n// This updater function will run twice for every click.\nreturn [...prevTodos, createTodo()];\n});\n}\n// ...\n</code></pre> <p>This is expected and shouldn't break your code.</p> <p>This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.</p> <p>For example, this impure updater function mutates an array in state:</p> <pre><code>setTodos((prevTodos) =&gt; {\n// \ud83d\udea9 Mistake: mutating state\nprevTodos.push(createTodo());\n});\n</code></pre> <p>Because React calls your updater function twice, you'll see the todo was added twice, so you'll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:</p> <pre><code>setTodos((prevTodos) =&gt; {\n// \u2705 Correct: replacing with new state\nreturn [...prevTodos, createTodo()];\n});\n</code></pre> <p>Now that this updater function is pure, calling it an extra time doesn't make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don't need to be pure, so React will never call your event handlers twice.</p> <p>Read keeping components pure to learn more.</p>"},{"location":"reference/use-state/#im-trying-to-set-state-to-a-function-but-it-gets-called-instead","title":"I'm trying to set state to a function, but it gets called instead","text":"<p>You can't put a function into state like this:</p> <pre><code>const [fn, setFn] = useState(someFunction);\n\nfunction handleClick() {\nsetFn(someOtherFunction);\n}\n</code></pre> <p>Because you're passing a function, React assumes that <code>someFunction</code> is an initializer function, and that <code>someOtherFunction</code> is an updater function, so it tries to call them and store the result. To actually store a function, you have to put <code>() =&gt;</code> before them in both cases. Then React will store the functions you pass.</p> <pre><code>const [fn, setFn] = useState(() =&gt; someFunction);\n\nfunction handleClick() {\nsetFn(() =&gt; someOtherFunction);\n}\n</code></pre>"},{"location":"reference/use-sync-external-store/","title":"Use sync external store","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"},{"location":"reference/use-transition/","title":"Use transition","text":"<p>Planned / Undeveloped</p> <p>This feature is planned, but not yet developed.</p>"}]}