from __future__ import annotations

import asyncio
import dis
from collections.abc import Sequence
from typing import Any, Callable, Literal, cast, overload

from anyio import create_task_group

from reactpy.types import EventHandlerFunc, EventHandlerType


@overload
def event(
    function: Callable[..., Any],
    *,
    stop_propagation: bool = ...,
    prevent_default: bool = ...,
) -> EventHandler: ...


@overload
def event(
    function: Literal[None] = ...,
    *,
    stop_propagation: bool = ...,
    prevent_default: bool = ...,
) -> Callable[[Callable[..., Any]], EventHandler]: ...


def event(
    function: Callable[..., Any] | None = None,
    *,
    stop_propagation: bool = False,
    prevent_default: bool = False,
) -> EventHandler | Callable[[Callable[..., Any]], EventHandler]:
    """A decorator for constructing an :class:`EventHandler`.

    While you're always free to add callbacks by assigning them to an element's attributes

    .. code-block:: python

        element = reactpy.html.button({"onClick": my_callback})

    You may want the ability to prevent the default action associated with the event
    from taking place, or stopping the event from propagating up the DOM. This decorator
    allows you to add that functionality to your callbacks.

    .. code-block:: python

        @event(stop_propagation=True, prevent_default=True)
        def my_callback(*data): ...


        element = reactpy.html.button({"onClick": my_callback})

    Parameters:
        function:
            A function or coroutine responsible for handling the event.
        stop_propagation:
            Block the event from propagating further up the DOM.
        prevent_default:
            Stops the default actional associate with the event from taking place.
    """

    def setup(function: Callable[..., Any]) -> EventHandler:
        return EventHandler(
            to_event_handler_function(function, positional_args=True),
            stop_propagation,
            prevent_default,
        )

    return setup(function) if function is not None else setup


class EventHandler:
    """Turn a function or coroutine into an event handler

    Parameters:
        function:
            The function or coroutine which handles the event.
        stop_propagation:
            Block the event from propagating further up the DOM.
        prevent_default:
            Stops the default action associate with the event from taking place.
        target:
            A unique identifier for this event handler (auto-generated by default)
    """

    __slots__ = (
        "__weakref__",
        "function",
        "prevent_default",
        "stop_propagation",
        "target",
    )

    def __init__(
        self,
        function: EventHandlerFunc,
        stop_propagation: bool = False,
        prevent_default: bool = False,
        target: str | None = None,
    ) -> None:
        self.function = to_event_handler_function(function, positional_args=False)
        self.prevent_default = prevent_default
        self.stop_propagation = stop_propagation
        self.target = target

        # Check if our `preventDefault` or `stopPropagation` methods were called
        # by inspecting the function's bytecode
        func_to_inspect = cast(Any, function)
        while hasattr(func_to_inspect, "__wrapped__"):
            func_to_inspect = func_to_inspect.__wrapped__

        code = func_to_inspect.__code__
        if code.co_argcount > 0:
            event_arg_name = code.co_varnames[0]
            last_was_event = False

            for instr in dis.get_instructions(func_to_inspect):
                if instr.opname == "LOAD_FAST" and instr.argval == event_arg_name:
                    last_was_event = True
                    continue

                if last_was_event and instr.opname in (
                    "LOAD_METHOD",
                    "LOAD_ATTR",
                ):
                    if instr.argval == "preventDefault":
                        self.prevent_default = True
                    elif instr.argval == "stopPropagation":
                        self.stop_propagation = True

                last_was_event = False

    __hash__ = None  # type: ignore

    def __eq__(self, other: object) -> bool:
        undefined = object()
        return not any(
            not attr.startswith("_")
            and not getattr(other, attr, undefined) == getattr(self, attr)
            for attr in (
                "function",
                "prevent_default",
                "stop_propagation",
                "target",
            )
        )

    def __repr__(self) -> str:
        public_names = [name for name in self.__slots__ if not name.startswith("_")]
        items = ", ".join([f"{n}={getattr(self, n)!r}" for n in public_names])
        return f"{type(self).__name__}({items})"


def to_event_handler_function(
    function: Callable[..., Any],
    positional_args: bool = True,
) -> EventHandlerFunc:
    """Make a :data:`~reactpy.core.proto.EventHandlerFunc` from a function or coroutine

    Parameters:
        function:
            A function or coroutine accepting a number of positional arguments.
        positional_args:
            Whether to pass the event parameters a positional args or as a list.
    """
    if positional_args:
        if asyncio.iscoroutinefunction(function):

            async def wrapper(data: Sequence[Any]) -> None:
                await function(*data)

            cast(Any, wrapper).__wrapped__ = function

        else:

            async def wrapper(data: Sequence[Any]) -> None:
                function(*data)

        cast(Any, wrapper).__wrapped__ = function
        return wrapper
    elif not asyncio.iscoroutinefunction(function):

        async def wrapper(data: Sequence[Any]) -> None:
            function(data)

        cast(Any, wrapper).__wrapped__ = function
        return wrapper
    else:
        return function


def merge_event_handlers(
    event_handlers: Sequence[EventHandlerType],
) -> EventHandlerType:
    """Merge multiple event handlers into one

    Raises a ValueError if any handlers have conflicting
    :attr:`~reactpy.core.proto.EventHandlerType.stop_propagation` or
    :attr:`~reactpy.core.proto.EventHandlerType.prevent_default` attributes.
    """
    if not event_handlers:
        msg = "No event handlers to merge"
        raise ValueError(msg)
    elif len(event_handlers) == 1:
        return event_handlers[0]

    first_handler = event_handlers[0]

    stop_propagation = first_handler.stop_propagation
    prevent_default = first_handler.prevent_default
    target = first_handler.target

    for handler in event_handlers:
        if (
            handler.stop_propagation != stop_propagation
            or handler.prevent_default != prevent_default
            or handler.target != target
        ):
            msg = "Cannot merge handlers - 'stop_propagation', 'prevent_default' or 'target' mismatch."
            raise ValueError(msg)

    return EventHandler(
        merge_event_handler_funcs([h.function for h in event_handlers]),
        stop_propagation,
        prevent_default,
        target,
    )


def merge_event_handler_funcs(
    functions: Sequence[EventHandlerFunc],
) -> EventHandlerFunc:
    """Make one event handler function from many"""
    if not functions:
        msg = "No event handler functions to merge"
        raise ValueError(msg)
    elif len(functions) == 1:
        return functions[0]

    async def await_all_event_handlers(data: Sequence[Any]) -> None:
        async with create_task_group() as group:
            for func in functions:
                group.start_soon(func, data)

    return await_all_event_handlers
