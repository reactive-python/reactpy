import abc
import asyncio
from types import coroutine
from typing import (
    List,
    Dict,
    Tuple,
    Mapping,
    NamedTuple,
    Any,
    Set,
    Generic,
    TypeVar,
    Optional,
    Iterator,
    AsyncIterator,
    Awaitable,
    TypeVar,
    Callable,
)

from mypy_extensions import TypedDict
from loguru import logger

from .element import AbstractElement
from .events import EventHandler
from .utils import HasAsyncResources, async_resource
from .vdom import VdomDict
from .hooks import LifeCycleHook


_Self = TypeVar("_Self")


class LayoutUpdate(NamedTuple):
    """An object describing an update to a :class:`Layout`"""

    src: str
    """element ID for the update's source"""

    new: Dict[str, Dict[str, Any]]
    """maps element IDs to new models"""

    old: List[str]
    """element IDs that have been deleted"""


class LayoutEvent(NamedTuple):
    target: str
    """The ID of the event handler."""
    data: List[Any]
    """A list of event data passed to the event handler."""


class AbstractLayout(HasAsyncResources, abc.ABC):
    """Renders the models generated by :class:`AbstractElement` objects.

    Parameters:
        root: The root element of the layout.
        loop: What loop the layout should be using to schedule tasks.
    """

    __slots__ = ["_loop", "_root"]

    if not hasattr(abc.ABC, "__weakref__"):  # pragma: no cover
        __slots__.append("__weakref__")

    def __init__(
        self, root: "AbstractElement", loop: Optional[asyncio.AbstractEventLoop] = None
    ) -> None:
        super().__init__()
        if loop is None:
            loop = asyncio.get_event_loop()
        if not isinstance(root, AbstractElement):
            raise TypeError("Expected an AbstractElement, not %r" % root)
        self._loop = loop
        self._root = root

    @property
    def loop(self) -> asyncio.AbstractEventLoop:
        """The event loop the layout is using."""
        return self._loop

    @property
    def root(self) -> str:
        """Id of the root element."""
        return self._root.id

    @abc.abstractmethod
    async def render(self) -> LayoutUpdate:
        """Await an update to the model."""

    @abc.abstractmethod
    def update(self, element: AbstractElement) -> None:
        """Schedule the element to be re-renderer."""

    @abc.abstractmethod
    async def trigger(self, event: LayoutEvent) -> None:
        """Trigger an event handler

        Parameters:
            event: Event data passed to the event handler.
        """


class _LayoutState(TypedDict):
    event_handlers: Dict[str, EventHandler]
    element_states: Dict[str, "ElementState"]
    schedule_element_render: Callable[[AbstractElement], None]


class Layout(AbstractLayout):

    __slots__ = "_global_layout_state", "_root_element_state"

    def __init__(
        self, root: "AbstractElement", loop: Optional[asyncio.AbstractEventLoop] = None
    ) -> None:
        super().__init__(root, loop)
        self._global_layout_state: _LayoutState = {
            "event_handlers": {},
            "element_states": {},
            "schedule_element_render": self.update,
        }

    def update(self, element: "AbstractElement") -> None:
        self._rendering_queue.put(self._render_layout_update(element))

    async def trigger(self, event: LayoutEvent) -> None:
        # It is possible for an element in the frontend to produce an event
        # associated with a backend model that has been deleted. We only handle
        # events if the element and the handler exist in the backend. Otherwise
        # we just ignore the event.
        handler = self._global_layout_state["event_handlers"].get(event.target)
        if handler is not None:
            await handler(event.data)

    async def render(self) -> LayoutUpdate:
        return await self._rendering_queue.get()

    @async_resource
    async def _rendering_queue(self) -> AsyncIterator["FutureQueue[LayoutUpdate]"]:
        queue: FutureQueue[LayoutUpdate] = FutureQueue()
        queue.put(self._render_layout_update(self._root))
        try:
            yield queue
        finally:
            await queue.cancel()

    @async_resource
    async def _root_element_state(self):
        root_state = ElementState(self._global_layout_state, self._root)
        root_state.update()
        try:
            yield root_state
        finally:
            root_state.unmount()

    async def _render_layout_update(self, element: AbstractElement) -> LayoutUpdate:
        # current element ids
        element_ids_pre_render = set(self._global_layout_state["element_states"])

        # all element updates
        new: Dict[str, Dict[str, Any]] = {}
        element_state = self._global_layout_state["element_states"][element.id]
        async for element_id, model in element_state.render():
            new[element_id] = model

        element_ids_post_render = set(self._global_layout_state["element_states"])

        return LayoutUpdate(
            element.id,
            new,
            list(element_ids_pre_render.difference(element_ids_post_render)),
        )


class ElementState:

    __slots__ = (
        "_layout_state",
        "_element",
        "_event_handler_ids",
        "_child_state_managers",
        "_life_cycle_hook",
    )

    def __init__(self, layout_state: "_LayoutState", element: AbstractElement) -> None:
        layout_state["element_states"][element.id] = self
        self._layout_state = layout_state
        self._element = element
        self._event_handler_ids: Set[str] = set()
        self._child_state_managers: List[ElementState] = []
        self._life_cycle_hook = LifeCycleHook(self)

    @property
    def element_id(self):
        return self._element.id

    def update(self):
        self._layout_state["schedule_element_render"](self._element)

    async def render(self) -> AsyncIterator[Tuple[str, Any]]:
        model_resolution = _resolve_model(await self._render())

        self._event_handler_ids.clear()
        for handler_id in self._event_handler_ids:
            del self._layout_state[handler_id]
        for child_state in self._child_state_managers:
            child_state.unmount()
        self._child_state_managers.clear()

        for event_handler in model_resolution.event_handlers:
            self._event_handler_ids.add(event_handler.id)
            self._layout_state["event_handlers"][event_handler.id] = event_handler

        yield self._element.id, model_resolution.resolved_model

        for child_element in model_resolution.child_elements:
            try:
                child_state = self._create_child_state(child_element)
                async for e_id, e_model in child_state.render():
                    yield e_id, e_model
            except asyncio.CancelledError:
                raise  # we don't want to supress cancellations
            except Exception as error:
                logger.exception(f"Failed to render {child_element.id}")
                yield child_element.id, {
                    "tagName": "div",
                    "attributes": {"__error__": str(error)},
                }

        self._life_cycle_hook.element_did_render()

    def unmount(self):
        element_id = self._element.id
        del self._layout_state["element_states"][element_id]
        for handler_id in self._event_handler_ids:
            del self._layout_state["event_handlers"][handler_id]
        for state in self._child_state_managers:
            state.unmount()
        self._life_cycle_hook.element_will_unmount()

    @coroutine
    def _render(self) -> Iterator[None]:
        """Render an element which may use hooks.

        We use a coroutine here because we need to know when control is yielded
        back to the event loop since it might switch to render a different element.
        """
        gen = self._element.render().__await__()
        while True:
            self._life_cycle_hook.set_current()
            try:
                yield next(gen)
            except StopIteration as error:
                return error.value
            finally:
                self._life_cycle_hook.unset_current()

    def _create_child_state(self, element: AbstractElement) -> "ElementState":
        state = ElementState(self._layout_state, element)
        self._child_state_managers.append(state)
        return state


class _ModelResolution(NamedTuple):
    resolved_model: Dict[str, Any]
    event_handlers: List[EventHandler]
    child_elements: List[AbstractElement]


def _resolve_model(model: VdomDict) -> _ModelResolution:
    resolved_model: Dict[str, Any] = dict(model)

    event_handler_resolution = _resolve_model_event_handlers(model)
    if event_handler_resolution.event_targets:
        resolved_model["eventHandlers"] = event_handler_resolution.event_targets
    event_handlers = event_handler_resolution.event_handlers

    if "children" in model:
        child_resolution = _resolve_model_children(model["children"])
        resolved_model["children"] = child_resolution.resolved_models
        event_handlers += child_resolution.event_handlers
        child_elements = child_resolution.child_elements
    else:
        child_elements = []

    return _ModelResolution(
        resolved_model=resolved_model,
        event_handlers=event_handlers,
        child_elements=child_elements,
    )


_ResolvedChild = Dict[str, Dict[str, str]]


class _ChildResolution(NamedTuple):
    resolved_models: List[Dict[str, Dict[str, str]]]
    event_handlers: List[EventHandler]
    child_elements: List[AbstractElement]


def _resolve_model_children(children: List[Any]) -> _ChildResolution:
    if not isinstance(children, (list, tuple)):
        children = [children]

    resolved_models: List[_ResolvedChild] = []
    event_handlers: List[EventHandler] = []
    child_elements: List[EventHandler] = []

    for child in children:
        if isinstance(child, Mapping):
            inner_resolution = _resolve_model(child)
            resolved_child = {"type": "obj", "data": inner_resolution.resolved_model}
            event_handlers += inner_resolution.event_handlers
            child_elements += inner_resolution.child_elements
        elif isinstance(child, AbstractElement):
            resolved_child = {"type": "ref", "data": child.id}
            child_elements.append(child)
        else:
            resolved_child = {"type": "str", "data": str(child)}
        resolved_models.append(resolved_child)

    return _ChildResolution(
        resolved_models=resolved_models,
        event_handlers=event_handlers,
        child_elements=child_elements,
    )


_EventTargets = Dict[str, str]


class _EventHandlerResolution(NamedTuple):
    event_targets: Dict[str, str]
    event_handlers: List[EventHandler]


def _resolve_model_event_handlers(model: VdomDict) -> _EventHandlerResolution:
    handlers: Dict[str, EventHandler] = {}
    if "eventHandlers" in model:
        handlers.update(model["eventHandlers"])
    if "attributes" in model:
        attrs = model["attributes"]
        for k, v in list(attrs.items()):
            if callable(v):
                if not isinstance(v, EventHandler):
                    h = handlers[k] = EventHandler()
                    h.add(attrs.pop(k))
                else:
                    h = attrs.pop(k)
                    handlers[k] = h

    return _EventHandlerResolution(
        event_targets={e: h.serialize() for e, h in handlers.items()},
        event_handlers=list(handlers.values()),
    )


# future queue type
_FQT = TypeVar("_FQT")


class FutureQueue(Generic[_FQT]):
    """A queue which returns the result of futures as they complete."""

    def __init__(self) -> None:
        self._loop = asyncio.get_event_loop()
        self._pending: Dict[int, asyncio.Future[_FQT]] = {}
        self._done: asyncio.Queue[asyncio.Future[_FQT]] = asyncio.Queue()

    def put(self, awaitable: Awaitable[_FQT]) -> None:
        """Put an awaitable in the queue

        The result will be returned by a call to :meth:`FutureQueue.get` only
        when the awaitable has completed.
        """

        async def wrapper() -> None:
            future = asyncio.ensure_future(awaitable)
            self._pending[id(future)] = future
            try:
                await future
            finally:
                del self._pending[id(future)]
                await self._done.put(future)
            return None

        asyncio.run_coroutine_threadsafe(wrapper(), self._loop)
        return None

    async def get(self) -> _FQT:
        """Get the result of a queued awaitable that has completed."""
        future = await self._done.get()
        return await future

    async def cancel(self) -> None:
        for f in self._pending.values():
            f.cancel()
        if self._pending:
            await asyncio.wait(
                list(self._pending.values()), return_when=asyncio.ALL_COMPLETED
            )
