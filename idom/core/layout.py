import abc
import asyncio
from typing import (
    List,
    Dict,
    Tuple,
    Mapping,
    NamedTuple,
    Any,
    Set,
    Generic,
    TypeVar,
    Optional,
    AsyncIterator,
    Awaitable,
    TypeVar,
)

from mypy_extensions import TypedDict
from loguru import logger

from .element import AbstractElement
from .events import EventHandler
from .utils import HasAsyncResources, async_resource
from .vdom import VdomDict
from ._hooks import HookDispatcher


_Self = TypeVar("_Self")


class LayoutUpdate(NamedTuple):
    """An object describing an update to a :class:`Layout`"""

    src: str
    """element ID for the update's source"""

    new: Dict[str, Dict[str, Any]]
    """maps element IDs to new models"""

    old: List[str]
    """element IDs that have been deleted"""


class LayoutEvent(NamedTuple):
    target: str
    """The ID of the event handler."""
    data: List[Any]
    """A list of event data passed to the event handler."""


class AbstractLayout(HasAsyncResources, abc.ABC):
    """Renders the models generated by :class:`AbstractElement` objects.

    Parameters:
        root: The root element of the layout.
        loop: What loop the layout should be using to schedule tasks.
    """

    __slots__ = ["_loop", "_root"]

    if not hasattr(abc.ABC, "__weakref__"):  # pragma: no cover
        __slots__.append("__weakref__")

    def __init__(
        self, root: "AbstractElement", loop: Optional[asyncio.AbstractEventLoop] = None
    ) -> None:
        super().__init__()
        if loop is None:
            loop = asyncio.get_event_loop()
        if not isinstance(root, AbstractElement):
            raise TypeError("Expected an AbstractElement, not %r" % root)
        self._loop = loop
        self._root = root

    @property
    def loop(self) -> asyncio.AbstractEventLoop:
        """The event loop the layout is using."""
        return self._loop

    @property
    def root(self) -> str:
        """Id of the root element."""
        return self._root.id

    @abc.abstractmethod
    async def render(self) -> LayoutUpdate:
        """Await an update to the model."""

    @abc.abstractmethod
    def update(self, element: AbstractElement) -> None:
        """Schedule the element to be re-renderer."""

    @abc.abstractmethod
    async def trigger(self, event: LayoutEvent) -> None:
        """Trigger an event handler

        Parameters:
            event: Event data passed to the event handler.
        """


class Layout(AbstractLayout):

    __slots__ = "_event_handlers", "_hook_dispatcher"

    def __init__(
        self, root: "AbstractElement", loop: Optional[asyncio.AbstractEventLoop] = None
    ) -> None:
        super().__init__(root, loop)
        self._hook_dispatcher = HookDispatcher(self)

    def update(self, element: "AbstractElement") -> None:
        self._rendering_queue.put(self._render_layout_update(element))

    async def trigger(self, event: LayoutEvent) -> None:
        # It is possible for an element in the frontend to produce an event
        # associated with a backend model that has been deleted. We only handle
        # events if the element and the handler exist in the backend. Otherwise
        # we just ignore the event.
        handler = self._state_manager.get_event_handler(event.target)
        if handler is not None:
            await handler(event.data)

    async def render(self) -> LayoutUpdate:
        return await self._rendering_queue.get()

    @async_resource
    async def _state_manager(self) -> AsyncIterator[Dict[str, "StateManager"]]:
        sm = StateManager(self)
        try:
            yield sm
        finally:
            await sm.delete_element_state(self._root.id)

    @async_resource
    async def _rendering_queue(self) -> AsyncIterator["FutureQueue[LayoutUpdate]"]:
        queue: FutureQueue[LayoutUpdate] = FutureQueue()
        queue.put(self._render_layout_update(self._root))
        try:
            yield queue
        finally:
            await queue.cancel()

    async def _render_layout_update(self, element: AbstractElement) -> LayoutUpdate:
        # current element ids
        element_ids_pre_render = self._state_manager.get_element_ids_in_layout()

        # all element updates
        new: Dict[str, Dict[str, Any]] = {}

        parent = self._state_manager.get_parent_element_id(element)

        async for element_id, model in self._render_layout_subtree(element, parent):
            new[element_id] = model

        element_ids_post_render = self._state_manager.get_element_ids_in_layout()

        return LayoutUpdate(
            element.id,
            new,
            list(element_ids_pre_render.difference(element_ids_post_render)),
        )

    async def _render_layout_subtree(
        self, element: "AbstractElement", parent_element_id: Optional[str]
    ) -> Tuple[Tuple[str, Dict[str, Any]]]:
        element_id = element.id
        if self._state_manager.has_element_state(element_id):
            await self._state_manager.reset_element_state(element)
        else:
            await self._state_manager.create_element_state(element, parent_element_id)

        async with self._hook_dispatcher.render(element) as model:

            if isinstance(model, AbstractElement):
                model = {"tagName": "div", "children": [model]}

            model_resolution = _resolve_model(model)

            yield element_id, model_resolution.resolved_model

            self._state_manager._element_state[element.id]["event_handlers"] = [
                h.id for h in model_resolution.event_handlers
            ]
            self._state_manager._event_handlers.update(
                {h.id: h for h in model_resolution.event_handlers}
            )

            for inner_element in model_resolution.child_elements:
                try:
                    subtree = self._render_layout_subtree(inner_element, element_id)
                    async for i, m in subtree:
                        yield i, m
                except asyncio.CancelledError:
                    raise  # we don't want to supress cancellations
                except Exception as error:
                    logger.exception(f"Failed to render {inner_element}")
                    yield inner_element.id, {
                        "tagName": "div",
                        "attributes": {"__error__": str(error)},
                    }


class _ElementState(TypedDict):
    parent: Optional[str]
    inner_elements: Set[str]
    event_handlers: List[str]


class StateManager:

    __slots__ = "_layout", "_element_state", "_event_handlers"

    def __init__(self, layout: Layout) -> None:
        self._layout = layout
        self._element_state: Dict[str, _ElementState] = {}
        self._event_handlers: Dict[str, EventHandler] = {}

    def get_element_ids_in_layout(self) -> Set[str]:
        return set(self._element_state)

    def get_event_handler(self, target: str) -> Optional[EventHandler]:
        return self._event_handlers.get(target)

    def has_element_state(self, element_id: str) -> bool:
        return element_id in self._element_state

    def get_parent_element_id(self, element: AbstractElement) -> Optional[str]:
        try:
            parent_id = self._element_state[element.id]["parent"]
        except KeyError:
            if element.id != self._layout.root:
                raise
            return None
        else:
            return parent_id

    async def create_element_state(
        self, element: AbstractElement, parent_element_id: Optional[str]
    ) -> None:
        if parent_element_id is not None and self.has_element_state(parent_element_id):
            self._element_state[parent_element_id]["inner_elements"].add(element.id)
        self._element_state[element.id] = {
            "parent": parent_element_id,
            "inner_elements": set(),
            "event_handlers": [],
        }

    async def reset_element_state(self, element: AbstractElement) -> None:
        parent_element_id = self._element_state[element.id]["parent"]
        await self.delete_element_state(element.id, unmount=False)
        await self.create_element_state(element, parent_element_id)

    async def delete_element_state(self, element_id: str, unmount: bool = True) -> None:
        old = self._element_state.pop(element_id)
        parent_element_id = old["parent"]
        if parent_element_id is not None and self.has_element_state(parent_element_id):
            self._element_state[parent_element_id]["inner_elements"].remove(element_id)
        for handler_id in old["event_handlers"]:
            del self._event_handlers[handler_id]
        for i in old["inner_elements"]:
            # don't pass on 'unmount' since that only applies to the root
            await self.delete_element_state(i)


class _ModelResolution(NamedTuple):
    resolved_model: Dict[str, Any]
    event_handlers: List[EventHandler]
    child_elements: List[AbstractElement]


def _resolve_model(model: VdomDict) -> _ModelResolution:
    resolved_model: Dict[str, Any] = dict(model)

    event_handler_resolution = _resolve_model_event_handlers(model)
    if event_handler_resolution.event_targets:
        resolved_model["eventHandlers"] = event_handler_resolution.event_targets
    event_handlers = event_handler_resolution.event_handlers

    if "children" in model:
        child_resolution = _resolve_model_children(model["children"])
        resolved_model["children"] = child_resolution.resolved_models
        event_handlers += child_resolution.event_handlers
        child_elements = child_resolution.child_elements
    else:
        child_elements = []

    return _ModelResolution(
        resolved_model=resolved_model,
        event_handlers=event_handlers,
        child_elements=child_elements,
    )


_ResolvedChild = Dict[str, Dict[str, str]]


class _ChildResolution(NamedTuple):
    resolved_models: List[Dict[str, Dict[str, str]]]
    event_handlers: List[EventHandler]
    child_elements: List[AbstractElement]


def _resolve_model_children(children: List[Any]) -> _ChildResolution:
    if not isinstance(children, (list, tuple)):
        children = [children]

    resolved_models: List[_ResolvedChild] = []
    event_handlers: List[EventHandler] = []
    child_elements: List[EventHandler] = []

    for child in children:
        if isinstance(child, Mapping):
            inner_resolution = _resolve_model(child)
            resolved_child = {"type": "obj", "data": inner_resolution.resolved_model}
            event_handlers += inner_resolution.event_handlers
            child_elements += inner_resolution.child_elements
        elif isinstance(child, AbstractElement):
            resolved_child = {"type": "ref", "data": child.id}
            child_elements.append(child)
        else:
            resolved_child = {"type": "str", "data": str(child)}
        resolved_models.append(resolved_child)

    return _ChildResolution(
        resolved_models=resolved_models,
        event_handlers=event_handlers,
        child_elements=child_elements,
    )


_EventTargets = Dict[str, str]


class _EventHandlerResolution(NamedTuple):
    event_targets: Dict[str, str]
    event_handlers: List[EventHandler]


def _resolve_model_event_handlers(model: VdomDict) -> _EventHandlerResolution:
    handlers: Dict[str, EventHandler] = {}
    if "eventHandlers" in model:
        handlers.update(model["eventHandlers"])
    if "attributes" in model:
        attrs = model["attributes"]
        for k, v in list(attrs.items()):
            if callable(v):
                if not isinstance(v, EventHandler):
                    h = handlers[k] = EventHandler()
                    h.add(attrs.pop(k))
                else:
                    h = attrs.pop(k)
                    handlers[k] = h

    return _EventHandlerResolution(
        event_targets={e: h.serialize() for e, h in handlers.items()},
        event_handlers=list(handlers.values()),
    )


# future queue type
_FQT = TypeVar("_FQT")


class FutureQueue(Generic[_FQT]):
    """A queue which returns the result of futures as they complete."""

    def __init__(self) -> None:
        self._loop = asyncio.get_event_loop()
        self._pending: Dict[int, asyncio.Future[_FQT]] = {}
        self._done: asyncio.Queue[asyncio.Future[_FQT]] = asyncio.Queue()

    def put(self, awaitable: Awaitable[_FQT]) -> None:
        """Put an awaitable in the queue

        The result will be returned by a call to :meth:`FutureQueue.get` only
        when the awaitable has completed.
        """

        async def wrapper() -> None:
            future = asyncio.ensure_future(awaitable)
            self._pending[id(future)] = future
            try:
                await future
            finally:
                del self._pending[id(future)]
                await self._done.put(future)
            return None

        asyncio.run_coroutine_threadsafe(wrapper(), self._loop)
        return None

    async def get(self) -> _FQT:
        """Get the result of a queued awaitable that has completed."""
        future = await self._done.get()
        return await future

    async def cancel(self) -> None:
        for f in self._pending.values():
            f.cancel()
        if self._pending:
            await asyncio.wait(
                list(self._pending.values()), return_when=asyncio.ALL_COMPLETED
            )
